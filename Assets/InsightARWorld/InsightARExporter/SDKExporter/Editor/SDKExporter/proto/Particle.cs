// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: particle.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ProtoPs {

  /// <summary>Holder for reflection information generated from particle.proto</summary>
  public static partial class ParticleReflection {

    #region Descriptor
    /// <summary>File descriptor for particle.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ParticleReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg5wYXJ0aWNsZS5wcm90bxIIcHJvdG9fcHMaCm1hdGgucHJvdG8aFHBhcnRp",
            "Y2xlX2VudW1zLnByb3RvGhZwYXJ0aWNsZV9zdHJ1Y3RzLnByb3RvIroLCgpN",
            "YWluTW9kdWxlEhAKCGR1cmF0aW9uGGUgASgCEi0KDnN0YXJ0Um90YXRpb25Y",
            "GGYgASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUSIAoYc3RhcnRSb3RhdGlv",
            "blhNdWx0aXBsaWVyGGcgASgCEi0KDnN0YXJ0Um90YXRpb25ZGGggASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSIAoYc3RhcnRSb3RhdGlvbllNdWx0aXBs",
            "aWVyGGkgASgCEi0KDnN0YXJ0Um90YXRpb25aGGogASgLMhUucHJvdG9fcHMu",
            "TWluTWF4Q3VydmUSIAoYc3RhcnRSb3RhdGlvblpNdWx0aXBsaWVyGGsgASgC",
            "EiIKGnJhbmRvbWl6ZVJvdGF0aW9uRGlyZWN0aW9uGGwgASgCEh8KF3N0YXJ0",
            "Um90YXRpb25NdWx0aXBsaWVyGG0gASgCEiwKCnN0YXJ0Q29sb3IYbiABKAsy",
            "GC5wcm90b19wcy5NaW5NYXhHcmFkaWVudBIhChlncmF2aXR5TW9kaWZpZXJN",
            "dWx0aXBsaWVyGG8gASgCEkAKD3NpbXVsYXRpb25TcGFjZRhwIAEoDjInLnBy",
            "b3RvX3BzLlBhcnRpY2xlU3lzdGVtU2ltdWxhdGlvblNwYWNlEjQKFWN1c3Rv",
            "bVNpbXVsYXRpb25TcGFjZRhxIAEoCzIVLnByb3RvX21hdGgudHJhbnNmb3Jt",
            "EhcKD3NpbXVsYXRpb25TcGVlZBhyIAEoAhIXCg91c2VVbnNjYWxlZFRpbWUY",
            "cyABKAgSOAoLc2NhbGluZ01vZGUYdCABKA4yIy5wcm90b19wcy5QYXJ0aWNs",
            "ZVN5c3RlbVNjYWxpbmdNb2RlEhMKC3BsYXlPbkF3YWtlGHUgASgIEi4KD2dy",
            "YXZpdHlNb2RpZmllchh2IAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhQK",
            "DG1heFBhcnRpY2xlcxh3IAEoBRIsCg1zdGFydFJvdGF0aW9uGHggASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSHAoUc3RhcnRTaXplWk11bHRpcGxpZXIY",
            "eSABKAISDAoEbG9vcBh6IAEoCBIPCgdwcmV3YXJtGHsgASgIEikKCnN0YXJ0",
            "RGVsYXkYfCABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIcChRzdGFydERl",
            "bGF5TXVsdGlwbGllchh9IAEoAhIsCg1zdGFydExpZmV0aW1lGH4gASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSHwoXc3RhcnRMaWZldGltZU11bHRpcGxp",
            "ZXIYfyABKAISKgoKc3RhcnRTcGVlZBiAASABKAsyFS5wcm90b19wcy5NaW5N",
            "YXhDdXJ2ZRIYCg9zdGFydFJvdGF0aW9uM0QYgQEgASgIEh0KFHN0YXJ0U3Bl",
            "ZWRNdWx0aXBsaWVyGIIBIAEoAhIpCglzdGFydFNpemUYgwEgASgLMhUucHJv",
            "dG9fcHMuTWluTWF4Q3VydmUSHAoTc3RhcnRTaXplTXVsdGlwbGllchiEASAB",
            "KAISKgoKc3RhcnRTaXplWBiFASABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2",
            "ZRIdChRzdGFydFNpemVYTXVsdGlwbGllchiGASABKAISKgoKc3RhcnRTaXpl",
            "WRiHASABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIdChRzdGFydFNpemVZ",
            "TXVsdGlwbGllchiIASABKAISKgoKc3RhcnRTaXplWhiJASABKAsyFS5wcm90",
            "b19wcy5NaW5NYXhDdXJ2ZRIUCgtzdGFydFNpemUzRBiKASABKAgSSQoTZW1p",
            "dHRlclZlbG9jaXR5TW9kZRiLASABKA4yKy5wcm90b19wcy5QYXJ0aWNsZVN5",
            "c3RlbUVtaXR0ZXJWZWxvY2l0eU1vZGUicQoSQ29sb3JCeVNwZWVkTW9kdWxl",
            "Eg8KB2VuYWJsZWQYZSABKAgSJwoFY29sb3IYZiABKAsyGC5wcm90b19wcy5N",
            "aW5NYXhHcmFkaWVudBIhCgVyYW5nZRhnIAEoCzISLnByb3RvX21hdGguZmxv",
            "YXQyIsoDChtUZXh0dXJlU2hlZXRBbmltYXRpb25Nb2R1bGUSFAoMdXNlUmFu",
            "ZG9tUm93GGUgASgIEg0KBWZsaXBVGGYgASgCEhAKCHJvd0luZGV4GGggASgF",
            "EhIKCmN5Y2xlQ291bnQYaSABKAUSHAoUc3RhcnRGcmFtZU11bHRpcGxpZXIY",
            "aiABKAISKQoKc3RhcnRGcmFtZRhrIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1",
            "cnZlEh8KF2ZyYW1lT3ZlclRpbWVNdWx0aXBsaWVyGGwgASgCEiwKDWZyYW1l",
            "T3ZlclRpbWUYbSABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRITCgtzcHJp",
            "dGVDb3VudBhuIAEoBRI4CglhbmltYXRpb24YbyABKA4yJS5wcm90b19wcy5Q",
            "YXJ0aWNsZVN5c3RlbUFuaW1hdGlvblR5cGUSEQoJbnVtVGlsZXNZGHAgASgF",
            "EhEKCW51bVRpbGVzWBhxIAEoBRIzCgRtb2RlGHIgASgOMiUucHJvdG9fcHMu",
            "UGFydGljbGVTeXN0ZW1BbmltYXRpb25Nb2RlEg8KB2VuYWJsZWQYcyABKAgS",
            "DQoFZmxpcFYYdCABKAIijQEKClN1YkVtaXR0ZXISCgoCcHMYASABKAkSNAoE",
            "dHlwZRgCIAEoDjImLnByb3RvX3BzLlBhcnRpY2xlU3lzdGVtU3ViRW1pdHRl",
            "clR5cGUSPQoHaW5oZXJpdBgDIAEoDjIsLnByb3RvX3BzLlBhcnRpY2xlU3lz",
            "dGVtU3ViRW1pdHRlclByb3BlcnRpZXMiaQoRU3ViRW1pdHRlcnNNb2R1bGUS",
            "DwoHZW5hYmxlZBgBIAEoCBIYChBzdWJFbWl0dGVyc0NvdW50GAIgASgFEikK",
            "C3N1YkVtaXR0ZXJzGAMgAygLMhQucHJvdG9fcHMuU3ViRW1pdHRlciI7ChRF",
            "eHRlcm5hbEZvcmNlc01vZHVsZRIPCgdlbmFibGVkGAEgASgIEhIKCm11bHRp",
            "cGxpZXIYAiABKAIihgIKFVJvdGF0aW9uQnlTcGVlZE1vZHVsZRIPCgdlbmFi",
            "bGVkGAogASgIEiAKAXgYCyABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIT",
            "Cgt4TXVsdGlwbGllchgMIAEoAhIgCgF5GA0gASgLMhUucHJvdG9fcHMuTWlu",
            "TWF4Q3VydmUSEwoLeU11bHRpcGxpZXIYDiABKAISIAoBehgPIAEoCzIVLnBy",
            "b3RvX3BzLk1pbk1heEN1cnZlEhMKC3pNdWx0aXBsaWVyGBAgASgCEhQKDHNl",
            "cGFyYXRlQXhlcxgRIAEoCBIhCgVyYW5nZRgSIAEoCzISLnByb3RvX21hdGgu",
            "ZmxvYXQyIugBChpSb3RhdGlvbk92ZXJMaWZldGltZU1vZHVsZRIPCgdlbmFi",
            "bGVkGAogASgIEiAKAXgYCyABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIT",
            "Cgt4TXVsdGlwbGllchgMIAEoAhIgCgF5GA0gASgLMhUucHJvdG9fcHMuTWlu",
            "TWF4Q3VydmUSEwoLeU11bHRpcGxpZXIYDiABKAISIAoBehgPIAEoCzIVLnBy",
            "b3RvX3BzLk1pbk1heEN1cnZlEhMKC3pNdWx0aXBsaWVyGBAgASgCEhQKDHNl",
            "cGFyYXRlQXhlcxgRIAEoCCK/AgoRU2l6ZUJ5U3BlZWRNb2R1bGUSDwoHZW5h",
            "YmxlZBgKIAEoCBIjCgRzaXplGAsgASgLMhUucHJvdG9fcHMuTWluTWF4Q3Vy",
            "dmUSFgoOc2l6ZU11bHRpcGxpZXIYDCABKAISIAoBeBgNIAEoCzIVLnByb3Rv",
            "X3BzLk1pbk1heEN1cnZlEhMKC3hNdWx0aXBsaWVyGA4gASgCEiAKAXkYDyAB",
            "KAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRITCgt5TXVsdGlwbGllchgQIAEo",
            "AhIgCgF6GBEgASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUSEwoLek11bHRp",
            "cGxpZXIYEiABKAISFAoMc2VwYXJhdGVBeGVzGBMgASgIEiEKBXJhbmdlGBQg",
            "ASgLMhIucHJvdG9fbWF0aC5mbG9hdDIioQIKFlNpemVPdmVyTGlmZXRpbWVN",
            "b2R1bGUSDwoHZW5hYmxlZBgKIAEoCBIjCgRzaXplGAsgASgLMhUucHJvdG9f",
            "cHMuTWluTWF4Q3VydmUSFgoOc2l6ZU11bHRpcGxpZXIYDCABKAISIAoBeBgN",
            "IAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhMKC3hNdWx0aXBsaWVyGA4g",
            "ASgCEiAKAXkYDyABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRITCgt5TXVs",
            "dGlwbGllchgQIAEoAhIgCgF6GBEgASgLMhUucHJvdG9fcHMuTWluTWF4Q3Vy",
            "dmUSEwoLek11bHRpcGxpZXIYEiABKAISFAoMc2VwYXJhdGVBeGVzGBMgASgI",
            "IvgBCg5FbWlzc2lvbk1vZHVsZRIPCgdlbmFibGVkGAogASgIEisKDHJhdGVP",
            "dmVyVGltZRgLIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEh4KFnJhdGVP",
            "dmVyVGltZU11bHRpcGxpZXIYDCABKAISLwoQcmF0ZU92ZXJEaXN0YW5jZRgN",
            "IAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEiIKGnJhdGVPdmVyRGlzdGFu",
            "Y2VNdWx0aXBsaWVyGA4gASgCEhIKCmJ1cnN0Q291bnQYDyABKAUSHwoGYnVy",
            "c3RzGBAgAygLMg8ucHJvdG9fcHMuQnVyc3QiUwoXQ29sb3JPdmVyTGlmZXRp",
            "bWVNb2R1bGUSDwoHZW5hYmxlZBgKIAEoCBInCgVjb2xvchgLIAEoCzIYLnBy",
            "b3RvX3BzLk1pbk1heEdyYWRpZW50IpsCChdGb3JjZU92ZXJMaWZldGltZU1v",
            "ZHVsZRIPCgdlbmFibGVkGAogASgIEiAKAXgYCyABKAsyFS5wcm90b19wcy5N",
            "aW5NYXhDdXJ2ZRIgCgF5GAwgASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUS",
            "IAoBehgNIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhMKC3hNdWx0aXBs",
            "aWVyGA4gASgCEhMKC3lNdWx0aXBsaWVyGA8gASgCEhMKC3pNdWx0aXBsaWVy",
            "GBAgASgCEjYKBXNwYWNlGBEgASgOMicucHJvdG9fcHMuUGFydGljbGVTeXN0",
            "ZW1TaW11bGF0aW9uU3BhY2USEgoKcmFuZG9taXplZBgSIAEoCCKiAQoVSW5o",
            "ZXJpdFZlbG9jaXR5TW9kdWxlEg8KB2VuYWJsZWQYCiABKAgSOQoEbW9kZRgL",
            "IAEoDjIrLnByb3RvX3BzLlBhcnRpY2xlU3lzdGVtSW5oZXJpdFZlbG9jaXR5",
            "TW9kZRIkCgVjdXJ2ZRgMIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhcK",
            "D2N1cnZlTXVsdGlwbGllchgNIAEoAiKSAwofTGltaXRWZWxvY2l0eU92ZXJM",
            "aWZldGltZU1vZHVsZRIPCgdlbmFibGVkGAogASgIEiUKBmxpbWl0WBgLIAEo",
            "CzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhgKEGxpbWl0WE11bHRpcGxpZXIY",
            "DCABKAISJQoGbGltaXRZGA0gASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUS",
            "GAoQbGltaXRZTXVsdGlwbGllchgOIAEoAhIlCgZsaW1pdFoYDyABKAsyFS5w",
            "cm90b19wcy5NaW5NYXhDdXJ2ZRIYChBsaW1pdFpNdWx0aXBsaWVyGBAgASgC",
            "EiQKBWxpbWl0GBEgASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUSFwoPbGlt",
            "aXRNdWx0aXBsaWVyGBIgASgCEg4KBmRhbXBlbhgTIAEoAhIUCgxzZXBhcmF0",
            "ZUF4ZXMYFCABKAgSNgoFc3BhY2UYFSABKA4yJy5wcm90b19wcy5QYXJ0aWNs",
            "ZVN5c3RlbVNpbXVsYXRpb25TcGFjZSKmBgoaVmVsb2NpdHlPdmVyTGlmZXRp",
            "bWVNb2R1bGUSDwoHZW5hYmxlZBgKIAEoCBIgCgF4GAsgASgLMhUucHJvdG9f",
            "cHMuTWluTWF4Q3VydmUSIAoBeRgMIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1",
            "cnZlEiAKAXoYDSABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRITCgt4TXVs",
            "dGlwbGllchgOIAEoAhITCgt5TXVsdGlwbGllchgPIAEoAhITCgt6TXVsdGlw",
            "bGllchgQIAEoAhI2CgVzcGFjZRgRIAEoDjInLnByb3RvX3BzLlBhcnRpY2xl",
            "U3lzdGVtU2ltdWxhdGlvblNwYWNlEicKCG9yYml0YWxYGBUgASgLMhUucHJv",
            "dG9fcHMuTWluTWF4Q3VydmUSGgoSb3JiaXRhbFhNdWx0aXBsaWVyGBYgASgC",
            "EicKCG9yYml0YWxZGBcgASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUSGgoS",
            "b3JiaXRhbFlNdWx0aXBsaWVyGBggASgCEicKCG9yYml0YWxaGBkgASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSGgoSb3JiaXRhbFpNdWx0aXBsaWVyGBog",
            "ASgCEiYKB29mZnNldFgYHyABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIZ",
            "ChFvZmZzZXRYTXVsdGlwbGllchggIAEoAhImCgdvZmZzZXRZGCEgASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSGQoRb2Zmc2V0WU11bHRpcGxpZXIYIiAB",
            "KAISJgoHb2Zmc2V0WhgjIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhkK",
            "EW9mZnNldFpNdWx0aXBsaWVyGCQgASgCEiYKBnJhZGlhbBiRAyABKAsyFS5w",
            "cm90b19wcy5NaW5NYXhDdXJ2ZRIZChByYWRpYWxNdWx0aXBsaWVyGJIDIAEo",
            "AhIlCgVzcGVlZBj1AyABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIYCg9z",
            "cGVlZE11bHRpcGxpZXIY9gMgASgCIuAGCgtTaGFwZU1vZHVsZRIPCgdlbmFi",
            "bGVkGGQgASgIEhwKFHVzZU1lc2hNYXRlcmlhbEluZGV4GGYgASgIEhkKEW1l",
            "c2hNYXRlcmlhbEluZGV4GGcgASgFEhUKDXVzZU1lc2hDb2xvcnMYaCABKAgS",
            "FAoMbm9ybWFsT2Zmc2V0GGkgASgCEgsKA2FyYxhrIAEoAhIRCglhcmNTcHJl",
            "YWQYbCABKAISJwoIYXJjU3BlZWQYbSABKAsyFS5wcm90b19wcy5NaW5NYXhD",
            "dXJ2ZRIaChJhcmNTcGVlZE11bHRpcGxpZXIYbiABKAISEwoLZG9udXRSYWRp",
            "dXMYbyABKAISJAoIcG9zaXRpb24YcCABKAsyEi5wcm90b19tYXRoLmZsb2F0",
            "MxIkCghyb3RhdGlvbhhxIAEoCzISLnByb3RvX21hdGguZmxvYXQ0EiEKBXNj",
            "YWxlGHMgASgLMhIucHJvdG9fbWF0aC5mbG9hdDMSKAoMYm94VGhpY2tuZXNz",
            "GHUgASgLMhIucHJvdG9fbWF0aC5mbG9hdDMSNAoJc2hhcGVUeXBlGHYgASgO",
            "MiEucHJvdG9fcHMuUGFydGljbGVTeXN0ZW1TaGFwZVR5cGUSHQoVcmFuZG9t",
            "RGlyZWN0aW9uQW1vdW50GHcgASgCEiAKGHNwaGVyaWNhbERpcmVjdGlvbkFt",
            "b3VudBh4IAEoAhIcChRyYW5kb21Qb3NpdGlvbkFtb3VudBh5IAEoAhIYChBh",
            "bGlnblRvRGlyZWN0aW9uGHogASgIEg4KBnJhZGl1cxh7IAEoAhIqCgtyYWRp",
            "dXNTcGVlZBh+IAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEh0KFXJhZGl1",
            "c1NwZWVkTXVsdGlwbGllchh/IAEoAhIYCg9yYWRpdXNUaGlja25lc3MYgAEg",
            "ASgCEg4KBWFuZ2xlGIEBIAEoAhIPCgZsZW5ndGgYggEgASgCEhUKDHJhZGl1",
            "c1NwcmVhZBiDASABKAISPQoNbWVzaFNoYXBlVHlwZRiEASABKA4yJS5wcm90",
            "b19wcy5QYXJ0aWNsZVN5c3RlbU1lc2hTaGFwZVR5cGUSGQoQbWVzaFJlbmRl",
            "cmVyTmFtZRjJASABKAkSEQoIbWVzaE5hbWUYygEgASgJIukDChZQYXJ0aWNs",
            "ZVN5c3RlbVJlbmRlcmVyEg8KB2VuYWJsZWQYASABKAgSEAoIbWF0ZXJpYWwY",
            "AiABKAkSFQoNdHJhaWxNYXRlcmlhbBgDIAEoCRIRCgltZXNoQ291bnQYBCAB",
            "KAUSFwoPbWF4UGFydGljbGVTaXplGAYgASgCEhcKD21pblBhcnRpY2xlU2l6",
            "ZRgHIAEoAhIUCgxzb3J0aW5nRnVkZ2UYCCABKAISMgoIc29ydE1vZGUYCSAB",
            "KA4yIC5wcm90b19wcy5QYXJ0aWNsZVN5c3RlbVNvcnRNb2RlEiEKBXBpdm90",
            "GAogASgLMhIucHJvdG9fbWF0aC5mbG9hdDMSNgoJYWxpZ25tZW50GAsgASgO",
            "MiMucHJvdG9fcHMuUGFydGljbGVTeXN0ZW1SZW5kZXJTcGFjZRIXCg9ub3Jt",
            "YWxEaXJlY3Rpb24YDCABKAISGwoTY2FtZXJhVmVsb2NpdHlTY2FsZRgNIAEo",
            "AhIVCg12ZWxvY2l0eVNjYWxlGA4gASgCEhMKC2xlbmd0aFNjYWxlGA8gASgC",
            "EjYKCnJlbmRlck1vZGUYECABKA4yIi5wcm90b19wcy5QYXJ0aWNsZVN5c3Rl",
            "bVJlbmRlck1vZGUSEQoJbWVzaE5hbWVzGBQgAygJItkHCgtOb2lzZU1vZHVs",
            "ZRIPCgdlbmFibGVkGAEgASgIEi0KDnBvc2l0aW9uQW1vdW50GAIgASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSGAoQcmVtYXBaTXVsdGlwbGllchgDIAEo",
            "AhIlCgZyZW1hcFoYBCABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIYChBy",
            "ZW1hcFlNdWx0aXBsaWVyGAUgASgCEiUKBnJlbWFwWRgGIAEoCzIVLnByb3Rv",
            "X3BzLk1pbk1heEN1cnZlEhgKEHJlbWFwWE11bHRpcGxpZXIYByABKAISJQoG",
            "cmVtYXBYGAggASgLMhUucHJvdG9fcHMuTWluTWF4Q3VydmUSFwoPcmVtYXBN",
            "dWx0aXBsaWVyGAkgASgCEiQKBXJlbWFwGAogASgLMhUucHJvdG9fcHMuTWlu",
            "TWF4Q3VydmUSFAoMcmVtYXBFbmFibGVkGAsgASgIEh0KFXNjcm9sbFNwZWVk",
            "TXVsdGlwbGllchgMIAEoAhIqCgtzY3JvbGxTcGVlZBgNIAEoCzIVLnByb3Rv",
            "X3BzLk1pbk1heEN1cnZlEjUKB3F1YWxpdHkYDiABKA4yJC5wcm90b19wcy5Q",
            "YXJ0aWNsZVN5c3RlbU5vaXNlUXVhbGl0eRITCgtvY3RhdmVTY2FsZRgPIAEo",
            "AhIYChBvY3RhdmVNdWx0aXBsaWVyGBAgASgCEhMKC29jdGF2ZUNvdW50GBEg",
            "ASgFEg8KB2RhbXBpbmcYEiABKAgSEQoJZnJlcXVlbmN5GBMgASgCEhsKE3N0",
            "cmVuZ3RoWk11bHRpcGxpZXIYFCABKAISKAoJc3RyZW5ndGhaGBUgASgLMhUu",
            "cHJvdG9fcHMuTWluTWF4Q3VydmUSGwoTc3RyZW5ndGhZTXVsdGlwbGllchgW",
            "IAEoAhIoCglzdHJlbmd0aFkYFyABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2",
            "ZRIbChNzdHJlbmd0aFhNdWx0aXBsaWVyGBggASgCEigKCXN0cmVuZ3RoWBgZ",
            "IAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhoKEnN0cmVuZ3RoTXVsdGlw",
            "bGllchgaIAEoAhInCghzdHJlbmd0aBgbIAEoCzIVLnByb3RvX3BzLk1pbk1h",
            "eEN1cnZlEhQKDHNlcGFyYXRlQXhlcxgcIAEoCBItCg5yb3RhdGlvbkFtb3Vu",
            "dBgdIAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEikKCnNpemVBbW91bnQY",
            "HiABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZSKlBAoLVHJhaWxNb2R1bGUS",
            "DwoHZW5hYmxlZBhkIAEoCBINCgVyYXRpbxgBIAEoAhInCghsaWZldGltZRgC",
            "IAEoCzIVLnByb3RvX3BzLk1pbk1heEN1cnZlEhoKEmxpZmV0aW1lTXVsdGlw",
            "bGllchgDIAEoAhIZChFtaW5WZXJ0ZXhEaXN0YW5jZRgEIAEoAhI9Cgt0ZXh0",
            "dXJlTW9kZRgFIAEoDjIoLnByb3RvX3BzLlBhcnRpY2xlU3lzdGVtVHJhaWxU",
            "ZXh0dXJlTW9kZRISCgp3b3JsZFNwYWNlGAYgASgIEhgKEGRpZVdpdGhQYXJ0",
            "aWNsZXMYByABKAgSGAoQc2l6ZUFmZmVjdHNXaWR0aBgIIAEoCBIbChNzaXpl",
            "QWZmZWN0c0xpZmV0aW1lGAkgASgIEhwKFGluaGVyaXRQYXJ0aWNsZUNvbG9y",
            "GAogASgIEjMKEWNvbG9yT3ZlckxpZmV0aW1lGAsgASgLMhgucHJvdG9fcHMu",
            "TWluTWF4R3JhZGllbnQSLQoOd2lkdGhPdmVyVHJhaWwYDCABKAsyFS5wcm90",
            "b19wcy5NaW5NYXhDdXJ2ZRIgChh3aWR0aE92ZXJUcmFpbE11bHRpcGxpZXIY",
            "DSABKAISMAoOY29sb3JPdmVyVHJhaWwYDiABKAsyGC5wcm90b19wcy5NaW5N",
            "YXhHcmFkaWVudBIcChRnZW5lcmF0ZUxpZ2h0aW5nRGF0YRgPIAEoCCK8AgoN",
            "VHJpZ2dlck1vZHVsZRIPCgdlbmFibGVkGAEgASgIEjUKBmluc2lkZRgCIAEo",
            "DjIlLnByb3RvX3BzLlBhcnRpY2xlU3lzdGVtT3ZlcmxhcEFjdGlvbhI2Cgdv",
            "dXRzaWRlGAMgASgOMiUucHJvdG9fcHMuUGFydGljbGVTeXN0ZW1PdmVybGFw",
            "QWN0aW9uEjQKBWVudGVyGAQgASgOMiUucHJvdG9fcHMuUGFydGljbGVTeXN0",
            "ZW1PdmVybGFwQWN0aW9uEjMKBGV4aXQYBSABKA4yJS5wcm90b19wcy5QYXJ0",
            "aWNsZVN5c3RlbU92ZXJsYXBBY3Rpb24SEwoLcmFkaXVzU2NhbGUYBiABKAIS",
            "GAoQbWF4Q29sbGlkZXJDb3VudBgHIAEoBRIRCgljb2xsaWRlcnMYCCADKAki",
            "uAYKD0NvbGxpc2lvbk1vZHVsZRIUCgxtYXhLaWxsU3BlZWQYASABKAISLAok",
            "bXVsdGlwbHlDb2xsaWRlckZvcmNlQnlQYXJ0aWNsZVNwZWVkGAIgASgIEi0K",
            "JW11bHRpcGx5Q29sbGlkZXJGb3JjZUJ5Q29sbGlzaW9uQW5nbGUYAyABKAgS",
            "FQoNY29sbGlkZXJGb3JjZRgEIAEoAhIdChVzZW5kQ29sbGlzaW9uTWVzc2Fn",
            "ZXMYBSABKAgSEwoLcmFkaXVzU2NhbGUYBiABKAISEQoJdm94ZWxTaXplGAcg",
            "ASgCEjkKB3F1YWxpdHkYCCABKA4yKC5wcm90b19wcy5QYXJ0aWNsZVN5c3Rl",
            "bUNvbGxpc2lvblF1YWxpdHkSGgoSbWF4Q29sbGlzaW9uU2hhcGVzGAkgASgF",
            "Eh4KFmVuYWJsZUR5bmFtaWNDb2xsaWRlcnMYCiABKAgSKQoMY29sbGlkZXNX",
            "aXRoGAsgASgLMhMucHJvdG9fcHMuTGF5ZXJNYXNrEhUKDW1heFBsYW5lQ291",
            "bnQYDCABKAUSFAoMbWluS2lsbFNwZWVkGA0gASgCEh4KFmxpZmV0aW1lTG9z",
            "c011bHRpcGxpZXIYDiABKAISKwoMbGlmZXRpbWVMb3NzGA8gASgLMhUucHJv",
            "dG9fcHMuTWluTWF4Q3VydmUSGAoQYm91bmNlTXVsdGlwbGllchgQIAEoAhIl",
            "CgZib3VuY2UYESABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIYChBkYW1w",
            "ZW5NdWx0aXBsaWVyGBIgASgCEiUKBmRhbXBlbhgTIAEoCzIVLnByb3RvX3Bz",
            "Lk1pbk1heEN1cnZlEjMKBG1vZGUYFCABKA4yJS5wcm90b19wcy5QYXJ0aWNs",
            "ZVN5c3RlbUNvbGxpc2lvbk1vZGUSMwoEdHlwZRgVIAEoDjIlLnByb3RvX3Bz",
            "LlBhcnRpY2xlU3lzdGVtQ29sbGlzaW9uVHlwZRIPCgdlbmFibGVkGBYgASgI",
            "EisKI211bHRpcGx5Q29sbGlkZXJGb3JjZUJ5UGFydGljbGVTaXplGBcgASgI",
            "Eg4KBnBsYW5lcxgYIAMoCSKJCQoOUGFydGljbGVTeXN0ZW0SEAoIcGFyZW50",
            "UFMYASABKAkSMgoIcmVuZGVyZXIYZCABKAsyIC5wcm90b19wcy5QYXJ0aWNs",
            "ZVN5c3RlbVJlbmRlcmVyEiIKBG1haW4YZSABKAsyFC5wcm90b19wcy5NYWlu",
            "TW9kdWxlEioKCGVtaXNzaW9uGGYgASgLMhgucHJvdG9fcHMuRW1pc3Npb25N",
            "b2R1bGUSJAoFc2hhcGUYZyABKAsyFS5wcm90b19wcy5TaGFwZU1vZHVsZRJC",
            "ChR2ZWxvY2l0eU92ZXJMaWZldGltZRhoIAEoCzIkLnByb3RvX3BzLlZlbG9j",
            "aXR5T3ZlckxpZmV0aW1lTW9kdWxlEkwKGWxpbWl0VmVsb2NpdHlPdmVyTGlm",
            "ZXRpbWUYaSABKAsyKS5wcm90b19wcy5MaW1pdFZlbG9jaXR5T3ZlckxpZmV0",
            "aW1lTW9kdWxlEjgKD2luaGVyaXRWZWxvY2l0eRhqIAEoCzIfLnByb3RvX3Bz",
            "LkluaGVyaXRWZWxvY2l0eU1vZHVsZRI8ChFmb3JjZU92ZXJMaWZldGltZRhr",
            "IAEoCzIhLnByb3RvX3BzLkZvcmNlT3ZlckxpZmV0aW1lTW9kdWxlEiUKBnRy",
            "YWlscxhtIAEoCzIVLnByb3RvX3BzLlRyYWlsTW9kdWxlEkQKFXRleHR1cmVT",
            "aGVldEFuaW1hdGlvbhhvIAEoCzIlLnByb3RvX3BzLlRleHR1cmVTaGVldEFu",
            "aW1hdGlvbk1vZHVsZRIwCgtzdWJFbWl0dGVycxhwIAEoCzIbLnByb3RvX3Bz",
            "LlN1YkVtaXR0ZXJzTW9kdWxlEigKB3RyaWdnZXIYcSABKAsyFy5wcm90b19w",
            "cy5UcmlnZ2VyTW9kdWxlEiwKCWNvbGxpc2lvbhhyIAEoCzIZLnByb3RvX3Bz",
            "LkNvbGxpc2lvbk1vZHVsZRIkCgVub2lzZRhzIAEoCzIVLnByb3RvX3BzLk5v",
            "aXNlTW9kdWxlEjYKDmV4dGVybmFsRm9yY2VzGHQgASgLMh4ucHJvdG9fcHMu",
            "RXh0ZXJuYWxGb3JjZXNNb2R1bGUSOAoPcm90YXRpb25CeVNwZWVkGHUgASgL",
            "Mh8ucHJvdG9fcHMuUm90YXRpb25CeVNwZWVkTW9kdWxlEkIKFHJvdGF0aW9u",
            "T3ZlckxpZmV0aW1lGHYgASgLMiQucHJvdG9fcHMuUm90YXRpb25PdmVyTGlm",
            "ZXRpbWVNb2R1bGUSMAoLc2l6ZUJ5U3BlZWQYdyABKAsyGy5wcm90b19wcy5T",
            "aXplQnlTcGVlZE1vZHVsZRI6ChBzaXplT3ZlckxpZmV0aW1lGHggASgLMiAu",
            "cHJvdG9fcHMuU2l6ZU92ZXJMaWZldGltZU1vZHVsZRIyCgxjb2xvckJ5U3Bl",
            "ZWQYeSABKAsyHC5wcm90b19wcy5Db2xvckJ5U3BlZWRNb2R1bGUSPAoRY29s",
            "b3JPdmVyTGlmZXRpbWUYeiABKAsyIS5wcm90b19wcy5Db2xvck92ZXJMaWZl",
            "dGltZU1vZHVsZUICSANiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::ProtoMath.MathReflection.Descriptor, global::ProtoPs.ParticleEnumsReflection.Descriptor, global::ProtoPs.ParticleStructsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.MainModule), global::ProtoPs.MainModule.Parser, new[]{ "Duration", "StartRotationX", "StartRotationXMultiplier", "StartRotationY", "StartRotationYMultiplier", "StartRotationZ", "StartRotationZMultiplier", "RandomizeRotationDirection", "StartRotationMultiplier", "StartColor", "GravityModifierMultiplier", "SimulationSpace", "CustomSimulationSpace", "SimulationSpeed", "UseUnscaledTime", "ScalingMode", "PlayOnAwake", "GravityModifier", "MaxParticles", "StartRotation", "StartSizeZMultiplier", "Loop", "Prewarm", "StartDelay", "StartDelayMultiplier", "StartLifetime", "StartLifetimeMultiplier", "StartSpeed", "StartRotation3D", "StartSpeedMultiplier", "StartSize", "StartSizeMultiplier", "StartSizeX", "StartSizeXMultiplier", "StartSizeY", "StartSizeYMultiplier", "StartSizeZ", "StartSize3D", "EmitterVelocityMode" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ColorBySpeedModule), global::ProtoPs.ColorBySpeedModule.Parser, new[]{ "Enabled", "Color", "Range" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.TextureSheetAnimationModule), global::ProtoPs.TextureSheetAnimationModule.Parser, new[]{ "UseRandomRow", "FlipU", "RowIndex", "CycleCount", "StartFrameMultiplier", "StartFrame", "FrameOverTimeMultiplier", "FrameOverTime", "SpriteCount", "Animation", "NumTilesY", "NumTilesX", "Mode", "Enabled", "FlipV" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.SubEmitter), global::ProtoPs.SubEmitter.Parser, new[]{ "Ps", "Type", "Inherit" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.SubEmittersModule), global::ProtoPs.SubEmittersModule.Parser, new[]{ "Enabled", "SubEmittersCount", "SubEmitters" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ExternalForcesModule), global::ProtoPs.ExternalForcesModule.Parser, new[]{ "Enabled", "Multiplier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.RotationBySpeedModule), global::ProtoPs.RotationBySpeedModule.Parser, new[]{ "Enabled", "X", "XMultiplier", "Y", "YMultiplier", "Z", "ZMultiplier", "SeparateAxes", "Range" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.RotationOverLifetimeModule), global::ProtoPs.RotationOverLifetimeModule.Parser, new[]{ "Enabled", "X", "XMultiplier", "Y", "YMultiplier", "Z", "ZMultiplier", "SeparateAxes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.SizeBySpeedModule), global::ProtoPs.SizeBySpeedModule.Parser, new[]{ "Enabled", "Size", "SizeMultiplier", "X", "XMultiplier", "Y", "YMultiplier", "Z", "ZMultiplier", "SeparateAxes", "Range" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.SizeOverLifetimeModule), global::ProtoPs.SizeOverLifetimeModule.Parser, new[]{ "Enabled", "Size", "SizeMultiplier", "X", "XMultiplier", "Y", "YMultiplier", "Z", "ZMultiplier", "SeparateAxes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.EmissionModule), global::ProtoPs.EmissionModule.Parser, new[]{ "Enabled", "RateOverTime", "RateOverTimeMultiplier", "RateOverDistance", "RateOverDistanceMultiplier", "BurstCount", "Bursts" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ColorOverLifetimeModule), global::ProtoPs.ColorOverLifetimeModule.Parser, new[]{ "Enabled", "Color" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ForceOverLifetimeModule), global::ProtoPs.ForceOverLifetimeModule.Parser, new[]{ "Enabled", "X", "Y", "Z", "XMultiplier", "YMultiplier", "ZMultiplier", "Space", "Randomized" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.InheritVelocityModule), global::ProtoPs.InheritVelocityModule.Parser, new[]{ "Enabled", "Mode", "Curve", "CurveMultiplier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.LimitVelocityOverLifetimeModule), global::ProtoPs.LimitVelocityOverLifetimeModule.Parser, new[]{ "Enabled", "LimitX", "LimitXMultiplier", "LimitY", "LimitYMultiplier", "LimitZ", "LimitZMultiplier", "Limit", "LimitMultiplier", "Dampen", "SeparateAxes", "Space" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.VelocityOverLifetimeModule), global::ProtoPs.VelocityOverLifetimeModule.Parser, new[]{ "Enabled", "X", "Y", "Z", "XMultiplier", "YMultiplier", "ZMultiplier", "Space", "OrbitalX", "OrbitalXMultiplier", "OrbitalY", "OrbitalYMultiplier", "OrbitalZ", "OrbitalZMultiplier", "OffsetX", "OffsetXMultiplier", "OffsetY", "OffsetYMultiplier", "OffsetZ", "OffsetZMultiplier", "Radial", "RadialMultiplier", "Speed", "SpeedMultiplier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ShapeModule), global::ProtoPs.ShapeModule.Parser, new[]{ "Enabled", "UseMeshMaterialIndex", "MeshMaterialIndex", "UseMeshColors", "NormalOffset", "Arc", "ArcSpread", "ArcSpeed", "ArcSpeedMultiplier", "DonutRadius", "Position", "Rotation", "Scale", "BoxThickness", "ShapeType", "RandomDirectionAmount", "SphericalDirectionAmount", "RandomPositionAmount", "AlignToDirection", "Radius", "RadiusSpeed", "RadiusSpeedMultiplier", "RadiusThickness", "Angle", "Length", "RadiusSpread", "MeshShapeType", "MeshRendererName", "MeshName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ParticleSystemRenderer), global::ProtoPs.ParticleSystemRenderer.Parser, new[]{ "Enabled", "Material", "TrailMaterial", "MeshCount", "MaxParticleSize", "MinParticleSize", "SortingFudge", "SortMode", "Pivot", "Alignment", "NormalDirection", "CameraVelocityScale", "VelocityScale", "LengthScale", "RenderMode", "MeshNames" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.NoiseModule), global::ProtoPs.NoiseModule.Parser, new[]{ "Enabled", "PositionAmount", "RemapZMultiplier", "RemapZ", "RemapYMultiplier", "RemapY", "RemapXMultiplier", "RemapX", "RemapMultiplier", "Remap", "RemapEnabled", "ScrollSpeedMultiplier", "ScrollSpeed", "Quality", "OctaveScale", "OctaveMultiplier", "OctaveCount", "Damping", "Frequency", "StrengthZMultiplier", "StrengthZ", "StrengthYMultiplier", "StrengthY", "StrengthXMultiplier", "StrengthX", "StrengthMultiplier", "Strength", "SeparateAxes", "RotationAmount", "SizeAmount" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.TrailModule), global::ProtoPs.TrailModule.Parser, new[]{ "Enabled", "Ratio", "Lifetime", "LifetimeMultiplier", "MinVertexDistance", "TextureMode", "WorldSpace", "DieWithParticles", "SizeAffectsWidth", "SizeAffectsLifetime", "InheritParticleColor", "ColorOverLifetime", "WidthOverTrail", "WidthOverTrailMultiplier", "ColorOverTrail", "GenerateLightingData" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.TriggerModule), global::ProtoPs.TriggerModule.Parser, new[]{ "Enabled", "Inside", "Outside", "Enter", "Exit", "RadiusScale", "MaxColliderCount", "Colliders" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.CollisionModule), global::ProtoPs.CollisionModule.Parser, new[]{ "MaxKillSpeed", "MultiplyColliderForceByParticleSpeed", "MultiplyColliderForceByCollisionAngle", "ColliderForce", "SendCollisionMessages", "RadiusScale", "VoxelSize", "Quality", "MaxCollisionShapes", "EnableDynamicColliders", "CollidesWith", "MaxPlaneCount", "MinKillSpeed", "LifetimeLossMultiplier", "LifetimeLoss", "BounceMultiplier", "Bounce", "DampenMultiplier", "Dampen", "Mode", "Type", "Enabled", "MultiplyColliderForceByParticleSize", "Planes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.ParticleSystem), global::ProtoPs.ParticleSystem.Parser, new[]{ "ParentPS", "Renderer", "Main", "Emission", "Shape", "VelocityOverLifetime", "LimitVelocityOverLifetime", "InheritVelocity", "ForceOverLifetime", "Trails", "TextureSheetAnimation", "SubEmitters", "Trigger", "Collision", "Noise", "ExternalForces", "RotationBySpeed", "RotationOverLifetime", "SizeBySpeed", "SizeOverLifetime", "ColorBySpeed", "ColorOverLifetime" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// Summary:
  ///     ///
  ///     Access the ParticleSystem Lights Module.
  ///     ///
  ///        struct LightsModule
  ///        {
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Enable/disable the Lights module.
  ///            //     ///
  ///            bool enabled;
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Choose what proportion of particles will receive a dynamic light.
  ///            //     ///
  ///            float ratio;
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Randomly assign lights to new particles based on ParticleSystem.LightsModule.ratio.
  ///            //     ///
  ///            bool useRandomDistribution;
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Select what Light prefab you want to base your particle lights on.
  ///            //     ///
  ///            Light light;
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Toggle whether the particle lights will have their color multiplied by the particle
  ///            //     color.
  ///            //     ///
  ///            public bool useParticleColor { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Toggle where the particle size will be multiplied by the light range, to determine
  ///            //     the final light range.
  ///            //     ///
  ///            public bool sizeAffectsRange { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Toggle whether the particle alpha gets multiplied by the light intensity, when
  ///            //     computing the final light intensity.
  ///            //     ///
  ///            public bool alphaAffectsIntensity { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Define a curve to apply custom range scaling to particle lights.
  ///            //     ///
  ///            public MinMaxCurve range { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Range multiplier.
  ///            //     ///
  ///            public float rangeMultiplier { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Define a curve to apply custom intensity scaling to particle lights.
  ///            //     ///
  ///            public MinMaxCurve intensity { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Intensity multiplier.
  ///            //     ///
  ///            public float intensityMultiplier { get; set; }
  ///            //
  ///            // Summary:
  ///            //     ///
  ///            //     Set a limit on how many lights this Module can create.
  ///            //     ///
  ///            public int maxLights { get; set; }
  ///        }
  /// </summary>
  public sealed partial class MainModule : pb::IMessage<MainModule> {
    private static readonly pb::MessageParser<MainModule> _parser = new pb::MessageParser<MainModule>(() => new MainModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MainModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MainModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MainModule(MainModule other) : this() {
      duration_ = other.duration_;
      StartRotationX = other.startRotationX_ != null ? other.StartRotationX.Clone() : null;
      startRotationXMultiplier_ = other.startRotationXMultiplier_;
      StartRotationY = other.startRotationY_ != null ? other.StartRotationY.Clone() : null;
      startRotationYMultiplier_ = other.startRotationYMultiplier_;
      StartRotationZ = other.startRotationZ_ != null ? other.StartRotationZ.Clone() : null;
      startRotationZMultiplier_ = other.startRotationZMultiplier_;
      randomizeRotationDirection_ = other.randomizeRotationDirection_;
      startRotationMultiplier_ = other.startRotationMultiplier_;
      StartColor = other.startColor_ != null ? other.StartColor.Clone() : null;
      gravityModifierMultiplier_ = other.gravityModifierMultiplier_;
      simulationSpace_ = other.simulationSpace_;
      CustomSimulationSpace = other.customSimulationSpace_ != null ? other.CustomSimulationSpace.Clone() : null;
      simulationSpeed_ = other.simulationSpeed_;
      useUnscaledTime_ = other.useUnscaledTime_;
      scalingMode_ = other.scalingMode_;
      playOnAwake_ = other.playOnAwake_;
      GravityModifier = other.gravityModifier_ != null ? other.GravityModifier.Clone() : null;
      maxParticles_ = other.maxParticles_;
      StartRotation = other.startRotation_ != null ? other.StartRotation.Clone() : null;
      startSizeZMultiplier_ = other.startSizeZMultiplier_;
      loop_ = other.loop_;
      prewarm_ = other.prewarm_;
      StartDelay = other.startDelay_ != null ? other.StartDelay.Clone() : null;
      startDelayMultiplier_ = other.startDelayMultiplier_;
      StartLifetime = other.startLifetime_ != null ? other.StartLifetime.Clone() : null;
      startLifetimeMultiplier_ = other.startLifetimeMultiplier_;
      StartSpeed = other.startSpeed_ != null ? other.StartSpeed.Clone() : null;
      startRotation3D_ = other.startRotation3D_;
      startSpeedMultiplier_ = other.startSpeedMultiplier_;
      StartSize = other.startSize_ != null ? other.StartSize.Clone() : null;
      startSizeMultiplier_ = other.startSizeMultiplier_;
      StartSizeX = other.startSizeX_ != null ? other.StartSizeX.Clone() : null;
      startSizeXMultiplier_ = other.startSizeXMultiplier_;
      StartSizeY = other.startSizeY_ != null ? other.StartSizeY.Clone() : null;
      startSizeYMultiplier_ = other.startSizeYMultiplier_;
      StartSizeZ = other.startSizeZ_ != null ? other.StartSizeZ.Clone() : null;
      startSize3D_ = other.startSize3D_;
      emitterVelocityMode_ = other.emitterVelocityMode_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MainModule Clone() {
      return new MainModule(this);
    }

    /// <summary>Field number for the "duration" field.</summary>
    public const int DurationFieldNumber = 101;
    private float duration_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Duration {
      get { return duration_; }
      set {
        duration_ = value;
      }
    }

    /// <summary>Field number for the "startRotationX" field.</summary>
    public const int StartRotationXFieldNumber = 102;
    private global::ProtoPs.MinMaxCurve startRotationX_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartRotationX {
      get { return startRotationX_; }
      set {
        startRotationX_ = value;
      }
    }

    /// <summary>Field number for the "startRotationXMultiplier" field.</summary>
    public const int StartRotationXMultiplierFieldNumber = 103;
    private float startRotationXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartRotationXMultiplier {
      get { return startRotationXMultiplier_; }
      set {
        startRotationXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startRotationY" field.</summary>
    public const int StartRotationYFieldNumber = 104;
    private global::ProtoPs.MinMaxCurve startRotationY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartRotationY {
      get { return startRotationY_; }
      set {
        startRotationY_ = value;
      }
    }

    /// <summary>Field number for the "startRotationYMultiplier" field.</summary>
    public const int StartRotationYMultiplierFieldNumber = 105;
    private float startRotationYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartRotationYMultiplier {
      get { return startRotationYMultiplier_; }
      set {
        startRotationYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startRotationZ" field.</summary>
    public const int StartRotationZFieldNumber = 106;
    private global::ProtoPs.MinMaxCurve startRotationZ_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartRotationZ {
      get { return startRotationZ_; }
      set {
        startRotationZ_ = value;
      }
    }

    /// <summary>Field number for the "startRotationZMultiplier" field.</summary>
    public const int StartRotationZMultiplierFieldNumber = 107;
    private float startRotationZMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartRotationZMultiplier {
      get { return startRotationZMultiplier_; }
      set {
        startRotationZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "randomizeRotationDirection" field.</summary>
    public const int RandomizeRotationDirectionFieldNumber = 108;
    private float randomizeRotationDirection_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomizeRotationDirection {
      get { return randomizeRotationDirection_; }
      set {
        randomizeRotationDirection_ = value;
      }
    }

    /// <summary>Field number for the "startRotationMultiplier" field.</summary>
    public const int StartRotationMultiplierFieldNumber = 109;
    private float startRotationMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartRotationMultiplier {
      get { return startRotationMultiplier_; }
      set {
        startRotationMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startColor" field.</summary>
    public const int StartColorFieldNumber = 110;
    private global::ProtoPs.MinMaxGradient startColor_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxGradient StartColor {
      get { return startColor_; }
      set {
        startColor_ = value;
      }
    }

    /// <summary>Field number for the "gravityModifierMultiplier" field.</summary>
    public const int GravityModifierMultiplierFieldNumber = 111;
    private float gravityModifierMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float GravityModifierMultiplier {
      get { return gravityModifierMultiplier_; }
      set {
        gravityModifierMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "simulationSpace" field.</summary>
    public const int SimulationSpaceFieldNumber = 112;
    private global::ProtoPs.ParticleSystemSimulationSpace simulationSpace_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSimulationSpace SimulationSpace {
      get { return simulationSpace_; }
      set {
        simulationSpace_ = value;
      }
    }

    /// <summary>Field number for the "customSimulationSpace" field.</summary>
    public const int CustomSimulationSpaceFieldNumber = 113;
    private global::ProtoMath.transform customSimulationSpace_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.transform CustomSimulationSpace {
      get { return customSimulationSpace_; }
      set {
        customSimulationSpace_ = value;
      }
    }

    /// <summary>Field number for the "simulationSpeed" field.</summary>
    public const int SimulationSpeedFieldNumber = 114;
    private float simulationSpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SimulationSpeed {
      get { return simulationSpeed_; }
      set {
        simulationSpeed_ = value;
      }
    }

    /// <summary>Field number for the "useUnscaledTime" field.</summary>
    public const int UseUnscaledTimeFieldNumber = 115;
    private bool useUnscaledTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseUnscaledTime {
      get { return useUnscaledTime_; }
      set {
        useUnscaledTime_ = value;
      }
    }

    /// <summary>Field number for the "scalingMode" field.</summary>
    public const int ScalingModeFieldNumber = 116;
    private global::ProtoPs.ParticleSystemScalingMode scalingMode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemScalingMode ScalingMode {
      get { return scalingMode_; }
      set {
        scalingMode_ = value;
      }
    }

    /// <summary>Field number for the "playOnAwake" field.</summary>
    public const int PlayOnAwakeFieldNumber = 117;
    private bool playOnAwake_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PlayOnAwake {
      get { return playOnAwake_; }
      set {
        playOnAwake_ = value;
      }
    }

    /// <summary>Field number for the "gravityModifier" field.</summary>
    public const int GravityModifierFieldNumber = 118;
    private global::ProtoPs.MinMaxCurve gravityModifier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve GravityModifier {
      get { return gravityModifier_; }
      set {
        gravityModifier_ = value;
      }
    }

    /// <summary>Field number for the "maxParticles" field.</summary>
    public const int MaxParticlesFieldNumber = 119;
    private int maxParticles_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxParticles {
      get { return maxParticles_; }
      set {
        maxParticles_ = value;
      }
    }

    /// <summary>Field number for the "startRotation" field.</summary>
    public const int StartRotationFieldNumber = 120;
    private global::ProtoPs.MinMaxCurve startRotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartRotation {
      get { return startRotation_; }
      set {
        startRotation_ = value;
      }
    }

    /// <summary>Field number for the "startSizeZMultiplier" field.</summary>
    public const int StartSizeZMultiplierFieldNumber = 121;
    private float startSizeZMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartSizeZMultiplier {
      get { return startSizeZMultiplier_; }
      set {
        startSizeZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "loop" field.</summary>
    public const int LoopFieldNumber = 122;
    private bool loop_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Loop {
      get { return loop_; }
      set {
        loop_ = value;
      }
    }

    /// <summary>Field number for the "prewarm" field.</summary>
    public const int PrewarmFieldNumber = 123;
    private bool prewarm_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Prewarm {
      get { return prewarm_; }
      set {
        prewarm_ = value;
      }
    }

    /// <summary>Field number for the "startDelay" field.</summary>
    public const int StartDelayFieldNumber = 124;
    private global::ProtoPs.MinMaxCurve startDelay_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartDelay {
      get { return startDelay_; }
      set {
        startDelay_ = value;
      }
    }

    /// <summary>Field number for the "startDelayMultiplier" field.</summary>
    public const int StartDelayMultiplierFieldNumber = 125;
    private float startDelayMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartDelayMultiplier {
      get { return startDelayMultiplier_; }
      set {
        startDelayMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startLifetime" field.</summary>
    public const int StartLifetimeFieldNumber = 126;
    private global::ProtoPs.MinMaxCurve startLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartLifetime {
      get { return startLifetime_; }
      set {
        startLifetime_ = value;
      }
    }

    /// <summary>Field number for the "startLifetimeMultiplier" field.</summary>
    public const int StartLifetimeMultiplierFieldNumber = 127;
    private float startLifetimeMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartLifetimeMultiplier {
      get { return startLifetimeMultiplier_; }
      set {
        startLifetimeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startSpeed" field.</summary>
    public const int StartSpeedFieldNumber = 128;
    private global::ProtoPs.MinMaxCurve startSpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartSpeed {
      get { return startSpeed_; }
      set {
        startSpeed_ = value;
      }
    }

    /// <summary>Field number for the "startRotation3D" field.</summary>
    public const int StartRotation3DFieldNumber = 129;
    private bool startRotation3D_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StartRotation3D {
      get { return startRotation3D_; }
      set {
        startRotation3D_ = value;
      }
    }

    /// <summary>Field number for the "startSpeedMultiplier" field.</summary>
    public const int StartSpeedMultiplierFieldNumber = 130;
    private float startSpeedMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartSpeedMultiplier {
      get { return startSpeedMultiplier_; }
      set {
        startSpeedMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startSize" field.</summary>
    public const int StartSizeFieldNumber = 131;
    private global::ProtoPs.MinMaxCurve startSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartSize {
      get { return startSize_; }
      set {
        startSize_ = value;
      }
    }

    /// <summary>Field number for the "startSizeMultiplier" field.</summary>
    public const int StartSizeMultiplierFieldNumber = 132;
    private float startSizeMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartSizeMultiplier {
      get { return startSizeMultiplier_; }
      set {
        startSizeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startSizeX" field.</summary>
    public const int StartSizeXFieldNumber = 133;
    private global::ProtoPs.MinMaxCurve startSizeX_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartSizeX {
      get { return startSizeX_; }
      set {
        startSizeX_ = value;
      }
    }

    /// <summary>Field number for the "startSizeXMultiplier" field.</summary>
    public const int StartSizeXMultiplierFieldNumber = 134;
    private float startSizeXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartSizeXMultiplier {
      get { return startSizeXMultiplier_; }
      set {
        startSizeXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startSizeY" field.</summary>
    public const int StartSizeYFieldNumber = 135;
    private global::ProtoPs.MinMaxCurve startSizeY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartSizeY {
      get { return startSizeY_; }
      set {
        startSizeY_ = value;
      }
    }

    /// <summary>Field number for the "startSizeYMultiplier" field.</summary>
    public const int StartSizeYMultiplierFieldNumber = 136;
    private float startSizeYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartSizeYMultiplier {
      get { return startSizeYMultiplier_; }
      set {
        startSizeYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startSizeZ" field.</summary>
    public const int StartSizeZFieldNumber = 137;
    private global::ProtoPs.MinMaxCurve startSizeZ_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartSizeZ {
      get { return startSizeZ_; }
      set {
        startSizeZ_ = value;
      }
    }

    /// <summary>Field number for the "startSize3D" field.</summary>
    public const int StartSize3DFieldNumber = 138;
    private bool startSize3D_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StartSize3D {
      get { return startSize3D_; }
      set {
        startSize3D_ = value;
      }
    }

    /// <summary>Field number for the "emitterVelocityMode" field.</summary>
    public const int EmitterVelocityModeFieldNumber = 139;
    private global::ProtoPs.ParticleSystemEmitterVelocityMode emitterVelocityMode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemEmitterVelocityMode EmitterVelocityMode {
      get { return emitterVelocityMode_; }
      set {
        emitterVelocityMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MainModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MainModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Duration != other.Duration) return false;
      if (!object.Equals(StartRotationX, other.StartRotationX)) return false;
      if (StartRotationXMultiplier != other.StartRotationXMultiplier) return false;
      if (!object.Equals(StartRotationY, other.StartRotationY)) return false;
      if (StartRotationYMultiplier != other.StartRotationYMultiplier) return false;
      if (!object.Equals(StartRotationZ, other.StartRotationZ)) return false;
      if (StartRotationZMultiplier != other.StartRotationZMultiplier) return false;
      if (RandomizeRotationDirection != other.RandomizeRotationDirection) return false;
      if (StartRotationMultiplier != other.StartRotationMultiplier) return false;
      if (!object.Equals(StartColor, other.StartColor)) return false;
      if (GravityModifierMultiplier != other.GravityModifierMultiplier) return false;
      if (SimulationSpace != other.SimulationSpace) return false;
      if (!object.Equals(CustomSimulationSpace, other.CustomSimulationSpace)) return false;
      if (SimulationSpeed != other.SimulationSpeed) return false;
      if (UseUnscaledTime != other.UseUnscaledTime) return false;
      if (ScalingMode != other.ScalingMode) return false;
      if (PlayOnAwake != other.PlayOnAwake) return false;
      if (!object.Equals(GravityModifier, other.GravityModifier)) return false;
      if (MaxParticles != other.MaxParticles) return false;
      if (!object.Equals(StartRotation, other.StartRotation)) return false;
      if (StartSizeZMultiplier != other.StartSizeZMultiplier) return false;
      if (Loop != other.Loop) return false;
      if (Prewarm != other.Prewarm) return false;
      if (!object.Equals(StartDelay, other.StartDelay)) return false;
      if (StartDelayMultiplier != other.StartDelayMultiplier) return false;
      if (!object.Equals(StartLifetime, other.StartLifetime)) return false;
      if (StartLifetimeMultiplier != other.StartLifetimeMultiplier) return false;
      if (!object.Equals(StartSpeed, other.StartSpeed)) return false;
      if (StartRotation3D != other.StartRotation3D) return false;
      if (StartSpeedMultiplier != other.StartSpeedMultiplier) return false;
      if (!object.Equals(StartSize, other.StartSize)) return false;
      if (StartSizeMultiplier != other.StartSizeMultiplier) return false;
      if (!object.Equals(StartSizeX, other.StartSizeX)) return false;
      if (StartSizeXMultiplier != other.StartSizeXMultiplier) return false;
      if (!object.Equals(StartSizeY, other.StartSizeY)) return false;
      if (StartSizeYMultiplier != other.StartSizeYMultiplier) return false;
      if (!object.Equals(StartSizeZ, other.StartSizeZ)) return false;
      if (StartSize3D != other.StartSize3D) return false;
      if (EmitterVelocityMode != other.EmitterVelocityMode) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Duration != 0F) hash ^= Duration.GetHashCode();
      if (startRotationX_ != null) hash ^= StartRotationX.GetHashCode();
      if (StartRotationXMultiplier != 0F) hash ^= StartRotationXMultiplier.GetHashCode();
      if (startRotationY_ != null) hash ^= StartRotationY.GetHashCode();
      if (StartRotationYMultiplier != 0F) hash ^= StartRotationYMultiplier.GetHashCode();
      if (startRotationZ_ != null) hash ^= StartRotationZ.GetHashCode();
      if (StartRotationZMultiplier != 0F) hash ^= StartRotationZMultiplier.GetHashCode();
      if (RandomizeRotationDirection != 0F) hash ^= RandomizeRotationDirection.GetHashCode();
      if (StartRotationMultiplier != 0F) hash ^= StartRotationMultiplier.GetHashCode();
      if (startColor_ != null) hash ^= StartColor.GetHashCode();
      if (GravityModifierMultiplier != 0F) hash ^= GravityModifierMultiplier.GetHashCode();
      if (SimulationSpace != 0) hash ^= SimulationSpace.GetHashCode();
      if (customSimulationSpace_ != null) hash ^= CustomSimulationSpace.GetHashCode();
      if (SimulationSpeed != 0F) hash ^= SimulationSpeed.GetHashCode();
      if (UseUnscaledTime != false) hash ^= UseUnscaledTime.GetHashCode();
      if (ScalingMode != 0) hash ^= ScalingMode.GetHashCode();
      if (PlayOnAwake != false) hash ^= PlayOnAwake.GetHashCode();
      if (gravityModifier_ != null) hash ^= GravityModifier.GetHashCode();
      if (MaxParticles != 0) hash ^= MaxParticles.GetHashCode();
      if (startRotation_ != null) hash ^= StartRotation.GetHashCode();
      if (StartSizeZMultiplier != 0F) hash ^= StartSizeZMultiplier.GetHashCode();
      if (Loop != false) hash ^= Loop.GetHashCode();
      if (Prewarm != false) hash ^= Prewarm.GetHashCode();
      if (startDelay_ != null) hash ^= StartDelay.GetHashCode();
      if (StartDelayMultiplier != 0F) hash ^= StartDelayMultiplier.GetHashCode();
      if (startLifetime_ != null) hash ^= StartLifetime.GetHashCode();
      if (StartLifetimeMultiplier != 0F) hash ^= StartLifetimeMultiplier.GetHashCode();
      if (startSpeed_ != null) hash ^= StartSpeed.GetHashCode();
      if (StartRotation3D != false) hash ^= StartRotation3D.GetHashCode();
      if (StartSpeedMultiplier != 0F) hash ^= StartSpeedMultiplier.GetHashCode();
      if (startSize_ != null) hash ^= StartSize.GetHashCode();
      if (StartSizeMultiplier != 0F) hash ^= StartSizeMultiplier.GetHashCode();
      if (startSizeX_ != null) hash ^= StartSizeX.GetHashCode();
      if (StartSizeXMultiplier != 0F) hash ^= StartSizeXMultiplier.GetHashCode();
      if (startSizeY_ != null) hash ^= StartSizeY.GetHashCode();
      if (StartSizeYMultiplier != 0F) hash ^= StartSizeYMultiplier.GetHashCode();
      if (startSizeZ_ != null) hash ^= StartSizeZ.GetHashCode();
      if (StartSize3D != false) hash ^= StartSize3D.GetHashCode();
      if (EmitterVelocityMode != 0) hash ^= EmitterVelocityMode.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Duration != 0F) {
        output.WriteRawTag(173, 6);
        output.WriteFloat(Duration);
      }
      if (startRotationX_ != null) {
        output.WriteRawTag(178, 6);
        output.WriteMessage(StartRotationX);
      }
      if (StartRotationXMultiplier != 0F) {
        output.WriteRawTag(189, 6);
        output.WriteFloat(StartRotationXMultiplier);
      }
      if (startRotationY_ != null) {
        output.WriteRawTag(194, 6);
        output.WriteMessage(StartRotationY);
      }
      if (StartRotationYMultiplier != 0F) {
        output.WriteRawTag(205, 6);
        output.WriteFloat(StartRotationYMultiplier);
      }
      if (startRotationZ_ != null) {
        output.WriteRawTag(210, 6);
        output.WriteMessage(StartRotationZ);
      }
      if (StartRotationZMultiplier != 0F) {
        output.WriteRawTag(221, 6);
        output.WriteFloat(StartRotationZMultiplier);
      }
      if (RandomizeRotationDirection != 0F) {
        output.WriteRawTag(229, 6);
        output.WriteFloat(RandomizeRotationDirection);
      }
      if (StartRotationMultiplier != 0F) {
        output.WriteRawTag(237, 6);
        output.WriteFloat(StartRotationMultiplier);
      }
      if (startColor_ != null) {
        output.WriteRawTag(242, 6);
        output.WriteMessage(StartColor);
      }
      if (GravityModifierMultiplier != 0F) {
        output.WriteRawTag(253, 6);
        output.WriteFloat(GravityModifierMultiplier);
      }
      if (SimulationSpace != 0) {
        output.WriteRawTag(128, 7);
        output.WriteEnum((int) SimulationSpace);
      }
      if (customSimulationSpace_ != null) {
        output.WriteRawTag(138, 7);
        output.WriteMessage(CustomSimulationSpace);
      }
      if (SimulationSpeed != 0F) {
        output.WriteRawTag(149, 7);
        output.WriteFloat(SimulationSpeed);
      }
      if (UseUnscaledTime != false) {
        output.WriteRawTag(152, 7);
        output.WriteBool(UseUnscaledTime);
      }
      if (ScalingMode != 0) {
        output.WriteRawTag(160, 7);
        output.WriteEnum((int) ScalingMode);
      }
      if (PlayOnAwake != false) {
        output.WriteRawTag(168, 7);
        output.WriteBool(PlayOnAwake);
      }
      if (gravityModifier_ != null) {
        output.WriteRawTag(178, 7);
        output.WriteMessage(GravityModifier);
      }
      if (MaxParticles != 0) {
        output.WriteRawTag(184, 7);
        output.WriteInt32(MaxParticles);
      }
      if (startRotation_ != null) {
        output.WriteRawTag(194, 7);
        output.WriteMessage(StartRotation);
      }
      if (StartSizeZMultiplier != 0F) {
        output.WriteRawTag(205, 7);
        output.WriteFloat(StartSizeZMultiplier);
      }
      if (Loop != false) {
        output.WriteRawTag(208, 7);
        output.WriteBool(Loop);
      }
      if (Prewarm != false) {
        output.WriteRawTag(216, 7);
        output.WriteBool(Prewarm);
      }
      if (startDelay_ != null) {
        output.WriteRawTag(226, 7);
        output.WriteMessage(StartDelay);
      }
      if (StartDelayMultiplier != 0F) {
        output.WriteRawTag(237, 7);
        output.WriteFloat(StartDelayMultiplier);
      }
      if (startLifetime_ != null) {
        output.WriteRawTag(242, 7);
        output.WriteMessage(StartLifetime);
      }
      if (StartLifetimeMultiplier != 0F) {
        output.WriteRawTag(253, 7);
        output.WriteFloat(StartLifetimeMultiplier);
      }
      if (startSpeed_ != null) {
        output.WriteRawTag(130, 8);
        output.WriteMessage(StartSpeed);
      }
      if (StartRotation3D != false) {
        output.WriteRawTag(136, 8);
        output.WriteBool(StartRotation3D);
      }
      if (StartSpeedMultiplier != 0F) {
        output.WriteRawTag(149, 8);
        output.WriteFloat(StartSpeedMultiplier);
      }
      if (startSize_ != null) {
        output.WriteRawTag(154, 8);
        output.WriteMessage(StartSize);
      }
      if (StartSizeMultiplier != 0F) {
        output.WriteRawTag(165, 8);
        output.WriteFloat(StartSizeMultiplier);
      }
      if (startSizeX_ != null) {
        output.WriteRawTag(170, 8);
        output.WriteMessage(StartSizeX);
      }
      if (StartSizeXMultiplier != 0F) {
        output.WriteRawTag(181, 8);
        output.WriteFloat(StartSizeXMultiplier);
      }
      if (startSizeY_ != null) {
        output.WriteRawTag(186, 8);
        output.WriteMessage(StartSizeY);
      }
      if (StartSizeYMultiplier != 0F) {
        output.WriteRawTag(197, 8);
        output.WriteFloat(StartSizeYMultiplier);
      }
      if (startSizeZ_ != null) {
        output.WriteRawTag(202, 8);
        output.WriteMessage(StartSizeZ);
      }
      if (StartSize3D != false) {
        output.WriteRawTag(208, 8);
        output.WriteBool(StartSize3D);
      }
      if (EmitterVelocityMode != 0) {
        output.WriteRawTag(216, 8);
        output.WriteEnum((int) EmitterVelocityMode);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Duration != 0F) {
        size += 2 + 4;
      }
      if (startRotationX_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartRotationX);
      }
      if (StartRotationXMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startRotationY_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartRotationY);
      }
      if (StartRotationYMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startRotationZ_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartRotationZ);
      }
      if (StartRotationZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (RandomizeRotationDirection != 0F) {
        size += 2 + 4;
      }
      if (StartRotationMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startColor_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartColor);
      }
      if (GravityModifierMultiplier != 0F) {
        size += 2 + 4;
      }
      if (SimulationSpace != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) SimulationSpace);
      }
      if (customSimulationSpace_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CustomSimulationSpace);
      }
      if (SimulationSpeed != 0F) {
        size += 2 + 4;
      }
      if (UseUnscaledTime != false) {
        size += 2 + 1;
      }
      if (ScalingMode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ScalingMode);
      }
      if (PlayOnAwake != false) {
        size += 2 + 1;
      }
      if (gravityModifier_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(GravityModifier);
      }
      if (MaxParticles != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxParticles);
      }
      if (startRotation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartRotation);
      }
      if (StartSizeZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (Loop != false) {
        size += 2 + 1;
      }
      if (Prewarm != false) {
        size += 2 + 1;
      }
      if (startDelay_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartDelay);
      }
      if (StartDelayMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartLifetime);
      }
      if (StartLifetimeMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startSpeed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartSpeed);
      }
      if (StartRotation3D != false) {
        size += 2 + 1;
      }
      if (StartSpeedMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startSize_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartSize);
      }
      if (StartSizeMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startSizeX_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartSizeX);
      }
      if (StartSizeXMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startSizeY_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartSizeY);
      }
      if (StartSizeYMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startSizeZ_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartSizeZ);
      }
      if (StartSize3D != false) {
        size += 2 + 1;
      }
      if (EmitterVelocityMode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) EmitterVelocityMode);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MainModule other) {
      if (other == null) {
        return;
      }
      if (other.Duration != 0F) {
        Duration = other.Duration;
      }
      if (other.startRotationX_ != null) {
        if (startRotationX_ == null) {
          startRotationX_ = new global::ProtoPs.MinMaxCurve();
        }
        StartRotationX.MergeFrom(other.StartRotationX);
      }
      if (other.StartRotationXMultiplier != 0F) {
        StartRotationXMultiplier = other.StartRotationXMultiplier;
      }
      if (other.startRotationY_ != null) {
        if (startRotationY_ == null) {
          startRotationY_ = new global::ProtoPs.MinMaxCurve();
        }
        StartRotationY.MergeFrom(other.StartRotationY);
      }
      if (other.StartRotationYMultiplier != 0F) {
        StartRotationYMultiplier = other.StartRotationYMultiplier;
      }
      if (other.startRotationZ_ != null) {
        if (startRotationZ_ == null) {
          startRotationZ_ = new global::ProtoPs.MinMaxCurve();
        }
        StartRotationZ.MergeFrom(other.StartRotationZ);
      }
      if (other.StartRotationZMultiplier != 0F) {
        StartRotationZMultiplier = other.StartRotationZMultiplier;
      }
      if (other.RandomizeRotationDirection != 0F) {
        RandomizeRotationDirection = other.RandomizeRotationDirection;
      }
      if (other.StartRotationMultiplier != 0F) {
        StartRotationMultiplier = other.StartRotationMultiplier;
      }
      if (other.startColor_ != null) {
        if (startColor_ == null) {
          startColor_ = new global::ProtoPs.MinMaxGradient();
        }
        StartColor.MergeFrom(other.StartColor);
      }
      if (other.GravityModifierMultiplier != 0F) {
        GravityModifierMultiplier = other.GravityModifierMultiplier;
      }
      if (other.SimulationSpace != 0) {
        SimulationSpace = other.SimulationSpace;
      }
      if (other.customSimulationSpace_ != null) {
        if (customSimulationSpace_ == null) {
          customSimulationSpace_ = new global::ProtoMath.transform();
        }
        CustomSimulationSpace.MergeFrom(other.CustomSimulationSpace);
      }
      if (other.SimulationSpeed != 0F) {
        SimulationSpeed = other.SimulationSpeed;
      }
      if (other.UseUnscaledTime != false) {
        UseUnscaledTime = other.UseUnscaledTime;
      }
      if (other.ScalingMode != 0) {
        ScalingMode = other.ScalingMode;
      }
      if (other.PlayOnAwake != false) {
        PlayOnAwake = other.PlayOnAwake;
      }
      if (other.gravityModifier_ != null) {
        if (gravityModifier_ == null) {
          gravityModifier_ = new global::ProtoPs.MinMaxCurve();
        }
        GravityModifier.MergeFrom(other.GravityModifier);
      }
      if (other.MaxParticles != 0) {
        MaxParticles = other.MaxParticles;
      }
      if (other.startRotation_ != null) {
        if (startRotation_ == null) {
          startRotation_ = new global::ProtoPs.MinMaxCurve();
        }
        StartRotation.MergeFrom(other.StartRotation);
      }
      if (other.StartSizeZMultiplier != 0F) {
        StartSizeZMultiplier = other.StartSizeZMultiplier;
      }
      if (other.Loop != false) {
        Loop = other.Loop;
      }
      if (other.Prewarm != false) {
        Prewarm = other.Prewarm;
      }
      if (other.startDelay_ != null) {
        if (startDelay_ == null) {
          startDelay_ = new global::ProtoPs.MinMaxCurve();
        }
        StartDelay.MergeFrom(other.StartDelay);
      }
      if (other.StartDelayMultiplier != 0F) {
        StartDelayMultiplier = other.StartDelayMultiplier;
      }
      if (other.startLifetime_ != null) {
        if (startLifetime_ == null) {
          startLifetime_ = new global::ProtoPs.MinMaxCurve();
        }
        StartLifetime.MergeFrom(other.StartLifetime);
      }
      if (other.StartLifetimeMultiplier != 0F) {
        StartLifetimeMultiplier = other.StartLifetimeMultiplier;
      }
      if (other.startSpeed_ != null) {
        if (startSpeed_ == null) {
          startSpeed_ = new global::ProtoPs.MinMaxCurve();
        }
        StartSpeed.MergeFrom(other.StartSpeed);
      }
      if (other.StartRotation3D != false) {
        StartRotation3D = other.StartRotation3D;
      }
      if (other.StartSpeedMultiplier != 0F) {
        StartSpeedMultiplier = other.StartSpeedMultiplier;
      }
      if (other.startSize_ != null) {
        if (startSize_ == null) {
          startSize_ = new global::ProtoPs.MinMaxCurve();
        }
        StartSize.MergeFrom(other.StartSize);
      }
      if (other.StartSizeMultiplier != 0F) {
        StartSizeMultiplier = other.StartSizeMultiplier;
      }
      if (other.startSizeX_ != null) {
        if (startSizeX_ == null) {
          startSizeX_ = new global::ProtoPs.MinMaxCurve();
        }
        StartSizeX.MergeFrom(other.StartSizeX);
      }
      if (other.StartSizeXMultiplier != 0F) {
        StartSizeXMultiplier = other.StartSizeXMultiplier;
      }
      if (other.startSizeY_ != null) {
        if (startSizeY_ == null) {
          startSizeY_ = new global::ProtoPs.MinMaxCurve();
        }
        StartSizeY.MergeFrom(other.StartSizeY);
      }
      if (other.StartSizeYMultiplier != 0F) {
        StartSizeYMultiplier = other.StartSizeYMultiplier;
      }
      if (other.startSizeZ_ != null) {
        if (startSizeZ_ == null) {
          startSizeZ_ = new global::ProtoPs.MinMaxCurve();
        }
        StartSizeZ.MergeFrom(other.StartSizeZ);
      }
      if (other.StartSize3D != false) {
        StartSize3D = other.StartSize3D;
      }
      if (other.EmitterVelocityMode != 0) {
        EmitterVelocityMode = other.EmitterVelocityMode;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 813: {
            Duration = input.ReadFloat();
            break;
          }
          case 818: {
            if (startRotationX_ == null) {
              startRotationX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startRotationX_);
            break;
          }
          case 829: {
            StartRotationXMultiplier = input.ReadFloat();
            break;
          }
          case 834: {
            if (startRotationY_ == null) {
              startRotationY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startRotationY_);
            break;
          }
          case 845: {
            StartRotationYMultiplier = input.ReadFloat();
            break;
          }
          case 850: {
            if (startRotationZ_ == null) {
              startRotationZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startRotationZ_);
            break;
          }
          case 861: {
            StartRotationZMultiplier = input.ReadFloat();
            break;
          }
          case 869: {
            RandomizeRotationDirection = input.ReadFloat();
            break;
          }
          case 877: {
            StartRotationMultiplier = input.ReadFloat();
            break;
          }
          case 882: {
            if (startColor_ == null) {
              startColor_ = new global::ProtoPs.MinMaxGradient();
            }
            input.ReadMessage(startColor_);
            break;
          }
          case 893: {
            GravityModifierMultiplier = input.ReadFloat();
            break;
          }
          case 896: {
            simulationSpace_ = (global::ProtoPs.ParticleSystemSimulationSpace) input.ReadEnum();
            break;
          }
          case 906: {
            if (customSimulationSpace_ == null) {
              customSimulationSpace_ = new global::ProtoMath.transform();
            }
            input.ReadMessage(customSimulationSpace_);
            break;
          }
          case 917: {
            SimulationSpeed = input.ReadFloat();
            break;
          }
          case 920: {
            UseUnscaledTime = input.ReadBool();
            break;
          }
          case 928: {
            scalingMode_ = (global::ProtoPs.ParticleSystemScalingMode) input.ReadEnum();
            break;
          }
          case 936: {
            PlayOnAwake = input.ReadBool();
            break;
          }
          case 946: {
            if (gravityModifier_ == null) {
              gravityModifier_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(gravityModifier_);
            break;
          }
          case 952: {
            MaxParticles = input.ReadInt32();
            break;
          }
          case 962: {
            if (startRotation_ == null) {
              startRotation_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startRotation_);
            break;
          }
          case 973: {
            StartSizeZMultiplier = input.ReadFloat();
            break;
          }
          case 976: {
            Loop = input.ReadBool();
            break;
          }
          case 984: {
            Prewarm = input.ReadBool();
            break;
          }
          case 994: {
            if (startDelay_ == null) {
              startDelay_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startDelay_);
            break;
          }
          case 1005: {
            StartDelayMultiplier = input.ReadFloat();
            break;
          }
          case 1010: {
            if (startLifetime_ == null) {
              startLifetime_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startLifetime_);
            break;
          }
          case 1021: {
            StartLifetimeMultiplier = input.ReadFloat();
            break;
          }
          case 1026: {
            if (startSpeed_ == null) {
              startSpeed_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startSpeed_);
            break;
          }
          case 1032: {
            StartRotation3D = input.ReadBool();
            break;
          }
          case 1045: {
            StartSpeedMultiplier = input.ReadFloat();
            break;
          }
          case 1050: {
            if (startSize_ == null) {
              startSize_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startSize_);
            break;
          }
          case 1061: {
            StartSizeMultiplier = input.ReadFloat();
            break;
          }
          case 1066: {
            if (startSizeX_ == null) {
              startSizeX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startSizeX_);
            break;
          }
          case 1077: {
            StartSizeXMultiplier = input.ReadFloat();
            break;
          }
          case 1082: {
            if (startSizeY_ == null) {
              startSizeY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startSizeY_);
            break;
          }
          case 1093: {
            StartSizeYMultiplier = input.ReadFloat();
            break;
          }
          case 1098: {
            if (startSizeZ_ == null) {
              startSizeZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startSizeZ_);
            break;
          }
          case 1104: {
            StartSize3D = input.ReadBool();
            break;
          }
          case 1112: {
            emitterVelocityMode_ = (global::ProtoPs.ParticleSystemEmitterVelocityMode) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ColorBySpeedModule : pb::IMessage<ColorBySpeedModule> {
    private static readonly pb::MessageParser<ColorBySpeedModule> _parser = new pb::MessageParser<ColorBySpeedModule>(() => new ColorBySpeedModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ColorBySpeedModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColorBySpeedModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColorBySpeedModule(ColorBySpeedModule other) : this() {
      enabled_ = other.enabled_;
      Color = other.color_ != null ? other.Color.Clone() : null;
      Range = other.range_ != null ? other.Range.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColorBySpeedModule Clone() {
      return new ColorBySpeedModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 101;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "color" field.</summary>
    public const int ColorFieldNumber = 102;
    private global::ProtoPs.MinMaxGradient color_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxGradient Color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 103;
    private global::ProtoMath.float2 range_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float2 Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ColorBySpeedModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ColorBySpeedModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(Color, other.Color)) return false;
      if (!object.Equals(Range, other.Range)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (color_ != null) hash ^= Color.GetHashCode();
      if (range_ != null) hash ^= Range.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(168, 6);
        output.WriteBool(Enabled);
      }
      if (color_ != null) {
        output.WriteRawTag(178, 6);
        output.WriteMessage(Color);
      }
      if (range_ != null) {
        output.WriteRawTag(186, 6);
        output.WriteMessage(Range);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 2 + 1;
      }
      if (color_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Color);
      }
      if (range_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Range);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ColorBySpeedModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.color_ != null) {
        if (color_ == null) {
          color_ = new global::ProtoPs.MinMaxGradient();
        }
        Color.MergeFrom(other.Color);
      }
      if (other.range_ != null) {
        if (range_ == null) {
          range_ = new global::ProtoMath.float2();
        }
        Range.MergeFrom(other.Range);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 808: {
            Enabled = input.ReadBool();
            break;
          }
          case 818: {
            if (color_ == null) {
              color_ = new global::ProtoPs.MinMaxGradient();
            }
            input.ReadMessage(color_);
            break;
          }
          case 826: {
            if (range_ == null) {
              range_ = new global::ProtoMath.float2();
            }
            input.ReadMessage(range_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class TextureSheetAnimationModule : pb::IMessage<TextureSheetAnimationModule> {
    private static readonly pb::MessageParser<TextureSheetAnimationModule> _parser = new pb::MessageParser<TextureSheetAnimationModule>(() => new TextureSheetAnimationModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TextureSheetAnimationModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TextureSheetAnimationModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TextureSheetAnimationModule(TextureSheetAnimationModule other) : this() {
      useRandomRow_ = other.useRandomRow_;
      flipU_ = other.flipU_;
      rowIndex_ = other.rowIndex_;
      cycleCount_ = other.cycleCount_;
      startFrameMultiplier_ = other.startFrameMultiplier_;
      StartFrame = other.startFrame_ != null ? other.StartFrame.Clone() : null;
      frameOverTimeMultiplier_ = other.frameOverTimeMultiplier_;
      FrameOverTime = other.frameOverTime_ != null ? other.FrameOverTime.Clone() : null;
      spriteCount_ = other.spriteCount_;
      animation_ = other.animation_;
      numTilesY_ = other.numTilesY_;
      numTilesX_ = other.numTilesX_;
      mode_ = other.mode_;
      enabled_ = other.enabled_;
      flipV_ = other.flipV_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TextureSheetAnimationModule Clone() {
      return new TextureSheetAnimationModule(this);
    }

    /// <summary>Field number for the "useRandomRow" field.</summary>
    public const int UseRandomRowFieldNumber = 101;
    private bool useRandomRow_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseRandomRow {
      get { return useRandomRow_; }
      set {
        useRandomRow_ = value;
      }
    }

    /// <summary>Field number for the "flipU" field.</summary>
    public const int FlipUFieldNumber = 102;
    private float flipU_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float FlipU {
      get { return flipU_; }
      set {
        flipU_ = value;
      }
    }

    /// <summary>Field number for the "rowIndex" field.</summary>
    public const int RowIndexFieldNumber = 104;
    private int rowIndex_;
    /// <summary>
    ///which row of the texture sheet is used, when ParticleSystem.TextureSheetAnimationModule.useRandomRow  is set to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int RowIndex {
      get { return rowIndex_; }
      set {
        rowIndex_ = value;
      }
    }

    /// <summary>Field number for the "cycleCount" field.</summary>
    public const int CycleCountFieldNumber = 105;
    private int cycleCount_;
    /// <summary>
    ///Specifies how many times the animation will loop during the lifetime of the particle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CycleCount {
      get { return cycleCount_; }
      set {
        cycleCount_ = value;
      }
    }

    /// <summary>Field number for the "startFrameMultiplier" field.</summary>
    public const int StartFrameMultiplierFieldNumber = 106;
    private float startFrameMultiplier_;
    /// <summary>
    ///Starting frame multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StartFrameMultiplier {
      get { return startFrameMultiplier_; }
      set {
        startFrameMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "startFrame" field.</summary>
    public const int StartFrameFieldNumber = 107;
    private global::ProtoPs.MinMaxCurve startFrame_;
    /// <summary>
    ///Define a random starting frame for the texture sheet animation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StartFrame {
      get { return startFrame_; }
      set {
        startFrame_ = value;
      }
    }

    /// <summary>Field number for the "frameOverTimeMultiplier" field.</summary>
    public const int FrameOverTimeMultiplierFieldNumber = 108;
    private float frameOverTimeMultiplier_;
    /// <summary>
    ///Frame over time mutiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float FrameOverTimeMultiplier {
      get { return frameOverTimeMultiplier_; }
      set {
        frameOverTimeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "frameOverTime" field.</summary>
    public const int FrameOverTimeFieldNumber = 109;
    private global::ProtoPs.MinMaxCurve frameOverTime_;
    /// <summary>
    ///Curve to control which frame of the texture sheet animation to play.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve FrameOverTime {
      get { return frameOverTime_; }
      set {
        frameOverTime_ = value;
      }
    }

    /// <summary>Field number for the "spriteCount" field.</summary>
    public const int SpriteCountFieldNumber = 110;
    private int spriteCount_;
    /// <summary>
    ///     The total number of sprites.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SpriteCount {
      get { return spriteCount_; }
      set {
        spriteCount_ = value;
      }
    }

    /// <summary>Field number for the "animation" field.</summary>
    public const int AnimationFieldNumber = 111;
    private global::ProtoPs.ParticleSystemAnimationType animation_ = 0;
    /// <summary>
    ///     Specifies the animation type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemAnimationType Animation {
      get { return animation_; }
      set {
        animation_ = value;
      }
    }

    /// <summary>Field number for the "numTilesY" field.</summary>
    public const int NumTilesYFieldNumber = 112;
    private int numTilesY_;
    /// <summary>
    ///     Defines the tiling of the texture in the Y axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumTilesY {
      get { return numTilesY_; }
      set {
        numTilesY_ = value;
      }
    }

    /// <summary>Field number for the "numTilesX" field.</summary>
    public const int NumTilesXFieldNumber = 113;
    private int numTilesX_;
    /// <summary>
    ///     Defines the tiling of the texture in the X axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumTilesX {
      get { return numTilesX_; }
      set {
        numTilesX_ = value;
      }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 114;
    private global::ProtoPs.ParticleSystemAnimationMode mode_ = 0;
    /// <summary>
    ///Select whether the animated texture information comes from a grid of frames on a single texture, or from a list of Sprite objects.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemAnimationMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 115;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "flipV" field.</summary>
    public const int FlipVFieldNumber = 116;
    private float flipV_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float FlipV {
      get { return flipV_; }
      set {
        flipV_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TextureSheetAnimationModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TextureSheetAnimationModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (UseRandomRow != other.UseRandomRow) return false;
      if (FlipU != other.FlipU) return false;
      if (RowIndex != other.RowIndex) return false;
      if (CycleCount != other.CycleCount) return false;
      if (StartFrameMultiplier != other.StartFrameMultiplier) return false;
      if (!object.Equals(StartFrame, other.StartFrame)) return false;
      if (FrameOverTimeMultiplier != other.FrameOverTimeMultiplier) return false;
      if (!object.Equals(FrameOverTime, other.FrameOverTime)) return false;
      if (SpriteCount != other.SpriteCount) return false;
      if (Animation != other.Animation) return false;
      if (NumTilesY != other.NumTilesY) return false;
      if (NumTilesX != other.NumTilesX) return false;
      if (Mode != other.Mode) return false;
      if (Enabled != other.Enabled) return false;
      if (FlipV != other.FlipV) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (UseRandomRow != false) hash ^= UseRandomRow.GetHashCode();
      if (FlipU != 0F) hash ^= FlipU.GetHashCode();
      if (RowIndex != 0) hash ^= RowIndex.GetHashCode();
      if (CycleCount != 0) hash ^= CycleCount.GetHashCode();
      if (StartFrameMultiplier != 0F) hash ^= StartFrameMultiplier.GetHashCode();
      if (startFrame_ != null) hash ^= StartFrame.GetHashCode();
      if (FrameOverTimeMultiplier != 0F) hash ^= FrameOverTimeMultiplier.GetHashCode();
      if (frameOverTime_ != null) hash ^= FrameOverTime.GetHashCode();
      if (SpriteCount != 0) hash ^= SpriteCount.GetHashCode();
      if (Animation != 0) hash ^= Animation.GetHashCode();
      if (NumTilesY != 0) hash ^= NumTilesY.GetHashCode();
      if (NumTilesX != 0) hash ^= NumTilesX.GetHashCode();
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (FlipV != 0F) hash ^= FlipV.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (UseRandomRow != false) {
        output.WriteRawTag(168, 6);
        output.WriteBool(UseRandomRow);
      }
      if (FlipU != 0F) {
        output.WriteRawTag(181, 6);
        output.WriteFloat(FlipU);
      }
      if (RowIndex != 0) {
        output.WriteRawTag(192, 6);
        output.WriteInt32(RowIndex);
      }
      if (CycleCount != 0) {
        output.WriteRawTag(200, 6);
        output.WriteInt32(CycleCount);
      }
      if (StartFrameMultiplier != 0F) {
        output.WriteRawTag(213, 6);
        output.WriteFloat(StartFrameMultiplier);
      }
      if (startFrame_ != null) {
        output.WriteRawTag(218, 6);
        output.WriteMessage(StartFrame);
      }
      if (FrameOverTimeMultiplier != 0F) {
        output.WriteRawTag(229, 6);
        output.WriteFloat(FrameOverTimeMultiplier);
      }
      if (frameOverTime_ != null) {
        output.WriteRawTag(234, 6);
        output.WriteMessage(FrameOverTime);
      }
      if (SpriteCount != 0) {
        output.WriteRawTag(240, 6);
        output.WriteInt32(SpriteCount);
      }
      if (Animation != 0) {
        output.WriteRawTag(248, 6);
        output.WriteEnum((int) Animation);
      }
      if (NumTilesY != 0) {
        output.WriteRawTag(128, 7);
        output.WriteInt32(NumTilesY);
      }
      if (NumTilesX != 0) {
        output.WriteRawTag(136, 7);
        output.WriteInt32(NumTilesX);
      }
      if (Mode != 0) {
        output.WriteRawTag(144, 7);
        output.WriteEnum((int) Mode);
      }
      if (Enabled != false) {
        output.WriteRawTag(152, 7);
        output.WriteBool(Enabled);
      }
      if (FlipV != 0F) {
        output.WriteRawTag(165, 7);
        output.WriteFloat(FlipV);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (UseRandomRow != false) {
        size += 2 + 1;
      }
      if (FlipU != 0F) {
        size += 2 + 4;
      }
      if (RowIndex != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(RowIndex);
      }
      if (CycleCount != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(CycleCount);
      }
      if (StartFrameMultiplier != 0F) {
        size += 2 + 4;
      }
      if (startFrame_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartFrame);
      }
      if (FrameOverTimeMultiplier != 0F) {
        size += 2 + 4;
      }
      if (frameOverTime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(FrameOverTime);
      }
      if (SpriteCount != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(SpriteCount);
      }
      if (Animation != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Animation);
      }
      if (NumTilesY != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(NumTilesY);
      }
      if (NumTilesX != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(NumTilesX);
      }
      if (Mode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (Enabled != false) {
        size += 2 + 1;
      }
      if (FlipV != 0F) {
        size += 2 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TextureSheetAnimationModule other) {
      if (other == null) {
        return;
      }
      if (other.UseRandomRow != false) {
        UseRandomRow = other.UseRandomRow;
      }
      if (other.FlipU != 0F) {
        FlipU = other.FlipU;
      }
      if (other.RowIndex != 0) {
        RowIndex = other.RowIndex;
      }
      if (other.CycleCount != 0) {
        CycleCount = other.CycleCount;
      }
      if (other.StartFrameMultiplier != 0F) {
        StartFrameMultiplier = other.StartFrameMultiplier;
      }
      if (other.startFrame_ != null) {
        if (startFrame_ == null) {
          startFrame_ = new global::ProtoPs.MinMaxCurve();
        }
        StartFrame.MergeFrom(other.StartFrame);
      }
      if (other.FrameOverTimeMultiplier != 0F) {
        FrameOverTimeMultiplier = other.FrameOverTimeMultiplier;
      }
      if (other.frameOverTime_ != null) {
        if (frameOverTime_ == null) {
          frameOverTime_ = new global::ProtoPs.MinMaxCurve();
        }
        FrameOverTime.MergeFrom(other.FrameOverTime);
      }
      if (other.SpriteCount != 0) {
        SpriteCount = other.SpriteCount;
      }
      if (other.Animation != 0) {
        Animation = other.Animation;
      }
      if (other.NumTilesY != 0) {
        NumTilesY = other.NumTilesY;
      }
      if (other.NumTilesX != 0) {
        NumTilesX = other.NumTilesX;
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.FlipV != 0F) {
        FlipV = other.FlipV;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 808: {
            UseRandomRow = input.ReadBool();
            break;
          }
          case 821: {
            FlipU = input.ReadFloat();
            break;
          }
          case 832: {
            RowIndex = input.ReadInt32();
            break;
          }
          case 840: {
            CycleCount = input.ReadInt32();
            break;
          }
          case 853: {
            StartFrameMultiplier = input.ReadFloat();
            break;
          }
          case 858: {
            if (startFrame_ == null) {
              startFrame_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(startFrame_);
            break;
          }
          case 869: {
            FrameOverTimeMultiplier = input.ReadFloat();
            break;
          }
          case 874: {
            if (frameOverTime_ == null) {
              frameOverTime_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(frameOverTime_);
            break;
          }
          case 880: {
            SpriteCount = input.ReadInt32();
            break;
          }
          case 888: {
            animation_ = (global::ProtoPs.ParticleSystemAnimationType) input.ReadEnum();
            break;
          }
          case 896: {
            NumTilesY = input.ReadInt32();
            break;
          }
          case 904: {
            NumTilesX = input.ReadInt32();
            break;
          }
          case 912: {
            mode_ = (global::ProtoPs.ParticleSystemAnimationMode) input.ReadEnum();
            break;
          }
          case 920: {
            Enabled = input.ReadBool();
            break;
          }
          case 933: {
            FlipV = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SubEmitter : pb::IMessage<SubEmitter> {
    private static readonly pb::MessageParser<SubEmitter> _parser = new pb::MessageParser<SubEmitter>(() => new SubEmitter());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubEmitter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubEmitter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubEmitter(SubEmitter other) : this() {
      ps_ = other.ps_;
      type_ = other.type_;
      inherit_ = other.inherit_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubEmitter Clone() {
      return new SubEmitter(this);
    }

    /// <summary>Field number for the "ps" field.</summary>
    public const int PsFieldNumber = 1;
    private string ps_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Ps {
      get { return ps_; }
      set {
        ps_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::ProtoPs.ParticleSystemSubEmitterType type_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSubEmitterType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "inherit" field.</summary>
    public const int InheritFieldNumber = 3;
    private global::ProtoPs.ParticleSystemSubEmitterProperties inherit_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSubEmitterProperties Inherit {
      get { return inherit_; }
      set {
        inherit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubEmitter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubEmitter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Ps != other.Ps) return false;
      if (Type != other.Type) return false;
      if (Inherit != other.Inherit) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Ps.Length != 0) hash ^= Ps.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (Inherit != 0) hash ^= Inherit.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Ps.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Ps);
      }
      if (Type != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (Inherit != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Inherit);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Ps.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ps);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Inherit != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Inherit);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubEmitter other) {
      if (other == null) {
        return;
      }
      if (other.Ps.Length != 0) {
        Ps = other.Ps;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.Inherit != 0) {
        Inherit = other.Inherit;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Ps = input.ReadString();
            break;
          }
          case 16: {
            type_ = (global::ProtoPs.ParticleSystemSubEmitterType) input.ReadEnum();
            break;
          }
          case 24: {
            inherit_ = (global::ProtoPs.ParticleSystemSubEmitterProperties) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SubEmittersModule : pb::IMessage<SubEmittersModule> {
    private static readonly pb::MessageParser<SubEmittersModule> _parser = new pb::MessageParser<SubEmittersModule>(() => new SubEmittersModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubEmittersModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubEmittersModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubEmittersModule(SubEmittersModule other) : this() {
      enabled_ = other.enabled_;
      subEmittersCount_ = other.subEmittersCount_;
      subEmitters_ = other.subEmitters_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubEmittersModule Clone() {
      return new SubEmittersModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "subEmittersCount" field.</summary>
    public const int SubEmittersCountFieldNumber = 2;
    private int subEmittersCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SubEmittersCount {
      get { return subEmittersCount_; }
      set {
        subEmittersCount_ = value;
      }
    }

    /// <summary>Field number for the "subEmitters" field.</summary>
    public const int SubEmittersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::ProtoPs.SubEmitter> _repeated_subEmitters_codec
        = pb::FieldCodec.ForMessage(26, global::ProtoPs.SubEmitter.Parser);
    private readonly pbc::RepeatedField<global::ProtoPs.SubEmitter> subEmitters_ = new pbc::RepeatedField<global::ProtoPs.SubEmitter>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ProtoPs.SubEmitter> SubEmitters {
      get { return subEmitters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubEmittersModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubEmittersModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (SubEmittersCount != other.SubEmittersCount) return false;
      if(!subEmitters_.Equals(other.subEmitters_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (SubEmittersCount != 0) hash ^= SubEmittersCount.GetHashCode();
      hash ^= subEmitters_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (SubEmittersCount != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(SubEmittersCount);
      }
      subEmitters_.WriteTo(output, _repeated_subEmitters_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (SubEmittersCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SubEmittersCount);
      }
      size += subEmitters_.CalculateSize(_repeated_subEmitters_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubEmittersModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.SubEmittersCount != 0) {
        SubEmittersCount = other.SubEmittersCount;
      }
      subEmitters_.Add(other.subEmitters_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 16: {
            SubEmittersCount = input.ReadInt32();
            break;
          }
          case 26: {
            subEmitters_.AddEntriesFrom(input, _repeated_subEmitters_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ExternalForcesModule : pb::IMessage<ExternalForcesModule> {
    private static readonly pb::MessageParser<ExternalForcesModule> _parser = new pb::MessageParser<ExternalForcesModule>(() => new ExternalForcesModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExternalForcesModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalForcesModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalForcesModule(ExternalForcesModule other) : this() {
      enabled_ = other.enabled_;
      multiplier_ = other.multiplier_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalForcesModule Clone() {
      return new ExternalForcesModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "multiplier" field.</summary>
    public const int MultiplierFieldNumber = 2;
    private float multiplier_;
    /// <summary>
    ///     Multiplies the magnitude of applied external forces.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Multiplier {
      get { return multiplier_; }
      set {
        multiplier_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExternalForcesModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExternalForcesModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (Multiplier != other.Multiplier) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (Multiplier != 0F) hash ^= Multiplier.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (Multiplier != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Multiplier);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (Multiplier != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExternalForcesModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.Multiplier != 0F) {
        Multiplier = other.Multiplier;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 21: {
            Multiplier = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class RotationBySpeedModule : pb::IMessage<RotationBySpeedModule> {
    private static readonly pb::MessageParser<RotationBySpeedModule> _parser = new pb::MessageParser<RotationBySpeedModule>(() => new RotationBySpeedModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RotationBySpeedModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationBySpeedModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationBySpeedModule(RotationBySpeedModule other) : this() {
      enabled_ = other.enabled_;
      X = other.x_ != null ? other.X.Clone() : null;
      xMultiplier_ = other.xMultiplier_;
      Y = other.y_ != null ? other.Y.Clone() : null;
      yMultiplier_ = other.yMultiplier_;
      Z = other.z_ != null ? other.Z.Clone() : null;
      zMultiplier_ = other.zMultiplier_;
      separateAxes_ = other.separateAxes_;
      Range = other.range_ != null ? other.Range.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationBySpeedModule Clone() {
      return new RotationBySpeedModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve x_;
    /// <summary>
    ///     Rotation by speed curve for the X axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "xMultiplier" field.</summary>
    public const int XMultiplierFieldNumber = 12;
    private float xMultiplier_;
    /// <summary>
    ///     Speed multiplier along the X axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XMultiplier {
      get { return xMultiplier_; }
      set {
        xMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve y_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "yMultiplier" field.</summary>
    public const int YMultiplierFieldNumber = 14;
    private float yMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YMultiplier {
      get { return yMultiplier_; }
      set {
        yMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 15;
    private global::ProtoPs.MinMaxCurve z_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    /// <summary>Field number for the "zMultiplier" field.</summary>
    public const int ZMultiplierFieldNumber = 16;
    private float zMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ZMultiplier {
      get { return zMultiplier_; }
      set {
        zMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "separateAxes" field.</summary>
    public const int SeparateAxesFieldNumber = 17;
    private bool separateAxes_;
    /// <summary>
    ///     Set the rotation by speed on each axis separately.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SeparateAxes {
      get { return separateAxes_; }
      set {
        separateAxes_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 18;
    private global::ProtoMath.float2 range_;
    /// <summary>
    ///     Apply the rotation curve between these minimum and maximum speeds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float2 Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RotationBySpeedModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RotationBySpeedModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(X, other.X)) return false;
      if (XMultiplier != other.XMultiplier) return false;
      if (!object.Equals(Y, other.Y)) return false;
      if (YMultiplier != other.YMultiplier) return false;
      if (!object.Equals(Z, other.Z)) return false;
      if (ZMultiplier != other.ZMultiplier) return false;
      if (SeparateAxes != other.SeparateAxes) return false;
      if (!object.Equals(Range, other.Range)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (x_ != null) hash ^= X.GetHashCode();
      if (XMultiplier != 0F) hash ^= XMultiplier.GetHashCode();
      if (y_ != null) hash ^= Y.GetHashCode();
      if (YMultiplier != 0F) hash ^= YMultiplier.GetHashCode();
      if (z_ != null) hash ^= Z.GetHashCode();
      if (ZMultiplier != 0F) hash ^= ZMultiplier.GetHashCode();
      if (SeparateAxes != false) hash ^= SeparateAxes.GetHashCode();
      if (range_ != null) hash ^= Range.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (x_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(X);
      }
      if (XMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(XMultiplier);
      }
      if (y_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Y);
      }
      if (YMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(YMultiplier);
      }
      if (z_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Z);
      }
      if (ZMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ZMultiplier);
      }
      if (SeparateAxes != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(SeparateAxes);
      }
      if (range_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(Range);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (x_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X);
      }
      if (XMultiplier != 0F) {
        size += 1 + 4;
      }
      if (y_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Y);
      }
      if (YMultiplier != 0F) {
        size += 1 + 4;
      }
      if (z_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Z);
      }
      if (ZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (SeparateAxes != false) {
        size += 2 + 1;
      }
      if (range_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Range);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RotationBySpeedModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.x_ != null) {
        if (x_ == null) {
          x_ = new global::ProtoPs.MinMaxCurve();
        }
        X.MergeFrom(other.X);
      }
      if (other.XMultiplier != 0F) {
        XMultiplier = other.XMultiplier;
      }
      if (other.y_ != null) {
        if (y_ == null) {
          y_ = new global::ProtoPs.MinMaxCurve();
        }
        Y.MergeFrom(other.Y);
      }
      if (other.YMultiplier != 0F) {
        YMultiplier = other.YMultiplier;
      }
      if (other.z_ != null) {
        if (z_ == null) {
          z_ = new global::ProtoPs.MinMaxCurve();
        }
        Z.MergeFrom(other.Z);
      }
      if (other.ZMultiplier != 0F) {
        ZMultiplier = other.ZMultiplier;
      }
      if (other.SeparateAxes != false) {
        SeparateAxes = other.SeparateAxes;
      }
      if (other.range_ != null) {
        if (range_ == null) {
          range_ = new global::ProtoMath.float2();
        }
        Range.MergeFrom(other.Range);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (x_ == null) {
              x_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(x_);
            break;
          }
          case 101: {
            XMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (y_ == null) {
              y_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(y_);
            break;
          }
          case 117: {
            YMultiplier = input.ReadFloat();
            break;
          }
          case 122: {
            if (z_ == null) {
              z_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(z_);
            break;
          }
          case 133: {
            ZMultiplier = input.ReadFloat();
            break;
          }
          case 136: {
            SeparateAxes = input.ReadBool();
            break;
          }
          case 146: {
            if (range_ == null) {
              range_ = new global::ProtoMath.float2();
            }
            input.ReadMessage(range_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class RotationOverLifetimeModule : pb::IMessage<RotationOverLifetimeModule> {
    private static readonly pb::MessageParser<RotationOverLifetimeModule> _parser = new pb::MessageParser<RotationOverLifetimeModule>(() => new RotationOverLifetimeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RotationOverLifetimeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationOverLifetimeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationOverLifetimeModule(RotationOverLifetimeModule other) : this() {
      enabled_ = other.enabled_;
      X = other.x_ != null ? other.X.Clone() : null;
      xMultiplier_ = other.xMultiplier_;
      Y = other.y_ != null ? other.Y.Clone() : null;
      yMultiplier_ = other.yMultiplier_;
      Z = other.z_ != null ? other.Z.Clone() : null;
      zMultiplier_ = other.zMultiplier_;
      separateAxes_ = other.separateAxes_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationOverLifetimeModule Clone() {
      return new RotationOverLifetimeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve x_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "xMultiplier" field.</summary>
    public const int XMultiplierFieldNumber = 12;
    private float xMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XMultiplier {
      get { return xMultiplier_; }
      set {
        xMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve y_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "yMultiplier" field.</summary>
    public const int YMultiplierFieldNumber = 14;
    private float yMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YMultiplier {
      get { return yMultiplier_; }
      set {
        yMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 15;
    private global::ProtoPs.MinMaxCurve z_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    /// <summary>Field number for the "zMultiplier" field.</summary>
    public const int ZMultiplierFieldNumber = 16;
    private float zMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ZMultiplier {
      get { return zMultiplier_; }
      set {
        zMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "separateAxes" field.</summary>
    public const int SeparateAxesFieldNumber = 17;
    private bool separateAxes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SeparateAxes {
      get { return separateAxes_; }
      set {
        separateAxes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RotationOverLifetimeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RotationOverLifetimeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(X, other.X)) return false;
      if (XMultiplier != other.XMultiplier) return false;
      if (!object.Equals(Y, other.Y)) return false;
      if (YMultiplier != other.YMultiplier) return false;
      if (!object.Equals(Z, other.Z)) return false;
      if (ZMultiplier != other.ZMultiplier) return false;
      if (SeparateAxes != other.SeparateAxes) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (x_ != null) hash ^= X.GetHashCode();
      if (XMultiplier != 0F) hash ^= XMultiplier.GetHashCode();
      if (y_ != null) hash ^= Y.GetHashCode();
      if (YMultiplier != 0F) hash ^= YMultiplier.GetHashCode();
      if (z_ != null) hash ^= Z.GetHashCode();
      if (ZMultiplier != 0F) hash ^= ZMultiplier.GetHashCode();
      if (SeparateAxes != false) hash ^= SeparateAxes.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (x_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(X);
      }
      if (XMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(XMultiplier);
      }
      if (y_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Y);
      }
      if (YMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(YMultiplier);
      }
      if (z_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Z);
      }
      if (ZMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ZMultiplier);
      }
      if (SeparateAxes != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(SeparateAxes);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (x_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X);
      }
      if (XMultiplier != 0F) {
        size += 1 + 4;
      }
      if (y_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Y);
      }
      if (YMultiplier != 0F) {
        size += 1 + 4;
      }
      if (z_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Z);
      }
      if (ZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (SeparateAxes != false) {
        size += 2 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RotationOverLifetimeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.x_ != null) {
        if (x_ == null) {
          x_ = new global::ProtoPs.MinMaxCurve();
        }
        X.MergeFrom(other.X);
      }
      if (other.XMultiplier != 0F) {
        XMultiplier = other.XMultiplier;
      }
      if (other.y_ != null) {
        if (y_ == null) {
          y_ = new global::ProtoPs.MinMaxCurve();
        }
        Y.MergeFrom(other.Y);
      }
      if (other.YMultiplier != 0F) {
        YMultiplier = other.YMultiplier;
      }
      if (other.z_ != null) {
        if (z_ == null) {
          z_ = new global::ProtoPs.MinMaxCurve();
        }
        Z.MergeFrom(other.Z);
      }
      if (other.ZMultiplier != 0F) {
        ZMultiplier = other.ZMultiplier;
      }
      if (other.SeparateAxes != false) {
        SeparateAxes = other.SeparateAxes;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (x_ == null) {
              x_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(x_);
            break;
          }
          case 101: {
            XMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (y_ == null) {
              y_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(y_);
            break;
          }
          case 117: {
            YMultiplier = input.ReadFloat();
            break;
          }
          case 122: {
            if (z_ == null) {
              z_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(z_);
            break;
          }
          case 133: {
            ZMultiplier = input.ReadFloat();
            break;
          }
          case 136: {
            SeparateAxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SizeBySpeedModule : pb::IMessage<SizeBySpeedModule> {
    private static readonly pb::MessageParser<SizeBySpeedModule> _parser = new pb::MessageParser<SizeBySpeedModule>(() => new SizeBySpeedModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SizeBySpeedModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SizeBySpeedModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SizeBySpeedModule(SizeBySpeedModule other) : this() {
      enabled_ = other.enabled_;
      Size = other.size_ != null ? other.Size.Clone() : null;
      sizeMultiplier_ = other.sizeMultiplier_;
      X = other.x_ != null ? other.X.Clone() : null;
      xMultiplier_ = other.xMultiplier_;
      Y = other.y_ != null ? other.Y.Clone() : null;
      yMultiplier_ = other.yMultiplier_;
      Z = other.z_ != null ? other.Z.Clone() : null;
      zMultiplier_ = other.zMultiplier_;
      separateAxes_ = other.separateAxes_;
      Range = other.range_ != null ? other.Range.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SizeBySpeedModule Clone() {
      return new SizeBySpeedModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Size {
      get { return size_; }
      set {
        size_ = value;
      }
    }

    /// <summary>Field number for the "sizeMultiplier" field.</summary>
    public const int SizeMultiplierFieldNumber = 12;
    private float sizeMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SizeMultiplier {
      get { return sizeMultiplier_; }
      set {
        sizeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve x_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "xMultiplier" field.</summary>
    public const int XMultiplierFieldNumber = 14;
    private float xMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XMultiplier {
      get { return xMultiplier_; }
      set {
        xMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 15;
    private global::ProtoPs.MinMaxCurve y_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "yMultiplier" field.</summary>
    public const int YMultiplierFieldNumber = 16;
    private float yMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YMultiplier {
      get { return yMultiplier_; }
      set {
        yMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 17;
    private global::ProtoPs.MinMaxCurve z_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    /// <summary>Field number for the "zMultiplier" field.</summary>
    public const int ZMultiplierFieldNumber = 18;
    private float zMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ZMultiplier {
      get { return zMultiplier_; }
      set {
        zMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "separateAxes" field.</summary>
    public const int SeparateAxesFieldNumber = 19;
    private bool separateAxes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SeparateAxes {
      get { return separateAxes_; }
      set {
        separateAxes_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 20;
    private global::ProtoMath.float2 range_;
    /// <summary>
    ///     Apply the size curve between these minimum and maximum speeds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float2 Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SizeBySpeedModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SizeBySpeedModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(Size, other.Size)) return false;
      if (SizeMultiplier != other.SizeMultiplier) return false;
      if (!object.Equals(X, other.X)) return false;
      if (XMultiplier != other.XMultiplier) return false;
      if (!object.Equals(Y, other.Y)) return false;
      if (YMultiplier != other.YMultiplier) return false;
      if (!object.Equals(Z, other.Z)) return false;
      if (ZMultiplier != other.ZMultiplier) return false;
      if (SeparateAxes != other.SeparateAxes) return false;
      if (!object.Equals(Range, other.Range)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (size_ != null) hash ^= Size.GetHashCode();
      if (SizeMultiplier != 0F) hash ^= SizeMultiplier.GetHashCode();
      if (x_ != null) hash ^= X.GetHashCode();
      if (XMultiplier != 0F) hash ^= XMultiplier.GetHashCode();
      if (y_ != null) hash ^= Y.GetHashCode();
      if (YMultiplier != 0F) hash ^= YMultiplier.GetHashCode();
      if (z_ != null) hash ^= Z.GetHashCode();
      if (ZMultiplier != 0F) hash ^= ZMultiplier.GetHashCode();
      if (SeparateAxes != false) hash ^= SeparateAxes.GetHashCode();
      if (range_ != null) hash ^= Range.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (size_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Size);
      }
      if (SizeMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(SizeMultiplier);
      }
      if (x_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(X);
      }
      if (XMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(XMultiplier);
      }
      if (y_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Y);
      }
      if (YMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(YMultiplier);
      }
      if (z_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Z);
      }
      if (ZMultiplier != 0F) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(ZMultiplier);
      }
      if (SeparateAxes != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(SeparateAxes);
      }
      if (range_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(Range);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (size_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Size);
      }
      if (SizeMultiplier != 0F) {
        size += 1 + 4;
      }
      if (x_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X);
      }
      if (XMultiplier != 0F) {
        size += 1 + 4;
      }
      if (y_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Y);
      }
      if (YMultiplier != 0F) {
        size += 2 + 4;
      }
      if (z_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Z);
      }
      if (ZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (SeparateAxes != false) {
        size += 2 + 1;
      }
      if (range_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Range);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SizeBySpeedModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.size_ != null) {
        if (size_ == null) {
          size_ = new global::ProtoPs.MinMaxCurve();
        }
        Size.MergeFrom(other.Size);
      }
      if (other.SizeMultiplier != 0F) {
        SizeMultiplier = other.SizeMultiplier;
      }
      if (other.x_ != null) {
        if (x_ == null) {
          x_ = new global::ProtoPs.MinMaxCurve();
        }
        X.MergeFrom(other.X);
      }
      if (other.XMultiplier != 0F) {
        XMultiplier = other.XMultiplier;
      }
      if (other.y_ != null) {
        if (y_ == null) {
          y_ = new global::ProtoPs.MinMaxCurve();
        }
        Y.MergeFrom(other.Y);
      }
      if (other.YMultiplier != 0F) {
        YMultiplier = other.YMultiplier;
      }
      if (other.z_ != null) {
        if (z_ == null) {
          z_ = new global::ProtoPs.MinMaxCurve();
        }
        Z.MergeFrom(other.Z);
      }
      if (other.ZMultiplier != 0F) {
        ZMultiplier = other.ZMultiplier;
      }
      if (other.SeparateAxes != false) {
        SeparateAxes = other.SeparateAxes;
      }
      if (other.range_ != null) {
        if (range_ == null) {
          range_ = new global::ProtoMath.float2();
        }
        Range.MergeFrom(other.Range);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (size_ == null) {
              size_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(size_);
            break;
          }
          case 101: {
            SizeMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (x_ == null) {
              x_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(x_);
            break;
          }
          case 117: {
            XMultiplier = input.ReadFloat();
            break;
          }
          case 122: {
            if (y_ == null) {
              y_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(y_);
            break;
          }
          case 133: {
            YMultiplier = input.ReadFloat();
            break;
          }
          case 138: {
            if (z_ == null) {
              z_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(z_);
            break;
          }
          case 149: {
            ZMultiplier = input.ReadFloat();
            break;
          }
          case 152: {
            SeparateAxes = input.ReadBool();
            break;
          }
          case 162: {
            if (range_ == null) {
              range_ = new global::ProtoMath.float2();
            }
            input.ReadMessage(range_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class SizeOverLifetimeModule : pb::IMessage<SizeOverLifetimeModule> {
    private static readonly pb::MessageParser<SizeOverLifetimeModule> _parser = new pb::MessageParser<SizeOverLifetimeModule>(() => new SizeOverLifetimeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SizeOverLifetimeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SizeOverLifetimeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SizeOverLifetimeModule(SizeOverLifetimeModule other) : this() {
      enabled_ = other.enabled_;
      Size = other.size_ != null ? other.Size.Clone() : null;
      sizeMultiplier_ = other.sizeMultiplier_;
      X = other.x_ != null ? other.X.Clone() : null;
      xMultiplier_ = other.xMultiplier_;
      Y = other.y_ != null ? other.Y.Clone() : null;
      yMultiplier_ = other.yMultiplier_;
      Z = other.z_ != null ? other.Z.Clone() : null;
      zMultiplier_ = other.zMultiplier_;
      separateAxes_ = other.separateAxes_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SizeOverLifetimeModule Clone() {
      return new SizeOverLifetimeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Size {
      get { return size_; }
      set {
        size_ = value;
      }
    }

    /// <summary>Field number for the "sizeMultiplier" field.</summary>
    public const int SizeMultiplierFieldNumber = 12;
    private float sizeMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SizeMultiplier {
      get { return sizeMultiplier_; }
      set {
        sizeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve x_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "xMultiplier" field.</summary>
    public const int XMultiplierFieldNumber = 14;
    private float xMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XMultiplier {
      get { return xMultiplier_; }
      set {
        xMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 15;
    private global::ProtoPs.MinMaxCurve y_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "yMultiplier" field.</summary>
    public const int YMultiplierFieldNumber = 16;
    private float yMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YMultiplier {
      get { return yMultiplier_; }
      set {
        yMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 17;
    private global::ProtoPs.MinMaxCurve z_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    /// <summary>Field number for the "zMultiplier" field.</summary>
    public const int ZMultiplierFieldNumber = 18;
    private float zMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ZMultiplier {
      get { return zMultiplier_; }
      set {
        zMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "separateAxes" field.</summary>
    public const int SeparateAxesFieldNumber = 19;
    private bool separateAxes_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SeparateAxes {
      get { return separateAxes_; }
      set {
        separateAxes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SizeOverLifetimeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SizeOverLifetimeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(Size, other.Size)) return false;
      if (SizeMultiplier != other.SizeMultiplier) return false;
      if (!object.Equals(X, other.X)) return false;
      if (XMultiplier != other.XMultiplier) return false;
      if (!object.Equals(Y, other.Y)) return false;
      if (YMultiplier != other.YMultiplier) return false;
      if (!object.Equals(Z, other.Z)) return false;
      if (ZMultiplier != other.ZMultiplier) return false;
      if (SeparateAxes != other.SeparateAxes) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (size_ != null) hash ^= Size.GetHashCode();
      if (SizeMultiplier != 0F) hash ^= SizeMultiplier.GetHashCode();
      if (x_ != null) hash ^= X.GetHashCode();
      if (XMultiplier != 0F) hash ^= XMultiplier.GetHashCode();
      if (y_ != null) hash ^= Y.GetHashCode();
      if (YMultiplier != 0F) hash ^= YMultiplier.GetHashCode();
      if (z_ != null) hash ^= Z.GetHashCode();
      if (ZMultiplier != 0F) hash ^= ZMultiplier.GetHashCode();
      if (SeparateAxes != false) hash ^= SeparateAxes.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (size_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Size);
      }
      if (SizeMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(SizeMultiplier);
      }
      if (x_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(X);
      }
      if (XMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(XMultiplier);
      }
      if (y_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Y);
      }
      if (YMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(YMultiplier);
      }
      if (z_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Z);
      }
      if (ZMultiplier != 0F) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(ZMultiplier);
      }
      if (SeparateAxes != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(SeparateAxes);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (size_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Size);
      }
      if (SizeMultiplier != 0F) {
        size += 1 + 4;
      }
      if (x_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X);
      }
      if (XMultiplier != 0F) {
        size += 1 + 4;
      }
      if (y_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Y);
      }
      if (YMultiplier != 0F) {
        size += 2 + 4;
      }
      if (z_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Z);
      }
      if (ZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (SeparateAxes != false) {
        size += 2 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SizeOverLifetimeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.size_ != null) {
        if (size_ == null) {
          size_ = new global::ProtoPs.MinMaxCurve();
        }
        Size.MergeFrom(other.Size);
      }
      if (other.SizeMultiplier != 0F) {
        SizeMultiplier = other.SizeMultiplier;
      }
      if (other.x_ != null) {
        if (x_ == null) {
          x_ = new global::ProtoPs.MinMaxCurve();
        }
        X.MergeFrom(other.X);
      }
      if (other.XMultiplier != 0F) {
        XMultiplier = other.XMultiplier;
      }
      if (other.y_ != null) {
        if (y_ == null) {
          y_ = new global::ProtoPs.MinMaxCurve();
        }
        Y.MergeFrom(other.Y);
      }
      if (other.YMultiplier != 0F) {
        YMultiplier = other.YMultiplier;
      }
      if (other.z_ != null) {
        if (z_ == null) {
          z_ = new global::ProtoPs.MinMaxCurve();
        }
        Z.MergeFrom(other.Z);
      }
      if (other.ZMultiplier != 0F) {
        ZMultiplier = other.ZMultiplier;
      }
      if (other.SeparateAxes != false) {
        SeparateAxes = other.SeparateAxes;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (size_ == null) {
              size_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(size_);
            break;
          }
          case 101: {
            SizeMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (x_ == null) {
              x_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(x_);
            break;
          }
          case 117: {
            XMultiplier = input.ReadFloat();
            break;
          }
          case 122: {
            if (y_ == null) {
              y_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(y_);
            break;
          }
          case 133: {
            YMultiplier = input.ReadFloat();
            break;
          }
          case 138: {
            if (z_ == null) {
              z_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(z_);
            break;
          }
          case 149: {
            ZMultiplier = input.ReadFloat();
            break;
          }
          case 152: {
            SeparateAxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class EmissionModule : pb::IMessage<EmissionModule> {
    private static readonly pb::MessageParser<EmissionModule> _parser = new pb::MessageParser<EmissionModule>(() => new EmissionModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EmissionModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EmissionModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EmissionModule(EmissionModule other) : this() {
      enabled_ = other.enabled_;
      RateOverTime = other.rateOverTime_ != null ? other.RateOverTime.Clone() : null;
      rateOverTimeMultiplier_ = other.rateOverTimeMultiplier_;
      RateOverDistance = other.rateOverDistance_ != null ? other.RateOverDistance.Clone() : null;
      rateOverDistanceMultiplier_ = other.rateOverDistanceMultiplier_;
      burstCount_ = other.burstCount_;
      bursts_ = other.bursts_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EmissionModule Clone() {
      return new EmissionModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "rateOverTime" field.</summary>
    public const int RateOverTimeFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve rateOverTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RateOverTime {
      get { return rateOverTime_; }
      set {
        rateOverTime_ = value;
      }
    }

    /// <summary>Field number for the "rateOverTimeMultiplier" field.</summary>
    public const int RateOverTimeMultiplierFieldNumber = 12;
    private float rateOverTimeMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RateOverTimeMultiplier {
      get { return rateOverTimeMultiplier_; }
      set {
        rateOverTimeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "rateOverDistance" field.</summary>
    public const int RateOverDistanceFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve rateOverDistance_;
    /// <summary>
    ///     The rate at which new particles are spawned, over distance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RateOverDistance {
      get { return rateOverDistance_; }
      set {
        rateOverDistance_ = value;
      }
    }

    /// <summary>Field number for the "rateOverDistanceMultiplier" field.</summary>
    public const int RateOverDistanceMultiplierFieldNumber = 14;
    private float rateOverDistanceMultiplier_;
    /// <summary>
    ///     Change the rate over distance multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RateOverDistanceMultiplier {
      get { return rateOverDistanceMultiplier_; }
      set {
        rateOverDistanceMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "burstCount" field.</summary>
    public const int BurstCountFieldNumber = 15;
    private int burstCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BurstCount {
      get { return burstCount_; }
      set {
        burstCount_ = value;
      }
    }

    /// <summary>Field number for the "bursts" field.</summary>
    public const int BurstsFieldNumber = 16;
    private static readonly pb::FieldCodec<global::ProtoPs.Burst> _repeated_bursts_codec
        = pb::FieldCodec.ForMessage(130, global::ProtoPs.Burst.Parser);
    private readonly pbc::RepeatedField<global::ProtoPs.Burst> bursts_ = new pbc::RepeatedField<global::ProtoPs.Burst>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ProtoPs.Burst> Bursts {
      get { return bursts_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EmissionModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EmissionModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(RateOverTime, other.RateOverTime)) return false;
      if (RateOverTimeMultiplier != other.RateOverTimeMultiplier) return false;
      if (!object.Equals(RateOverDistance, other.RateOverDistance)) return false;
      if (RateOverDistanceMultiplier != other.RateOverDistanceMultiplier) return false;
      if (BurstCount != other.BurstCount) return false;
      if(!bursts_.Equals(other.bursts_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (rateOverTime_ != null) hash ^= RateOverTime.GetHashCode();
      if (RateOverTimeMultiplier != 0F) hash ^= RateOverTimeMultiplier.GetHashCode();
      if (rateOverDistance_ != null) hash ^= RateOverDistance.GetHashCode();
      if (RateOverDistanceMultiplier != 0F) hash ^= RateOverDistanceMultiplier.GetHashCode();
      if (BurstCount != 0) hash ^= BurstCount.GetHashCode();
      hash ^= bursts_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (rateOverTime_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RateOverTime);
      }
      if (RateOverTimeMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(RateOverTimeMultiplier);
      }
      if (rateOverDistance_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(RateOverDistance);
      }
      if (RateOverDistanceMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(RateOverDistanceMultiplier);
      }
      if (BurstCount != 0) {
        output.WriteRawTag(120);
        output.WriteInt32(BurstCount);
      }
      bursts_.WriteTo(output, _repeated_bursts_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (rateOverTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateOverTime);
      }
      if (RateOverTimeMultiplier != 0F) {
        size += 1 + 4;
      }
      if (rateOverDistance_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateOverDistance);
      }
      if (RateOverDistanceMultiplier != 0F) {
        size += 1 + 4;
      }
      if (BurstCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BurstCount);
      }
      size += bursts_.CalculateSize(_repeated_bursts_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EmissionModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.rateOverTime_ != null) {
        if (rateOverTime_ == null) {
          rateOverTime_ = new global::ProtoPs.MinMaxCurve();
        }
        RateOverTime.MergeFrom(other.RateOverTime);
      }
      if (other.RateOverTimeMultiplier != 0F) {
        RateOverTimeMultiplier = other.RateOverTimeMultiplier;
      }
      if (other.rateOverDistance_ != null) {
        if (rateOverDistance_ == null) {
          rateOverDistance_ = new global::ProtoPs.MinMaxCurve();
        }
        RateOverDistance.MergeFrom(other.RateOverDistance);
      }
      if (other.RateOverDistanceMultiplier != 0F) {
        RateOverDistanceMultiplier = other.RateOverDistanceMultiplier;
      }
      if (other.BurstCount != 0) {
        BurstCount = other.BurstCount;
      }
      bursts_.Add(other.bursts_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (rateOverTime_ == null) {
              rateOverTime_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(rateOverTime_);
            break;
          }
          case 101: {
            RateOverTimeMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (rateOverDistance_ == null) {
              rateOverDistance_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(rateOverDistance_);
            break;
          }
          case 117: {
            RateOverDistanceMultiplier = input.ReadFloat();
            break;
          }
          case 120: {
            BurstCount = input.ReadInt32();
            break;
          }
          case 130: {
            bursts_.AddEntriesFrom(input, _repeated_bursts_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ColorOverLifetimeModule : pb::IMessage<ColorOverLifetimeModule> {
    private static readonly pb::MessageParser<ColorOverLifetimeModule> _parser = new pb::MessageParser<ColorOverLifetimeModule>(() => new ColorOverLifetimeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ColorOverLifetimeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColorOverLifetimeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColorOverLifetimeModule(ColorOverLifetimeModule other) : this() {
      enabled_ = other.enabled_;
      Color = other.color_ != null ? other.Color.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColorOverLifetimeModule Clone() {
      return new ColorOverLifetimeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "color" field.</summary>
    public const int ColorFieldNumber = 11;
    private global::ProtoPs.MinMaxGradient color_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxGradient Color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ColorOverLifetimeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ColorOverLifetimeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(Color, other.Color)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (color_ != null) hash ^= Color.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (color_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Color);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (color_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Color);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ColorOverLifetimeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.color_ != null) {
        if (color_ == null) {
          color_ = new global::ProtoPs.MinMaxGradient();
        }
        Color.MergeFrom(other.Color);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (color_ == null) {
              color_ = new global::ProtoPs.MinMaxGradient();
            }
            input.ReadMessage(color_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ForceOverLifetimeModule : pb::IMessage<ForceOverLifetimeModule> {
    private static readonly pb::MessageParser<ForceOverLifetimeModule> _parser = new pb::MessageParser<ForceOverLifetimeModule>(() => new ForceOverLifetimeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ForceOverLifetimeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ForceOverLifetimeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ForceOverLifetimeModule(ForceOverLifetimeModule other) : this() {
      enabled_ = other.enabled_;
      X = other.x_ != null ? other.X.Clone() : null;
      Y = other.y_ != null ? other.Y.Clone() : null;
      Z = other.z_ != null ? other.Z.Clone() : null;
      xMultiplier_ = other.xMultiplier_;
      yMultiplier_ = other.yMultiplier_;
      zMultiplier_ = other.zMultiplier_;
      space_ = other.space_;
      randomized_ = other.randomized_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ForceOverLifetimeModule Clone() {
      return new ForceOverLifetimeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve x_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 12;
    private global::ProtoPs.MinMaxCurve y_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve z_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    /// <summary>Field number for the "xMultiplier" field.</summary>
    public const int XMultiplierFieldNumber = 14;
    private float xMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XMultiplier {
      get { return xMultiplier_; }
      set {
        xMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "yMultiplier" field.</summary>
    public const int YMultiplierFieldNumber = 15;
    private float yMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YMultiplier {
      get { return yMultiplier_; }
      set {
        yMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "zMultiplier" field.</summary>
    public const int ZMultiplierFieldNumber = 16;
    private float zMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ZMultiplier {
      get { return zMultiplier_; }
      set {
        zMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "space" field.</summary>
    public const int SpaceFieldNumber = 17;
    private global::ProtoPs.ParticleSystemSimulationSpace space_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSimulationSpace Space {
      get { return space_; }
      set {
        space_ = value;
      }
    }

    /// <summary>Field number for the "randomized" field.</summary>
    public const int RandomizedFieldNumber = 18;
    private bool randomized_;
    /// <summary>
    ///When randomly selecting values between two curves or constants, this flag will cause a new random force to be chosen on each frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Randomized {
      get { return randomized_; }
      set {
        randomized_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ForceOverLifetimeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ForceOverLifetimeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(X, other.X)) return false;
      if (!object.Equals(Y, other.Y)) return false;
      if (!object.Equals(Z, other.Z)) return false;
      if (XMultiplier != other.XMultiplier) return false;
      if (YMultiplier != other.YMultiplier) return false;
      if (ZMultiplier != other.ZMultiplier) return false;
      if (Space != other.Space) return false;
      if (Randomized != other.Randomized) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (x_ != null) hash ^= X.GetHashCode();
      if (y_ != null) hash ^= Y.GetHashCode();
      if (z_ != null) hash ^= Z.GetHashCode();
      if (XMultiplier != 0F) hash ^= XMultiplier.GetHashCode();
      if (YMultiplier != 0F) hash ^= YMultiplier.GetHashCode();
      if (ZMultiplier != 0F) hash ^= ZMultiplier.GetHashCode();
      if (Space != 0) hash ^= Space.GetHashCode();
      if (Randomized != false) hash ^= Randomized.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (x_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(X);
      }
      if (y_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Y);
      }
      if (z_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Z);
      }
      if (XMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(XMultiplier);
      }
      if (YMultiplier != 0F) {
        output.WriteRawTag(125);
        output.WriteFloat(YMultiplier);
      }
      if (ZMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ZMultiplier);
      }
      if (Space != 0) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) Space);
      }
      if (Randomized != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Randomized);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (x_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X);
      }
      if (y_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Y);
      }
      if (z_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Z);
      }
      if (XMultiplier != 0F) {
        size += 1 + 4;
      }
      if (YMultiplier != 0F) {
        size += 1 + 4;
      }
      if (ZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (Space != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Space);
      }
      if (Randomized != false) {
        size += 2 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ForceOverLifetimeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.x_ != null) {
        if (x_ == null) {
          x_ = new global::ProtoPs.MinMaxCurve();
        }
        X.MergeFrom(other.X);
      }
      if (other.y_ != null) {
        if (y_ == null) {
          y_ = new global::ProtoPs.MinMaxCurve();
        }
        Y.MergeFrom(other.Y);
      }
      if (other.z_ != null) {
        if (z_ == null) {
          z_ = new global::ProtoPs.MinMaxCurve();
        }
        Z.MergeFrom(other.Z);
      }
      if (other.XMultiplier != 0F) {
        XMultiplier = other.XMultiplier;
      }
      if (other.YMultiplier != 0F) {
        YMultiplier = other.YMultiplier;
      }
      if (other.ZMultiplier != 0F) {
        ZMultiplier = other.ZMultiplier;
      }
      if (other.Space != 0) {
        Space = other.Space;
      }
      if (other.Randomized != false) {
        Randomized = other.Randomized;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (x_ == null) {
              x_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(x_);
            break;
          }
          case 98: {
            if (y_ == null) {
              y_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(y_);
            break;
          }
          case 106: {
            if (z_ == null) {
              z_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(z_);
            break;
          }
          case 117: {
            XMultiplier = input.ReadFloat();
            break;
          }
          case 125: {
            YMultiplier = input.ReadFloat();
            break;
          }
          case 133: {
            ZMultiplier = input.ReadFloat();
            break;
          }
          case 136: {
            space_ = (global::ProtoPs.ParticleSystemSimulationSpace) input.ReadEnum();
            break;
          }
          case 144: {
            Randomized = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///     The Inherit Velocity Module controls how the velocity of the emitter is transferred to the particles as they are emitted.
  /// </summary>
  public sealed partial class InheritVelocityModule : pb::IMessage<InheritVelocityModule> {
    private static readonly pb::MessageParser<InheritVelocityModule> _parser = new pb::MessageParser<InheritVelocityModule>(() => new InheritVelocityModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InheritVelocityModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InheritVelocityModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InheritVelocityModule(InheritVelocityModule other) : this() {
      enabled_ = other.enabled_;
      mode_ = other.mode_;
      Curve = other.curve_ != null ? other.Curve.Clone() : null;
      curveMultiplier_ = other.curveMultiplier_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InheritVelocityModule Clone() {
      return new InheritVelocityModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 11;
    private global::ProtoPs.ParticleSystemInheritVelocityMode mode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemInheritVelocityMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    /// <summary>Field number for the "curve" field.</summary>
    public const int CurveFieldNumber = 12;
    private global::ProtoPs.MinMaxCurve curve_;
    /// <summary>
    ///     Curve to define how much emitter velocity is applied during the lifetime of a particle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Curve {
      get { return curve_; }
      set {
        curve_ = value;
      }
    }

    /// <summary>Field number for the "curveMultiplier" field.</summary>
    public const int CurveMultiplierFieldNumber = 13;
    private float curveMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float CurveMultiplier {
      get { return curveMultiplier_; }
      set {
        curveMultiplier_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InheritVelocityModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InheritVelocityModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (Mode != other.Mode) return false;
      if (!object.Equals(Curve, other.Curve)) return false;
      if (CurveMultiplier != other.CurveMultiplier) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (curve_ != null) hash ^= Curve.GetHashCode();
      if (CurveMultiplier != 0F) hash ^= CurveMultiplier.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (Mode != 0) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Mode);
      }
      if (curve_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Curve);
      }
      if (CurveMultiplier != 0F) {
        output.WriteRawTag(109);
        output.WriteFloat(CurveMultiplier);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (Mode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (curve_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Curve);
      }
      if (CurveMultiplier != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InheritVelocityModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      if (other.curve_ != null) {
        if (curve_ == null) {
          curve_ = new global::ProtoPs.MinMaxCurve();
        }
        Curve.MergeFrom(other.Curve);
      }
      if (other.CurveMultiplier != 0F) {
        CurveMultiplier = other.CurveMultiplier;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 88: {
            mode_ = (global::ProtoPs.ParticleSystemInheritVelocityMode) input.ReadEnum();
            break;
          }
          case 98: {
            if (curve_ == null) {
              curve_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(curve_);
            break;
          }
          case 109: {
            CurveMultiplier = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class LimitVelocityOverLifetimeModule : pb::IMessage<LimitVelocityOverLifetimeModule> {
    private static readonly pb::MessageParser<LimitVelocityOverLifetimeModule> _parser = new pb::MessageParser<LimitVelocityOverLifetimeModule>(() => new LimitVelocityOverLifetimeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LimitVelocityOverLifetimeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LimitVelocityOverLifetimeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LimitVelocityOverLifetimeModule(LimitVelocityOverLifetimeModule other) : this() {
      enabled_ = other.enabled_;
      LimitX = other.limitX_ != null ? other.LimitX.Clone() : null;
      limitXMultiplier_ = other.limitXMultiplier_;
      LimitY = other.limitY_ != null ? other.LimitY.Clone() : null;
      limitYMultiplier_ = other.limitYMultiplier_;
      LimitZ = other.limitZ_ != null ? other.LimitZ.Clone() : null;
      limitZMultiplier_ = other.limitZMultiplier_;
      Limit = other.limit_ != null ? other.Limit.Clone() : null;
      limitMultiplier_ = other.limitMultiplier_;
      dampen_ = other.dampen_;
      separateAxes_ = other.separateAxes_;
      space_ = other.space_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LimitVelocityOverLifetimeModule Clone() {
      return new LimitVelocityOverLifetimeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "limitX" field.</summary>
    public const int LimitXFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve limitX_;
    /// <summary>
    ///     Maximum velocity curve for the X axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve LimitX {
      get { return limitX_; }
      set {
        limitX_ = value;
      }
    }

    /// <summary>Field number for the "limitXMultiplier" field.</summary>
    public const int LimitXMultiplierFieldNumber = 12;
    private float limitXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LimitXMultiplier {
      get { return limitXMultiplier_; }
      set {
        limitXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "limitY" field.</summary>
    public const int LimitYFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve limitY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve LimitY {
      get { return limitY_; }
      set {
        limitY_ = value;
      }
    }

    /// <summary>Field number for the "limitYMultiplier" field.</summary>
    public const int LimitYMultiplierFieldNumber = 14;
    private float limitYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LimitYMultiplier {
      get { return limitYMultiplier_; }
      set {
        limitYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "limitZ" field.</summary>
    public const int LimitZFieldNumber = 15;
    private global::ProtoPs.MinMaxCurve limitZ_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve LimitZ {
      get { return limitZ_; }
      set {
        limitZ_ = value;
      }
    }

    /// <summary>Field number for the "limitZMultiplier" field.</summary>
    public const int LimitZMultiplierFieldNumber = 16;
    private float limitZMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LimitZMultiplier {
      get { return limitZMultiplier_; }
      set {
        limitZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "limit" field.</summary>
    public const int LimitFieldNumber = 17;
    private global::ProtoPs.MinMaxCurve limit_;
    /// <summary>
    ///     Maximum velocity curve, when not using one curve per axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Limit {
      get { return limit_; }
      set {
        limit_ = value;
      }
    }

    /// <summary>Field number for the "limitMultiplier" field.</summary>
    public const int LimitMultiplierFieldNumber = 18;
    private float limitMultiplier_;
    /// <summary>
    ///     Change the limit multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LimitMultiplier {
      get { return limitMultiplier_; }
      set {
        limitMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "dampen" field.</summary>
    public const int DampenFieldNumber = 19;
    private float dampen_;
    /// <summary>
    ///     Controls how much the velocity that exceeds the velocity limit should be dampened.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Dampen {
      get { return dampen_; }
      set {
        dampen_ = value;
      }
    }

    /// <summary>Field number for the "separateAxes" field.</summary>
    public const int SeparateAxesFieldNumber = 20;
    private bool separateAxes_;
    /// <summary>
    ///     Set the velocity limit on each axis separately.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SeparateAxes {
      get { return separateAxes_; }
      set {
        separateAxes_ = value;
      }
    }

    /// <summary>Field number for the "space" field.</summary>
    public const int SpaceFieldNumber = 21;
    private global::ProtoPs.ParticleSystemSimulationSpace space_ = 0;
    /// <summary>
    ///     Specifies if the velocity limits are in local space (rotated with the transform) or world space.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSimulationSpace Space {
      get { return space_; }
      set {
        space_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LimitVelocityOverLifetimeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LimitVelocityOverLifetimeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(LimitX, other.LimitX)) return false;
      if (LimitXMultiplier != other.LimitXMultiplier) return false;
      if (!object.Equals(LimitY, other.LimitY)) return false;
      if (LimitYMultiplier != other.LimitYMultiplier) return false;
      if (!object.Equals(LimitZ, other.LimitZ)) return false;
      if (LimitZMultiplier != other.LimitZMultiplier) return false;
      if (!object.Equals(Limit, other.Limit)) return false;
      if (LimitMultiplier != other.LimitMultiplier) return false;
      if (Dampen != other.Dampen) return false;
      if (SeparateAxes != other.SeparateAxes) return false;
      if (Space != other.Space) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (limitX_ != null) hash ^= LimitX.GetHashCode();
      if (LimitXMultiplier != 0F) hash ^= LimitXMultiplier.GetHashCode();
      if (limitY_ != null) hash ^= LimitY.GetHashCode();
      if (LimitYMultiplier != 0F) hash ^= LimitYMultiplier.GetHashCode();
      if (limitZ_ != null) hash ^= LimitZ.GetHashCode();
      if (LimitZMultiplier != 0F) hash ^= LimitZMultiplier.GetHashCode();
      if (limit_ != null) hash ^= Limit.GetHashCode();
      if (LimitMultiplier != 0F) hash ^= LimitMultiplier.GetHashCode();
      if (Dampen != 0F) hash ^= Dampen.GetHashCode();
      if (SeparateAxes != false) hash ^= SeparateAxes.GetHashCode();
      if (Space != 0) hash ^= Space.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (limitX_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(LimitX);
      }
      if (LimitXMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(LimitXMultiplier);
      }
      if (limitY_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(LimitY);
      }
      if (LimitYMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(LimitYMultiplier);
      }
      if (limitZ_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(LimitZ);
      }
      if (LimitZMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(LimitZMultiplier);
      }
      if (limit_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Limit);
      }
      if (LimitMultiplier != 0F) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(LimitMultiplier);
      }
      if (Dampen != 0F) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(Dampen);
      }
      if (SeparateAxes != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(SeparateAxes);
      }
      if (Space != 0) {
        output.WriteRawTag(168, 1);
        output.WriteEnum((int) Space);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (limitX_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LimitX);
      }
      if (LimitXMultiplier != 0F) {
        size += 1 + 4;
      }
      if (limitY_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LimitY);
      }
      if (LimitYMultiplier != 0F) {
        size += 1 + 4;
      }
      if (limitZ_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LimitZ);
      }
      if (LimitZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (limit_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Limit);
      }
      if (LimitMultiplier != 0F) {
        size += 2 + 4;
      }
      if (Dampen != 0F) {
        size += 2 + 4;
      }
      if (SeparateAxes != false) {
        size += 2 + 1;
      }
      if (Space != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Space);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LimitVelocityOverLifetimeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.limitX_ != null) {
        if (limitX_ == null) {
          limitX_ = new global::ProtoPs.MinMaxCurve();
        }
        LimitX.MergeFrom(other.LimitX);
      }
      if (other.LimitXMultiplier != 0F) {
        LimitXMultiplier = other.LimitXMultiplier;
      }
      if (other.limitY_ != null) {
        if (limitY_ == null) {
          limitY_ = new global::ProtoPs.MinMaxCurve();
        }
        LimitY.MergeFrom(other.LimitY);
      }
      if (other.LimitYMultiplier != 0F) {
        LimitYMultiplier = other.LimitYMultiplier;
      }
      if (other.limitZ_ != null) {
        if (limitZ_ == null) {
          limitZ_ = new global::ProtoPs.MinMaxCurve();
        }
        LimitZ.MergeFrom(other.LimitZ);
      }
      if (other.LimitZMultiplier != 0F) {
        LimitZMultiplier = other.LimitZMultiplier;
      }
      if (other.limit_ != null) {
        if (limit_ == null) {
          limit_ = new global::ProtoPs.MinMaxCurve();
        }
        Limit.MergeFrom(other.Limit);
      }
      if (other.LimitMultiplier != 0F) {
        LimitMultiplier = other.LimitMultiplier;
      }
      if (other.Dampen != 0F) {
        Dampen = other.Dampen;
      }
      if (other.SeparateAxes != false) {
        SeparateAxes = other.SeparateAxes;
      }
      if (other.Space != 0) {
        Space = other.Space;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (limitX_ == null) {
              limitX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(limitX_);
            break;
          }
          case 101: {
            LimitXMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (limitY_ == null) {
              limitY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(limitY_);
            break;
          }
          case 117: {
            LimitYMultiplier = input.ReadFloat();
            break;
          }
          case 122: {
            if (limitZ_ == null) {
              limitZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(limitZ_);
            break;
          }
          case 133: {
            LimitZMultiplier = input.ReadFloat();
            break;
          }
          case 138: {
            if (limit_ == null) {
              limit_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(limit_);
            break;
          }
          case 149: {
            LimitMultiplier = input.ReadFloat();
            break;
          }
          case 157: {
            Dampen = input.ReadFloat();
            break;
          }
          case 160: {
            SeparateAxes = input.ReadBool();
            break;
          }
          case 168: {
            space_ = (global::ProtoPs.ParticleSystemSimulationSpace) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class VelocityOverLifetimeModule : pb::IMessage<VelocityOverLifetimeModule> {
    private static readonly pb::MessageParser<VelocityOverLifetimeModule> _parser = new pb::MessageParser<VelocityOverLifetimeModule>(() => new VelocityOverLifetimeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VelocityOverLifetimeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VelocityOverLifetimeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VelocityOverLifetimeModule(VelocityOverLifetimeModule other) : this() {
      enabled_ = other.enabled_;
      X = other.x_ != null ? other.X.Clone() : null;
      Y = other.y_ != null ? other.Y.Clone() : null;
      Z = other.z_ != null ? other.Z.Clone() : null;
      xMultiplier_ = other.xMultiplier_;
      yMultiplier_ = other.yMultiplier_;
      zMultiplier_ = other.zMultiplier_;
      space_ = other.space_;
      OrbitalX = other.orbitalX_ != null ? other.OrbitalX.Clone() : null;
      orbitalXMultiplier_ = other.orbitalXMultiplier_;
      OrbitalY = other.orbitalY_ != null ? other.OrbitalY.Clone() : null;
      orbitalYMultiplier_ = other.orbitalYMultiplier_;
      OrbitalZ = other.orbitalZ_ != null ? other.OrbitalZ.Clone() : null;
      orbitalZMultiplier_ = other.orbitalZMultiplier_;
      OffsetX = other.offsetX_ != null ? other.OffsetX.Clone() : null;
      offsetXMultiplier_ = other.offsetXMultiplier_;
      OffsetY = other.offsetY_ != null ? other.OffsetY.Clone() : null;
      offsetYMultiplier_ = other.offsetYMultiplier_;
      OffsetZ = other.offsetZ_ != null ? other.OffsetZ.Clone() : null;
      offsetZMultiplier_ = other.offsetZMultiplier_;
      Radial = other.radial_ != null ? other.Radial.Clone() : null;
      radialMultiplier_ = other.radialMultiplier_;
      Speed = other.speed_ != null ? other.Speed.Clone() : null;
      speedMultiplier_ = other.speedMultiplier_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VelocityOverLifetimeModule Clone() {
      return new VelocityOverLifetimeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 10;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 11;
    private global::ProtoPs.MinMaxCurve x_;
    /// <summary>
    ///     Curve to control particle speed based on lifetime, on the X axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 12;
    private global::ProtoPs.MinMaxCurve y_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve z_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    /// <summary>Field number for the "xMultiplier" field.</summary>
    public const int XMultiplierFieldNumber = 14;
    private float xMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XMultiplier {
      get { return xMultiplier_; }
      set {
        xMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "yMultiplier" field.</summary>
    public const int YMultiplierFieldNumber = 15;
    private float yMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YMultiplier {
      get { return yMultiplier_; }
      set {
        yMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "zMultiplier" field.</summary>
    public const int ZMultiplierFieldNumber = 16;
    private float zMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ZMultiplier {
      get { return zMultiplier_; }
      set {
        zMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "space" field.</summary>
    public const int SpaceFieldNumber = 17;
    private global::ProtoPs.ParticleSystemSimulationSpace space_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSimulationSpace Space {
      get { return space_; }
      set {
        space_ = value;
      }
    }

    /// <summary>Field number for the "orbitalX" field.</summary>
    public const int OrbitalXFieldNumber = 21;
    private global::ProtoPs.MinMaxCurve orbitalX_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve OrbitalX {
      get { return orbitalX_; }
      set {
        orbitalX_ = value;
      }
    }

    /// <summary>Field number for the "orbitalXMultiplier" field.</summary>
    public const int OrbitalXMultiplierFieldNumber = 22;
    private float orbitalXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OrbitalXMultiplier {
      get { return orbitalXMultiplier_; }
      set {
        orbitalXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "orbitalY" field.</summary>
    public const int OrbitalYFieldNumber = 23;
    private global::ProtoPs.MinMaxCurve orbitalY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve OrbitalY {
      get { return orbitalY_; }
      set {
        orbitalY_ = value;
      }
    }

    /// <summary>Field number for the "orbitalYMultiplier" field.</summary>
    public const int OrbitalYMultiplierFieldNumber = 24;
    private float orbitalYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OrbitalYMultiplier {
      get { return orbitalYMultiplier_; }
      set {
        orbitalYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "orbitalZ" field.</summary>
    public const int OrbitalZFieldNumber = 25;
    private global::ProtoPs.MinMaxCurve orbitalZ_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve OrbitalZ {
      get { return orbitalZ_; }
      set {
        orbitalZ_ = value;
      }
    }

    /// <summary>Field number for the "orbitalZMultiplier" field.</summary>
    public const int OrbitalZMultiplierFieldNumber = 26;
    private float orbitalZMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OrbitalZMultiplier {
      get { return orbitalZMultiplier_; }
      set {
        orbitalZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "offsetX" field.</summary>
    public const int OffsetXFieldNumber = 31;
    private global::ProtoPs.MinMaxCurve offsetX_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve OffsetX {
      get { return offsetX_; }
      set {
        offsetX_ = value;
      }
    }

    /// <summary>Field number for the "offsetXMultiplier" field.</summary>
    public const int OffsetXMultiplierFieldNumber = 32;
    private float offsetXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OffsetXMultiplier {
      get { return offsetXMultiplier_; }
      set {
        offsetXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "offsetY" field.</summary>
    public const int OffsetYFieldNumber = 33;
    private global::ProtoPs.MinMaxCurve offsetY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve OffsetY {
      get { return offsetY_; }
      set {
        offsetY_ = value;
      }
    }

    /// <summary>Field number for the "offsetYMultiplier" field.</summary>
    public const int OffsetYMultiplierFieldNumber = 34;
    private float offsetYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OffsetYMultiplier {
      get { return offsetYMultiplier_; }
      set {
        offsetYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "offsetZ" field.</summary>
    public const int OffsetZFieldNumber = 35;
    private global::ProtoPs.MinMaxCurve offsetZ_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve OffsetZ {
      get { return offsetZ_; }
      set {
        offsetZ_ = value;
      }
    }

    /// <summary>Field number for the "offsetZMultiplier" field.</summary>
    public const int OffsetZMultiplierFieldNumber = 36;
    private float offsetZMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OffsetZMultiplier {
      get { return offsetZMultiplier_; }
      set {
        offsetZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "radial" field.</summary>
    public const int RadialFieldNumber = 401;
    private global::ProtoPs.MinMaxCurve radial_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Radial {
      get { return radial_; }
      set {
        radial_ = value;
      }
    }

    /// <summary>Field number for the "radialMultiplier" field.</summary>
    public const int RadialMultiplierFieldNumber = 402;
    private float radialMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RadialMultiplier {
      get { return radialMultiplier_; }
      set {
        radialMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "speed" field.</summary>
    public const int SpeedFieldNumber = 501;
    private global::ProtoPs.MinMaxCurve speed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Speed {
      get { return speed_; }
      set {
        speed_ = value;
      }
    }

    /// <summary>Field number for the "speedMultiplier" field.</summary>
    public const int SpeedMultiplierFieldNumber = 502;
    private float speedMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SpeedMultiplier {
      get { return speedMultiplier_; }
      set {
        speedMultiplier_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VelocityOverLifetimeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VelocityOverLifetimeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(X, other.X)) return false;
      if (!object.Equals(Y, other.Y)) return false;
      if (!object.Equals(Z, other.Z)) return false;
      if (XMultiplier != other.XMultiplier) return false;
      if (YMultiplier != other.YMultiplier) return false;
      if (ZMultiplier != other.ZMultiplier) return false;
      if (Space != other.Space) return false;
      if (!object.Equals(OrbitalX, other.OrbitalX)) return false;
      if (OrbitalXMultiplier != other.OrbitalXMultiplier) return false;
      if (!object.Equals(OrbitalY, other.OrbitalY)) return false;
      if (OrbitalYMultiplier != other.OrbitalYMultiplier) return false;
      if (!object.Equals(OrbitalZ, other.OrbitalZ)) return false;
      if (OrbitalZMultiplier != other.OrbitalZMultiplier) return false;
      if (!object.Equals(OffsetX, other.OffsetX)) return false;
      if (OffsetXMultiplier != other.OffsetXMultiplier) return false;
      if (!object.Equals(OffsetY, other.OffsetY)) return false;
      if (OffsetYMultiplier != other.OffsetYMultiplier) return false;
      if (!object.Equals(OffsetZ, other.OffsetZ)) return false;
      if (OffsetZMultiplier != other.OffsetZMultiplier) return false;
      if (!object.Equals(Radial, other.Radial)) return false;
      if (RadialMultiplier != other.RadialMultiplier) return false;
      if (!object.Equals(Speed, other.Speed)) return false;
      if (SpeedMultiplier != other.SpeedMultiplier) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (x_ != null) hash ^= X.GetHashCode();
      if (y_ != null) hash ^= Y.GetHashCode();
      if (z_ != null) hash ^= Z.GetHashCode();
      if (XMultiplier != 0F) hash ^= XMultiplier.GetHashCode();
      if (YMultiplier != 0F) hash ^= YMultiplier.GetHashCode();
      if (ZMultiplier != 0F) hash ^= ZMultiplier.GetHashCode();
      if (Space != 0) hash ^= Space.GetHashCode();
      if (orbitalX_ != null) hash ^= OrbitalX.GetHashCode();
      if (OrbitalXMultiplier != 0F) hash ^= OrbitalXMultiplier.GetHashCode();
      if (orbitalY_ != null) hash ^= OrbitalY.GetHashCode();
      if (OrbitalYMultiplier != 0F) hash ^= OrbitalYMultiplier.GetHashCode();
      if (orbitalZ_ != null) hash ^= OrbitalZ.GetHashCode();
      if (OrbitalZMultiplier != 0F) hash ^= OrbitalZMultiplier.GetHashCode();
      if (offsetX_ != null) hash ^= OffsetX.GetHashCode();
      if (OffsetXMultiplier != 0F) hash ^= OffsetXMultiplier.GetHashCode();
      if (offsetY_ != null) hash ^= OffsetY.GetHashCode();
      if (OffsetYMultiplier != 0F) hash ^= OffsetYMultiplier.GetHashCode();
      if (offsetZ_ != null) hash ^= OffsetZ.GetHashCode();
      if (OffsetZMultiplier != 0F) hash ^= OffsetZMultiplier.GetHashCode();
      if (radial_ != null) hash ^= Radial.GetHashCode();
      if (RadialMultiplier != 0F) hash ^= RadialMultiplier.GetHashCode();
      if (speed_ != null) hash ^= Speed.GetHashCode();
      if (SpeedMultiplier != 0F) hash ^= SpeedMultiplier.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(80);
        output.WriteBool(Enabled);
      }
      if (x_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(X);
      }
      if (y_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Y);
      }
      if (z_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Z);
      }
      if (XMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(XMultiplier);
      }
      if (YMultiplier != 0F) {
        output.WriteRawTag(125);
        output.WriteFloat(YMultiplier);
      }
      if (ZMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ZMultiplier);
      }
      if (Space != 0) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) Space);
      }
      if (orbitalX_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(OrbitalX);
      }
      if (OrbitalXMultiplier != 0F) {
        output.WriteRawTag(181, 1);
        output.WriteFloat(OrbitalXMultiplier);
      }
      if (orbitalY_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(OrbitalY);
      }
      if (OrbitalYMultiplier != 0F) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(OrbitalYMultiplier);
      }
      if (orbitalZ_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(OrbitalZ);
      }
      if (OrbitalZMultiplier != 0F) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(OrbitalZMultiplier);
      }
      if (offsetX_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(OffsetX);
      }
      if (OffsetXMultiplier != 0F) {
        output.WriteRawTag(133, 2);
        output.WriteFloat(OffsetXMultiplier);
      }
      if (offsetY_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(OffsetY);
      }
      if (OffsetYMultiplier != 0F) {
        output.WriteRawTag(149, 2);
        output.WriteFloat(OffsetYMultiplier);
      }
      if (offsetZ_ != null) {
        output.WriteRawTag(154, 2);
        output.WriteMessage(OffsetZ);
      }
      if (OffsetZMultiplier != 0F) {
        output.WriteRawTag(165, 2);
        output.WriteFloat(OffsetZMultiplier);
      }
      if (radial_ != null) {
        output.WriteRawTag(138, 25);
        output.WriteMessage(Radial);
      }
      if (RadialMultiplier != 0F) {
        output.WriteRawTag(149, 25);
        output.WriteFloat(RadialMultiplier);
      }
      if (speed_ != null) {
        output.WriteRawTag(170, 31);
        output.WriteMessage(Speed);
      }
      if (SpeedMultiplier != 0F) {
        output.WriteRawTag(181, 31);
        output.WriteFloat(SpeedMultiplier);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (x_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X);
      }
      if (y_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Y);
      }
      if (z_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Z);
      }
      if (XMultiplier != 0F) {
        size += 1 + 4;
      }
      if (YMultiplier != 0F) {
        size += 1 + 4;
      }
      if (ZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (Space != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Space);
      }
      if (orbitalX_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OrbitalX);
      }
      if (OrbitalXMultiplier != 0F) {
        size += 2 + 4;
      }
      if (orbitalY_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OrbitalY);
      }
      if (OrbitalYMultiplier != 0F) {
        size += 2 + 4;
      }
      if (orbitalZ_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OrbitalZ);
      }
      if (OrbitalZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (offsetX_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OffsetX);
      }
      if (OffsetXMultiplier != 0F) {
        size += 2 + 4;
      }
      if (offsetY_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OffsetY);
      }
      if (OffsetYMultiplier != 0F) {
        size += 2 + 4;
      }
      if (offsetZ_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OffsetZ);
      }
      if (OffsetZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (radial_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Radial);
      }
      if (RadialMultiplier != 0F) {
        size += 2 + 4;
      }
      if (speed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Speed);
      }
      if (SpeedMultiplier != 0F) {
        size += 2 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VelocityOverLifetimeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.x_ != null) {
        if (x_ == null) {
          x_ = new global::ProtoPs.MinMaxCurve();
        }
        X.MergeFrom(other.X);
      }
      if (other.y_ != null) {
        if (y_ == null) {
          y_ = new global::ProtoPs.MinMaxCurve();
        }
        Y.MergeFrom(other.Y);
      }
      if (other.z_ != null) {
        if (z_ == null) {
          z_ = new global::ProtoPs.MinMaxCurve();
        }
        Z.MergeFrom(other.Z);
      }
      if (other.XMultiplier != 0F) {
        XMultiplier = other.XMultiplier;
      }
      if (other.YMultiplier != 0F) {
        YMultiplier = other.YMultiplier;
      }
      if (other.ZMultiplier != 0F) {
        ZMultiplier = other.ZMultiplier;
      }
      if (other.Space != 0) {
        Space = other.Space;
      }
      if (other.orbitalX_ != null) {
        if (orbitalX_ == null) {
          orbitalX_ = new global::ProtoPs.MinMaxCurve();
        }
        OrbitalX.MergeFrom(other.OrbitalX);
      }
      if (other.OrbitalXMultiplier != 0F) {
        OrbitalXMultiplier = other.OrbitalXMultiplier;
      }
      if (other.orbitalY_ != null) {
        if (orbitalY_ == null) {
          orbitalY_ = new global::ProtoPs.MinMaxCurve();
        }
        OrbitalY.MergeFrom(other.OrbitalY);
      }
      if (other.OrbitalYMultiplier != 0F) {
        OrbitalYMultiplier = other.OrbitalYMultiplier;
      }
      if (other.orbitalZ_ != null) {
        if (orbitalZ_ == null) {
          orbitalZ_ = new global::ProtoPs.MinMaxCurve();
        }
        OrbitalZ.MergeFrom(other.OrbitalZ);
      }
      if (other.OrbitalZMultiplier != 0F) {
        OrbitalZMultiplier = other.OrbitalZMultiplier;
      }
      if (other.offsetX_ != null) {
        if (offsetX_ == null) {
          offsetX_ = new global::ProtoPs.MinMaxCurve();
        }
        OffsetX.MergeFrom(other.OffsetX);
      }
      if (other.OffsetXMultiplier != 0F) {
        OffsetXMultiplier = other.OffsetXMultiplier;
      }
      if (other.offsetY_ != null) {
        if (offsetY_ == null) {
          offsetY_ = new global::ProtoPs.MinMaxCurve();
        }
        OffsetY.MergeFrom(other.OffsetY);
      }
      if (other.OffsetYMultiplier != 0F) {
        OffsetYMultiplier = other.OffsetYMultiplier;
      }
      if (other.offsetZ_ != null) {
        if (offsetZ_ == null) {
          offsetZ_ = new global::ProtoPs.MinMaxCurve();
        }
        OffsetZ.MergeFrom(other.OffsetZ);
      }
      if (other.OffsetZMultiplier != 0F) {
        OffsetZMultiplier = other.OffsetZMultiplier;
      }
      if (other.radial_ != null) {
        if (radial_ == null) {
          radial_ = new global::ProtoPs.MinMaxCurve();
        }
        Radial.MergeFrom(other.Radial);
      }
      if (other.RadialMultiplier != 0F) {
        RadialMultiplier = other.RadialMultiplier;
      }
      if (other.speed_ != null) {
        if (speed_ == null) {
          speed_ = new global::ProtoPs.MinMaxCurve();
        }
        Speed.MergeFrom(other.Speed);
      }
      if (other.SpeedMultiplier != 0F) {
        SpeedMultiplier = other.SpeedMultiplier;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            Enabled = input.ReadBool();
            break;
          }
          case 90: {
            if (x_ == null) {
              x_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(x_);
            break;
          }
          case 98: {
            if (y_ == null) {
              y_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(y_);
            break;
          }
          case 106: {
            if (z_ == null) {
              z_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(z_);
            break;
          }
          case 117: {
            XMultiplier = input.ReadFloat();
            break;
          }
          case 125: {
            YMultiplier = input.ReadFloat();
            break;
          }
          case 133: {
            ZMultiplier = input.ReadFloat();
            break;
          }
          case 136: {
            space_ = (global::ProtoPs.ParticleSystemSimulationSpace) input.ReadEnum();
            break;
          }
          case 170: {
            if (orbitalX_ == null) {
              orbitalX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(orbitalX_);
            break;
          }
          case 181: {
            OrbitalXMultiplier = input.ReadFloat();
            break;
          }
          case 186: {
            if (orbitalY_ == null) {
              orbitalY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(orbitalY_);
            break;
          }
          case 197: {
            OrbitalYMultiplier = input.ReadFloat();
            break;
          }
          case 202: {
            if (orbitalZ_ == null) {
              orbitalZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(orbitalZ_);
            break;
          }
          case 213: {
            OrbitalZMultiplier = input.ReadFloat();
            break;
          }
          case 250: {
            if (offsetX_ == null) {
              offsetX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(offsetX_);
            break;
          }
          case 261: {
            OffsetXMultiplier = input.ReadFloat();
            break;
          }
          case 266: {
            if (offsetY_ == null) {
              offsetY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(offsetY_);
            break;
          }
          case 277: {
            OffsetYMultiplier = input.ReadFloat();
            break;
          }
          case 282: {
            if (offsetZ_ == null) {
              offsetZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(offsetZ_);
            break;
          }
          case 293: {
            OffsetZMultiplier = input.ReadFloat();
            break;
          }
          case 3210: {
            if (radial_ == null) {
              radial_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(radial_);
            break;
          }
          case 3221: {
            RadialMultiplier = input.ReadFloat();
            break;
          }
          case 4010: {
            if (speed_ == null) {
              speed_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(speed_);
            break;
          }
          case 4021: {
            SpeedMultiplier = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ShapeModule : pb::IMessage<ShapeModule> {
    private static readonly pb::MessageParser<ShapeModule> _parser = new pb::MessageParser<ShapeModule>(() => new ShapeModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ShapeModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ShapeModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ShapeModule(ShapeModule other) : this() {
      enabled_ = other.enabled_;
      useMeshMaterialIndex_ = other.useMeshMaterialIndex_;
      meshMaterialIndex_ = other.meshMaterialIndex_;
      useMeshColors_ = other.useMeshColors_;
      normalOffset_ = other.normalOffset_;
      arc_ = other.arc_;
      arcSpread_ = other.arcSpread_;
      ArcSpeed = other.arcSpeed_ != null ? other.ArcSpeed.Clone() : null;
      arcSpeedMultiplier_ = other.arcSpeedMultiplier_;
      donutRadius_ = other.donutRadius_;
      Position = other.position_ != null ? other.Position.Clone() : null;
      Rotation = other.rotation_ != null ? other.Rotation.Clone() : null;
      Scale = other.scale_ != null ? other.Scale.Clone() : null;
      BoxThickness = other.boxThickness_ != null ? other.BoxThickness.Clone() : null;
      shapeType_ = other.shapeType_;
      randomDirectionAmount_ = other.randomDirectionAmount_;
      sphericalDirectionAmount_ = other.sphericalDirectionAmount_;
      randomPositionAmount_ = other.randomPositionAmount_;
      alignToDirection_ = other.alignToDirection_;
      radius_ = other.radius_;
      RadiusSpeed = other.radiusSpeed_ != null ? other.RadiusSpeed.Clone() : null;
      radiusSpeedMultiplier_ = other.radiusSpeedMultiplier_;
      radiusThickness_ = other.radiusThickness_;
      angle_ = other.angle_;
      length_ = other.length_;
      radiusSpread_ = other.radiusSpread_;
      meshShapeType_ = other.meshShapeType_;
      meshRendererName_ = other.meshRendererName_;
      meshName_ = other.meshName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ShapeModule Clone() {
      return new ShapeModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 100;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "useMeshMaterialIndex" field.</summary>
    public const int UseMeshMaterialIndexFieldNumber = 102;
    private bool useMeshMaterialIndex_;
    /// <summary>
    ///     Emit from a single material, or the whole mesh.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseMeshMaterialIndex {
      get { return useMeshMaterialIndex_; }
      set {
        useMeshMaterialIndex_ = value;
      }
    }

    /// <summary>Field number for the "meshMaterialIndex" field.</summary>
    public const int MeshMaterialIndexFieldNumber = 103;
    private int meshMaterialIndex_;
    /// <summary>
    ///     Emit particles from a single material of a mesh.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MeshMaterialIndex {
      get { return meshMaterialIndex_; }
      set {
        meshMaterialIndex_ = value;
      }
    }

    /// <summary>Field number for the "useMeshColors" field.</summary>
    public const int UseMeshColorsFieldNumber = 104;
    private bool useMeshColors_;
    /// <summary>
    ///     Modulate the particle colors with the vertex colors, or the material color if
    ///     no vertex colors exist.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseMeshColors {
      get { return useMeshColors_; }
      set {
        useMeshColors_ = value;
      }
    }

    /// <summary>Field number for the "normalOffset" field.</summary>
    public const int NormalOffsetFieldNumber = 105;
    private float normalOffset_;
    /// <summary>
    ///     Move particles away from the surface of the source mesh.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float NormalOffset {
      get { return normalOffset_; }
      set {
        normalOffset_ = value;
      }
    }

    /// <summary>Field number for the "arc" field.</summary>
    public const int ArcFieldNumber = 107;
    private float arc_;
    /// <summary>
    ///     Circle arc angle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Arc {
      get { return arc_; }
      set {
        arc_ = value;
      }
    }

    /// <summary>Field number for the "arcSpread" field.</summary>
    public const int ArcSpreadFieldNumber = 108;
    private float arcSpread_;
    /// <summary>
    ///     Control the gap between emission points around the arc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ArcSpread {
      get { return arcSpread_; }
      set {
        arcSpread_ = value;
      }
    }

    /// <summary>Field number for the "arcSpeed" field.</summary>
    public const int ArcSpeedFieldNumber = 109;
    private global::ProtoPs.MinMaxCurve arcSpeed_;
    /// <summary>
    ///     When using one of the animated modes, how quickly to move the emission position around the arc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve ArcSpeed {
      get { return arcSpeed_; }
      set {
        arcSpeed_ = value;
      }
    }

    /// <summary>Field number for the "arcSpeedMultiplier" field.</summary>
    public const int ArcSpeedMultiplierFieldNumber = 110;
    private float arcSpeedMultiplier_;
    /// <summary>
    ///     A multiplier of the arc speed of the emission shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ArcSpeedMultiplier {
      get { return arcSpeedMultiplier_; }
      set {
        arcSpeedMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "donutRadius" field.</summary>
    public const int DonutRadiusFieldNumber = 111;
    private float donutRadius_;
    /// <summary>
    ///     The radius of the Donut shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DonutRadius {
      get { return donutRadius_; }
      set {
        donutRadius_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 112;
    private global::ProtoMath.float3 position_;
    /// <summary>
    ///     Apply an offset to the position from which particles are emitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float3 Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 113;
    private global::ProtoMath.float4 rotation_;
    /// <summary>
    ///     Apply a rotation to the shape from which particles are emitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float4 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }

    /// <summary>Field number for the "scale" field.</summary>
    public const int ScaleFieldNumber = 115;
    private global::ProtoMath.float3 scale_;
    /// <summary>
    ///     Apply scale to the shape from which particles are emitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float3 Scale {
      get { return scale_; }
      set {
        scale_ = value;
      }
    }

    /// <summary>Field number for the "boxThickness" field.</summary>
    public const int BoxThicknessFieldNumber = 117;
    private global::ProtoMath.float3 boxThickness_;
    /// <summary>
    ///     Thickness of the box.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float3 BoxThickness {
      get { return boxThickness_; }
      set {
        boxThickness_ = value;
      }
    }

    /// <summary>Field number for the "shapeType" field.</summary>
    public const int ShapeTypeFieldNumber = 118;
    private global::ProtoPs.ParticleSystemShapeType shapeType_ = 0;
    /// <summary>
    ///     Type of shape to emit particles from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemShapeType ShapeType {
      get { return shapeType_; }
      set {
        shapeType_ = value;
      }
    }

    /// <summary>Field number for the "randomDirectionAmount" field.</summary>
    public const int RandomDirectionAmountFieldNumber = 119;
    private float randomDirectionAmount_;
    /// <summary>
    ///     Randomizes the starting direction of particles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomDirectionAmount {
      get { return randomDirectionAmount_; }
      set {
        randomDirectionAmount_ = value;
      }
    }

    /// <summary>Field number for the "sphericalDirectionAmount" field.</summary>
    public const int SphericalDirectionAmountFieldNumber = 120;
    private float sphericalDirectionAmount_;
    /// <summary>
    ///     Spherizes the starting direction of particles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SphericalDirectionAmount {
      get { return sphericalDirectionAmount_; }
      set {
        sphericalDirectionAmount_ = value;
      }
    }

    /// <summary>Field number for the "randomPositionAmount" field.</summary>
    public const int RandomPositionAmountFieldNumber = 121;
    private float randomPositionAmount_;
    /// <summary>
    ///     Randomizes the starting position of particles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomPositionAmount {
      get { return randomPositionAmount_; }
      set {
        randomPositionAmount_ = value;
      }
    }

    /// <summary>Field number for the "alignToDirection" field.</summary>
    public const int AlignToDirectionFieldNumber = 122;
    private bool alignToDirection_;
    /// <summary>
    ///     Align particles based on their initial direction of travel.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AlignToDirection {
      get { return alignToDirection_; }
      set {
        alignToDirection_ = value;
      }
    }

    /// <summary>Field number for the "radius" field.</summary>
    public const int RadiusFieldNumber = 123;
    private float radius_;
    /// <summary>
    ///     Radius of the shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Radius {
      get { return radius_; }
      set {
        radius_ = value;
      }
    }

    /// <summary>Field number for the "radiusSpeed" field.</summary>
    public const int RadiusSpeedFieldNumber = 126;
    private global::ProtoPs.MinMaxCurve radiusSpeed_;
    /// <summary>
    ///     When using one of the animated modes, how quickly to move the emission position  along the radius.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RadiusSpeed {
      get { return radiusSpeed_; }
      set {
        radiusSpeed_ = value;
      }
    }

    /// <summary>Field number for the "radiusSpeedMultiplier" field.</summary>
    public const int RadiusSpeedMultiplierFieldNumber = 127;
    private float radiusSpeedMultiplier_;
    /// <summary>
    ///     A multiplier of the radius speed of the emission shape.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RadiusSpeedMultiplier {
      get { return radiusSpeedMultiplier_; }
      set {
        radiusSpeedMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "radiusThickness" field.</summary>
    public const int RadiusThicknessFieldNumber = 128;
    private float radiusThickness_;
    /// <summary>
    ///     Thickness of the radius.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RadiusThickness {
      get { return radiusThickness_; }
      set {
        radiusThickness_ = value;
      }
    }

    /// <summary>Field number for the "angle" field.</summary>
    public const int AngleFieldNumber = 129;
    private float angle_;
    /// <summary>
    ///     Angle of the cone.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Angle {
      get { return angle_; }
      set {
        angle_ = value;
      }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 130;
    private float length_;
    /// <summary>
    ///     Length of the cone.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    /// <summary>Field number for the "radiusSpread" field.</summary>
    public const int RadiusSpreadFieldNumber = 131;
    private float radiusSpread_;
    /// <summary>
    ///     Control the gap between emission points along the radius.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RadiusSpread {
      get { return radiusSpread_; }
      set {
        radiusSpread_ = value;
      }
    }

    /// <summary>Field number for the "meshShapeType" field.</summary>
    public const int MeshShapeTypeFieldNumber = 132;
    private global::ProtoPs.ParticleSystemMeshShapeType meshShapeType_ = 0;
    /// <summary>
    ///     Where on the mesh to emit particles from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemMeshShapeType MeshShapeType {
      get { return meshShapeType_; }
      set {
        meshShapeType_ = value;
      }
    }

    /// <summary>Field number for the "meshRendererName" field.</summary>
    public const int MeshRendererNameFieldNumber = 201;
    private string meshRendererName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MeshRendererName {
      get { return meshRendererName_; }
      set {
        meshRendererName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "meshName" field.</summary>
    public const int MeshNameFieldNumber = 202;
    private string meshName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MeshName {
      get { return meshName_; }
      set {
        meshName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ShapeModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ShapeModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (UseMeshMaterialIndex != other.UseMeshMaterialIndex) return false;
      if (MeshMaterialIndex != other.MeshMaterialIndex) return false;
      if (UseMeshColors != other.UseMeshColors) return false;
      if (NormalOffset != other.NormalOffset) return false;
      if (Arc != other.Arc) return false;
      if (ArcSpread != other.ArcSpread) return false;
      if (!object.Equals(ArcSpeed, other.ArcSpeed)) return false;
      if (ArcSpeedMultiplier != other.ArcSpeedMultiplier) return false;
      if (DonutRadius != other.DonutRadius) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (!object.Equals(Scale, other.Scale)) return false;
      if (!object.Equals(BoxThickness, other.BoxThickness)) return false;
      if (ShapeType != other.ShapeType) return false;
      if (RandomDirectionAmount != other.RandomDirectionAmount) return false;
      if (SphericalDirectionAmount != other.SphericalDirectionAmount) return false;
      if (RandomPositionAmount != other.RandomPositionAmount) return false;
      if (AlignToDirection != other.AlignToDirection) return false;
      if (Radius != other.Radius) return false;
      if (!object.Equals(RadiusSpeed, other.RadiusSpeed)) return false;
      if (RadiusSpeedMultiplier != other.RadiusSpeedMultiplier) return false;
      if (RadiusThickness != other.RadiusThickness) return false;
      if (Angle != other.Angle) return false;
      if (Length != other.Length) return false;
      if (RadiusSpread != other.RadiusSpread) return false;
      if (MeshShapeType != other.MeshShapeType) return false;
      if (MeshRendererName != other.MeshRendererName) return false;
      if (MeshName != other.MeshName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (UseMeshMaterialIndex != false) hash ^= UseMeshMaterialIndex.GetHashCode();
      if (MeshMaterialIndex != 0) hash ^= MeshMaterialIndex.GetHashCode();
      if (UseMeshColors != false) hash ^= UseMeshColors.GetHashCode();
      if (NormalOffset != 0F) hash ^= NormalOffset.GetHashCode();
      if (Arc != 0F) hash ^= Arc.GetHashCode();
      if (ArcSpread != 0F) hash ^= ArcSpread.GetHashCode();
      if (arcSpeed_ != null) hash ^= ArcSpeed.GetHashCode();
      if (ArcSpeedMultiplier != 0F) hash ^= ArcSpeedMultiplier.GetHashCode();
      if (DonutRadius != 0F) hash ^= DonutRadius.GetHashCode();
      if (position_ != null) hash ^= Position.GetHashCode();
      if (rotation_ != null) hash ^= Rotation.GetHashCode();
      if (scale_ != null) hash ^= Scale.GetHashCode();
      if (boxThickness_ != null) hash ^= BoxThickness.GetHashCode();
      if (ShapeType != 0) hash ^= ShapeType.GetHashCode();
      if (RandomDirectionAmount != 0F) hash ^= RandomDirectionAmount.GetHashCode();
      if (SphericalDirectionAmount != 0F) hash ^= SphericalDirectionAmount.GetHashCode();
      if (RandomPositionAmount != 0F) hash ^= RandomPositionAmount.GetHashCode();
      if (AlignToDirection != false) hash ^= AlignToDirection.GetHashCode();
      if (Radius != 0F) hash ^= Radius.GetHashCode();
      if (radiusSpeed_ != null) hash ^= RadiusSpeed.GetHashCode();
      if (RadiusSpeedMultiplier != 0F) hash ^= RadiusSpeedMultiplier.GetHashCode();
      if (RadiusThickness != 0F) hash ^= RadiusThickness.GetHashCode();
      if (Angle != 0F) hash ^= Angle.GetHashCode();
      if (Length != 0F) hash ^= Length.GetHashCode();
      if (RadiusSpread != 0F) hash ^= RadiusSpread.GetHashCode();
      if (MeshShapeType != 0) hash ^= MeshShapeType.GetHashCode();
      if (MeshRendererName.Length != 0) hash ^= MeshRendererName.GetHashCode();
      if (MeshName.Length != 0) hash ^= MeshName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(160, 6);
        output.WriteBool(Enabled);
      }
      if (UseMeshMaterialIndex != false) {
        output.WriteRawTag(176, 6);
        output.WriteBool(UseMeshMaterialIndex);
      }
      if (MeshMaterialIndex != 0) {
        output.WriteRawTag(184, 6);
        output.WriteInt32(MeshMaterialIndex);
      }
      if (UseMeshColors != false) {
        output.WriteRawTag(192, 6);
        output.WriteBool(UseMeshColors);
      }
      if (NormalOffset != 0F) {
        output.WriteRawTag(205, 6);
        output.WriteFloat(NormalOffset);
      }
      if (Arc != 0F) {
        output.WriteRawTag(221, 6);
        output.WriteFloat(Arc);
      }
      if (ArcSpread != 0F) {
        output.WriteRawTag(229, 6);
        output.WriteFloat(ArcSpread);
      }
      if (arcSpeed_ != null) {
        output.WriteRawTag(234, 6);
        output.WriteMessage(ArcSpeed);
      }
      if (ArcSpeedMultiplier != 0F) {
        output.WriteRawTag(245, 6);
        output.WriteFloat(ArcSpeedMultiplier);
      }
      if (DonutRadius != 0F) {
        output.WriteRawTag(253, 6);
        output.WriteFloat(DonutRadius);
      }
      if (position_ != null) {
        output.WriteRawTag(130, 7);
        output.WriteMessage(Position);
      }
      if (rotation_ != null) {
        output.WriteRawTag(138, 7);
        output.WriteMessage(Rotation);
      }
      if (scale_ != null) {
        output.WriteRawTag(154, 7);
        output.WriteMessage(Scale);
      }
      if (boxThickness_ != null) {
        output.WriteRawTag(170, 7);
        output.WriteMessage(BoxThickness);
      }
      if (ShapeType != 0) {
        output.WriteRawTag(176, 7);
        output.WriteEnum((int) ShapeType);
      }
      if (RandomDirectionAmount != 0F) {
        output.WriteRawTag(189, 7);
        output.WriteFloat(RandomDirectionAmount);
      }
      if (SphericalDirectionAmount != 0F) {
        output.WriteRawTag(197, 7);
        output.WriteFloat(SphericalDirectionAmount);
      }
      if (RandomPositionAmount != 0F) {
        output.WriteRawTag(205, 7);
        output.WriteFloat(RandomPositionAmount);
      }
      if (AlignToDirection != false) {
        output.WriteRawTag(208, 7);
        output.WriteBool(AlignToDirection);
      }
      if (Radius != 0F) {
        output.WriteRawTag(221, 7);
        output.WriteFloat(Radius);
      }
      if (radiusSpeed_ != null) {
        output.WriteRawTag(242, 7);
        output.WriteMessage(RadiusSpeed);
      }
      if (RadiusSpeedMultiplier != 0F) {
        output.WriteRawTag(253, 7);
        output.WriteFloat(RadiusSpeedMultiplier);
      }
      if (RadiusThickness != 0F) {
        output.WriteRawTag(133, 8);
        output.WriteFloat(RadiusThickness);
      }
      if (Angle != 0F) {
        output.WriteRawTag(141, 8);
        output.WriteFloat(Angle);
      }
      if (Length != 0F) {
        output.WriteRawTag(149, 8);
        output.WriteFloat(Length);
      }
      if (RadiusSpread != 0F) {
        output.WriteRawTag(157, 8);
        output.WriteFloat(RadiusSpread);
      }
      if (MeshShapeType != 0) {
        output.WriteRawTag(160, 8);
        output.WriteEnum((int) MeshShapeType);
      }
      if (MeshRendererName.Length != 0) {
        output.WriteRawTag(202, 12);
        output.WriteString(MeshRendererName);
      }
      if (MeshName.Length != 0) {
        output.WriteRawTag(210, 12);
        output.WriteString(MeshName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 2 + 1;
      }
      if (UseMeshMaterialIndex != false) {
        size += 2 + 1;
      }
      if (MeshMaterialIndex != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MeshMaterialIndex);
      }
      if (UseMeshColors != false) {
        size += 2 + 1;
      }
      if (NormalOffset != 0F) {
        size += 2 + 4;
      }
      if (Arc != 0F) {
        size += 2 + 4;
      }
      if (ArcSpread != 0F) {
        size += 2 + 4;
      }
      if (arcSpeed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ArcSpeed);
      }
      if (ArcSpeedMultiplier != 0F) {
        size += 2 + 4;
      }
      if (DonutRadius != 0F) {
        size += 2 + 4;
      }
      if (position_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (rotation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Rotation);
      }
      if (scale_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Scale);
      }
      if (boxThickness_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(BoxThickness);
      }
      if (ShapeType != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ShapeType);
      }
      if (RandomDirectionAmount != 0F) {
        size += 2 + 4;
      }
      if (SphericalDirectionAmount != 0F) {
        size += 2 + 4;
      }
      if (RandomPositionAmount != 0F) {
        size += 2 + 4;
      }
      if (AlignToDirection != false) {
        size += 2 + 1;
      }
      if (Radius != 0F) {
        size += 2 + 4;
      }
      if (radiusSpeed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RadiusSpeed);
      }
      if (RadiusSpeedMultiplier != 0F) {
        size += 2 + 4;
      }
      if (RadiusThickness != 0F) {
        size += 2 + 4;
      }
      if (Angle != 0F) {
        size += 2 + 4;
      }
      if (Length != 0F) {
        size += 2 + 4;
      }
      if (RadiusSpread != 0F) {
        size += 2 + 4;
      }
      if (MeshShapeType != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) MeshShapeType);
      }
      if (MeshRendererName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MeshRendererName);
      }
      if (MeshName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MeshName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ShapeModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.UseMeshMaterialIndex != false) {
        UseMeshMaterialIndex = other.UseMeshMaterialIndex;
      }
      if (other.MeshMaterialIndex != 0) {
        MeshMaterialIndex = other.MeshMaterialIndex;
      }
      if (other.UseMeshColors != false) {
        UseMeshColors = other.UseMeshColors;
      }
      if (other.NormalOffset != 0F) {
        NormalOffset = other.NormalOffset;
      }
      if (other.Arc != 0F) {
        Arc = other.Arc;
      }
      if (other.ArcSpread != 0F) {
        ArcSpread = other.ArcSpread;
      }
      if (other.arcSpeed_ != null) {
        if (arcSpeed_ == null) {
          arcSpeed_ = new global::ProtoPs.MinMaxCurve();
        }
        ArcSpeed.MergeFrom(other.ArcSpeed);
      }
      if (other.ArcSpeedMultiplier != 0F) {
        ArcSpeedMultiplier = other.ArcSpeedMultiplier;
      }
      if (other.DonutRadius != 0F) {
        DonutRadius = other.DonutRadius;
      }
      if (other.position_ != null) {
        if (position_ == null) {
          position_ = new global::ProtoMath.float3();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.rotation_ != null) {
        if (rotation_ == null) {
          rotation_ = new global::ProtoMath.float4();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.scale_ != null) {
        if (scale_ == null) {
          scale_ = new global::ProtoMath.float3();
        }
        Scale.MergeFrom(other.Scale);
      }
      if (other.boxThickness_ != null) {
        if (boxThickness_ == null) {
          boxThickness_ = new global::ProtoMath.float3();
        }
        BoxThickness.MergeFrom(other.BoxThickness);
      }
      if (other.ShapeType != 0) {
        ShapeType = other.ShapeType;
      }
      if (other.RandomDirectionAmount != 0F) {
        RandomDirectionAmount = other.RandomDirectionAmount;
      }
      if (other.SphericalDirectionAmount != 0F) {
        SphericalDirectionAmount = other.SphericalDirectionAmount;
      }
      if (other.RandomPositionAmount != 0F) {
        RandomPositionAmount = other.RandomPositionAmount;
      }
      if (other.AlignToDirection != false) {
        AlignToDirection = other.AlignToDirection;
      }
      if (other.Radius != 0F) {
        Radius = other.Radius;
      }
      if (other.radiusSpeed_ != null) {
        if (radiusSpeed_ == null) {
          radiusSpeed_ = new global::ProtoPs.MinMaxCurve();
        }
        RadiusSpeed.MergeFrom(other.RadiusSpeed);
      }
      if (other.RadiusSpeedMultiplier != 0F) {
        RadiusSpeedMultiplier = other.RadiusSpeedMultiplier;
      }
      if (other.RadiusThickness != 0F) {
        RadiusThickness = other.RadiusThickness;
      }
      if (other.Angle != 0F) {
        Angle = other.Angle;
      }
      if (other.Length != 0F) {
        Length = other.Length;
      }
      if (other.RadiusSpread != 0F) {
        RadiusSpread = other.RadiusSpread;
      }
      if (other.MeshShapeType != 0) {
        MeshShapeType = other.MeshShapeType;
      }
      if (other.MeshRendererName.Length != 0) {
        MeshRendererName = other.MeshRendererName;
      }
      if (other.MeshName.Length != 0) {
        MeshName = other.MeshName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 800: {
            Enabled = input.ReadBool();
            break;
          }
          case 816: {
            UseMeshMaterialIndex = input.ReadBool();
            break;
          }
          case 824: {
            MeshMaterialIndex = input.ReadInt32();
            break;
          }
          case 832: {
            UseMeshColors = input.ReadBool();
            break;
          }
          case 845: {
            NormalOffset = input.ReadFloat();
            break;
          }
          case 861: {
            Arc = input.ReadFloat();
            break;
          }
          case 869: {
            ArcSpread = input.ReadFloat();
            break;
          }
          case 874: {
            if (arcSpeed_ == null) {
              arcSpeed_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(arcSpeed_);
            break;
          }
          case 885: {
            ArcSpeedMultiplier = input.ReadFloat();
            break;
          }
          case 893: {
            DonutRadius = input.ReadFloat();
            break;
          }
          case 898: {
            if (position_ == null) {
              position_ = new global::ProtoMath.float3();
            }
            input.ReadMessage(position_);
            break;
          }
          case 906: {
            if (rotation_ == null) {
              rotation_ = new global::ProtoMath.float4();
            }
            input.ReadMessage(rotation_);
            break;
          }
          case 922: {
            if (scale_ == null) {
              scale_ = new global::ProtoMath.float3();
            }
            input.ReadMessage(scale_);
            break;
          }
          case 938: {
            if (boxThickness_ == null) {
              boxThickness_ = new global::ProtoMath.float3();
            }
            input.ReadMessage(boxThickness_);
            break;
          }
          case 944: {
            shapeType_ = (global::ProtoPs.ParticleSystemShapeType) input.ReadEnum();
            break;
          }
          case 957: {
            RandomDirectionAmount = input.ReadFloat();
            break;
          }
          case 965: {
            SphericalDirectionAmount = input.ReadFloat();
            break;
          }
          case 973: {
            RandomPositionAmount = input.ReadFloat();
            break;
          }
          case 976: {
            AlignToDirection = input.ReadBool();
            break;
          }
          case 989: {
            Radius = input.ReadFloat();
            break;
          }
          case 1010: {
            if (radiusSpeed_ == null) {
              radiusSpeed_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(radiusSpeed_);
            break;
          }
          case 1021: {
            RadiusSpeedMultiplier = input.ReadFloat();
            break;
          }
          case 1029: {
            RadiusThickness = input.ReadFloat();
            break;
          }
          case 1037: {
            Angle = input.ReadFloat();
            break;
          }
          case 1045: {
            Length = input.ReadFloat();
            break;
          }
          case 1053: {
            RadiusSpread = input.ReadFloat();
            break;
          }
          case 1056: {
            meshShapeType_ = (global::ProtoPs.ParticleSystemMeshShapeType) input.ReadEnum();
            break;
          }
          case 1610: {
            MeshRendererName = input.ReadString();
            break;
          }
          case 1618: {
            MeshName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ParticleSystemRenderer : pb::IMessage<ParticleSystemRenderer> {
    private static readonly pb::MessageParser<ParticleSystemRenderer> _parser = new pb::MessageParser<ParticleSystemRenderer>(() => new ParticleSystemRenderer());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ParticleSystemRenderer> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParticleSystemRenderer() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParticleSystemRenderer(ParticleSystemRenderer other) : this() {
      enabled_ = other.enabled_;
      material_ = other.material_;
      trailMaterial_ = other.trailMaterial_;
      meshCount_ = other.meshCount_;
      maxParticleSize_ = other.maxParticleSize_;
      minParticleSize_ = other.minParticleSize_;
      sortingFudge_ = other.sortingFudge_;
      sortMode_ = other.sortMode_;
      Pivot = other.pivot_ != null ? other.Pivot.Clone() : null;
      alignment_ = other.alignment_;
      normalDirection_ = other.normalDirection_;
      cameraVelocityScale_ = other.cameraVelocityScale_;
      velocityScale_ = other.velocityScale_;
      lengthScale_ = other.lengthScale_;
      renderMode_ = other.renderMode_;
      meshNames_ = other.meshNames_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParticleSystemRenderer Clone() {
      return new ParticleSystemRenderer(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "material" field.</summary>
    public const int MaterialFieldNumber = 2;
    private string material_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Material {
      get { return material_; }
      set {
        material_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trailMaterial" field.</summary>
    public const int TrailMaterialFieldNumber = 3;
    private string trailMaterial_ = "";
    /// <summary>
    ///-------------
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TrailMaterial {
      get { return trailMaterial_; }
      set {
        trailMaterial_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "meshCount" field.</summary>
    public const int MeshCountFieldNumber = 4;
    private int meshCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MeshCount {
      get { return meshCount_; }
      set {
        meshCount_ = value;
      }
    }

    /// <summary>Field number for the "maxParticleSize" field.</summary>
    public const int MaxParticleSizeFieldNumber = 6;
    private float maxParticleSize_;
    /// <summary>
    ///     Clamp the maximum particle size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxParticleSize {
      get { return maxParticleSize_; }
      set {
        maxParticleSize_ = value;
      }
    }

    /// <summary>Field number for the "minParticleSize" field.</summary>
    public const int MinParticleSizeFieldNumber = 7;
    private float minParticleSize_;
    /// <summary>
    ///     Clamp the minimum particle size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinParticleSize {
      get { return minParticleSize_; }
      set {
        minParticleSize_ = value;
      }
    }

    /// <summary>Field number for the "sortingFudge" field.</summary>
    public const int SortingFudgeFieldNumber = 8;
    private float sortingFudge_;
    /// <summary>
    ///     Biases particle system sorting amongst other transparencies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SortingFudge {
      get { return sortingFudge_; }
      set {
        sortingFudge_ = value;
      }
    }

    /// <summary>Field number for the "sortMode" field.</summary>
    public const int SortModeFieldNumber = 9;
    private global::ProtoPs.ParticleSystemSortMode sortMode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemSortMode SortMode {
      get { return sortMode_; }
      set {
        sortMode_ = value;
      }
    }

    /// <summary>Field number for the "pivot" field.</summary>
    public const int PivotFieldNumber = 10;
    private global::ProtoMath.float3 pivot_;
    /// <summary>
    ///     Modify the pivot point used for rotating particles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float3 Pivot {
      get { return pivot_; }
      set {
        pivot_ = value;
      }
    }

    /// <summary>Field number for the "alignment" field.</summary>
    public const int AlignmentFieldNumber = 11;
    private global::ProtoPs.ParticleSystemRenderSpace alignment_ = 0;
    /// <summary>
    ///     Control the direction that particles face.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemRenderSpace Alignment {
      get { return alignment_; }
      set {
        alignment_ = value;
      }
    }

    /// <summary>Field number for the "normalDirection" field.</summary>
    public const int NormalDirectionFieldNumber = 12;
    private float normalDirection_;
    /// <summary>
    ///     How much are billboard particle normals oriented towards the camera.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float NormalDirection {
      get { return normalDirection_; }
      set {
        normalDirection_ = value;
      }
    }

    /// <summary>Field number for the "cameraVelocityScale" field.</summary>
    public const int CameraVelocityScaleFieldNumber = 13;
    private float cameraVelocityScale_;
    /// <summary>
    /// How much are the particles stretched depending on the Camera's speed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float CameraVelocityScale {
      get { return cameraVelocityScale_; }
      set {
        cameraVelocityScale_ = value;
      }
    }

    /// <summary>Field number for the "velocityScale" field.</summary>
    public const int VelocityScaleFieldNumber = 14;
    private float velocityScale_;
    /// <summary>
    /// How much are the particles stretched depending on "how fast they move"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float VelocityScale {
      get { return velocityScale_; }
      set {
        velocityScale_ = value;
      }
    }

    /// <summary>Field number for the "lengthScale" field.</summary>
    public const int LengthScaleFieldNumber = 15;
    private float lengthScale_;
    /// <summary>
    ///     How much are the particles stretched in their direction of motion
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LengthScale {
      get { return lengthScale_; }
      set {
        lengthScale_ = value;
      }
    }

    /// <summary>Field number for the "renderMode" field.</summary>
    public const int RenderModeFieldNumber = 16;
    private global::ProtoPs.ParticleSystemRenderMode renderMode_ = 0;
    /// <summary>
    ///     How particles are drawn.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemRenderMode RenderMode {
      get { return renderMode_; }
      set {
        renderMode_ = value;
      }
    }

    /// <summary>Field number for the "meshNames" field.</summary>
    public const int MeshNamesFieldNumber = 20;
    private static readonly pb::FieldCodec<string> _repeated_meshNames_codec
        = pb::FieldCodec.ForString(162);
    private readonly pbc::RepeatedField<string> meshNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///     Mesh used as particle instead of billboarded texture.
    ///Mesh mesh=5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> MeshNames {
      get { return meshNames_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ParticleSystemRenderer);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ParticleSystemRenderer other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (Material != other.Material) return false;
      if (TrailMaterial != other.TrailMaterial) return false;
      if (MeshCount != other.MeshCount) return false;
      if (MaxParticleSize != other.MaxParticleSize) return false;
      if (MinParticleSize != other.MinParticleSize) return false;
      if (SortingFudge != other.SortingFudge) return false;
      if (SortMode != other.SortMode) return false;
      if (!object.Equals(Pivot, other.Pivot)) return false;
      if (Alignment != other.Alignment) return false;
      if (NormalDirection != other.NormalDirection) return false;
      if (CameraVelocityScale != other.CameraVelocityScale) return false;
      if (VelocityScale != other.VelocityScale) return false;
      if (LengthScale != other.LengthScale) return false;
      if (RenderMode != other.RenderMode) return false;
      if(!meshNames_.Equals(other.meshNames_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (Material.Length != 0) hash ^= Material.GetHashCode();
      if (TrailMaterial.Length != 0) hash ^= TrailMaterial.GetHashCode();
      if (MeshCount != 0) hash ^= MeshCount.GetHashCode();
      if (MaxParticleSize != 0F) hash ^= MaxParticleSize.GetHashCode();
      if (MinParticleSize != 0F) hash ^= MinParticleSize.GetHashCode();
      if (SortingFudge != 0F) hash ^= SortingFudge.GetHashCode();
      if (SortMode != 0) hash ^= SortMode.GetHashCode();
      if (pivot_ != null) hash ^= Pivot.GetHashCode();
      if (Alignment != 0) hash ^= Alignment.GetHashCode();
      if (NormalDirection != 0F) hash ^= NormalDirection.GetHashCode();
      if (CameraVelocityScale != 0F) hash ^= CameraVelocityScale.GetHashCode();
      if (VelocityScale != 0F) hash ^= VelocityScale.GetHashCode();
      if (LengthScale != 0F) hash ^= LengthScale.GetHashCode();
      if (RenderMode != 0) hash ^= RenderMode.GetHashCode();
      hash ^= meshNames_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (Material.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Material);
      }
      if (TrailMaterial.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(TrailMaterial);
      }
      if (MeshCount != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MeshCount);
      }
      if (MaxParticleSize != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(MaxParticleSize);
      }
      if (MinParticleSize != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(MinParticleSize);
      }
      if (SortingFudge != 0F) {
        output.WriteRawTag(69);
        output.WriteFloat(SortingFudge);
      }
      if (SortMode != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) SortMode);
      }
      if (pivot_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Pivot);
      }
      if (Alignment != 0) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Alignment);
      }
      if (NormalDirection != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(NormalDirection);
      }
      if (CameraVelocityScale != 0F) {
        output.WriteRawTag(109);
        output.WriteFloat(CameraVelocityScale);
      }
      if (VelocityScale != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(VelocityScale);
      }
      if (LengthScale != 0F) {
        output.WriteRawTag(125);
        output.WriteFloat(LengthScale);
      }
      if (RenderMode != 0) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) RenderMode);
      }
      meshNames_.WriteTo(output, _repeated_meshNames_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (Material.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Material);
      }
      if (TrailMaterial.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TrailMaterial);
      }
      if (MeshCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MeshCount);
      }
      if (MaxParticleSize != 0F) {
        size += 1 + 4;
      }
      if (MinParticleSize != 0F) {
        size += 1 + 4;
      }
      if (SortingFudge != 0F) {
        size += 1 + 4;
      }
      if (SortMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SortMode);
      }
      if (pivot_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pivot);
      }
      if (Alignment != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Alignment);
      }
      if (NormalDirection != 0F) {
        size += 1 + 4;
      }
      if (CameraVelocityScale != 0F) {
        size += 1 + 4;
      }
      if (VelocityScale != 0F) {
        size += 1 + 4;
      }
      if (LengthScale != 0F) {
        size += 1 + 4;
      }
      if (RenderMode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) RenderMode);
      }
      size += meshNames_.CalculateSize(_repeated_meshNames_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ParticleSystemRenderer other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.Material.Length != 0) {
        Material = other.Material;
      }
      if (other.TrailMaterial.Length != 0) {
        TrailMaterial = other.TrailMaterial;
      }
      if (other.MeshCount != 0) {
        MeshCount = other.MeshCount;
      }
      if (other.MaxParticleSize != 0F) {
        MaxParticleSize = other.MaxParticleSize;
      }
      if (other.MinParticleSize != 0F) {
        MinParticleSize = other.MinParticleSize;
      }
      if (other.SortingFudge != 0F) {
        SortingFudge = other.SortingFudge;
      }
      if (other.SortMode != 0) {
        SortMode = other.SortMode;
      }
      if (other.pivot_ != null) {
        if (pivot_ == null) {
          pivot_ = new global::ProtoMath.float3();
        }
        Pivot.MergeFrom(other.Pivot);
      }
      if (other.Alignment != 0) {
        Alignment = other.Alignment;
      }
      if (other.NormalDirection != 0F) {
        NormalDirection = other.NormalDirection;
      }
      if (other.CameraVelocityScale != 0F) {
        CameraVelocityScale = other.CameraVelocityScale;
      }
      if (other.VelocityScale != 0F) {
        VelocityScale = other.VelocityScale;
      }
      if (other.LengthScale != 0F) {
        LengthScale = other.LengthScale;
      }
      if (other.RenderMode != 0) {
        RenderMode = other.RenderMode;
      }
      meshNames_.Add(other.meshNames_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 18: {
            Material = input.ReadString();
            break;
          }
          case 26: {
            TrailMaterial = input.ReadString();
            break;
          }
          case 32: {
            MeshCount = input.ReadInt32();
            break;
          }
          case 53: {
            MaxParticleSize = input.ReadFloat();
            break;
          }
          case 61: {
            MinParticleSize = input.ReadFloat();
            break;
          }
          case 69: {
            SortingFudge = input.ReadFloat();
            break;
          }
          case 72: {
            sortMode_ = (global::ProtoPs.ParticleSystemSortMode) input.ReadEnum();
            break;
          }
          case 82: {
            if (pivot_ == null) {
              pivot_ = new global::ProtoMath.float3();
            }
            input.ReadMessage(pivot_);
            break;
          }
          case 88: {
            alignment_ = (global::ProtoPs.ParticleSystemRenderSpace) input.ReadEnum();
            break;
          }
          case 101: {
            NormalDirection = input.ReadFloat();
            break;
          }
          case 109: {
            CameraVelocityScale = input.ReadFloat();
            break;
          }
          case 117: {
            VelocityScale = input.ReadFloat();
            break;
          }
          case 125: {
            LengthScale = input.ReadFloat();
            break;
          }
          case 128: {
            renderMode_ = (global::ProtoPs.ParticleSystemRenderMode) input.ReadEnum();
            break;
          }
          case 162: {
            meshNames_.AddEntriesFrom(input, _repeated_meshNames_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class NoiseModule : pb::IMessage<NoiseModule> {
    private static readonly pb::MessageParser<NoiseModule> _parser = new pb::MessageParser<NoiseModule>(() => new NoiseModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NoiseModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NoiseModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NoiseModule(NoiseModule other) : this() {
      enabled_ = other.enabled_;
      PositionAmount = other.positionAmount_ != null ? other.PositionAmount.Clone() : null;
      remapZMultiplier_ = other.remapZMultiplier_;
      RemapZ = other.remapZ_ != null ? other.RemapZ.Clone() : null;
      remapYMultiplier_ = other.remapYMultiplier_;
      RemapY = other.remapY_ != null ? other.RemapY.Clone() : null;
      remapXMultiplier_ = other.remapXMultiplier_;
      RemapX = other.remapX_ != null ? other.RemapX.Clone() : null;
      remapMultiplier_ = other.remapMultiplier_;
      Remap = other.remap_ != null ? other.Remap.Clone() : null;
      remapEnabled_ = other.remapEnabled_;
      scrollSpeedMultiplier_ = other.scrollSpeedMultiplier_;
      ScrollSpeed = other.scrollSpeed_ != null ? other.ScrollSpeed.Clone() : null;
      quality_ = other.quality_;
      octaveScale_ = other.octaveScale_;
      octaveMultiplier_ = other.octaveMultiplier_;
      octaveCount_ = other.octaveCount_;
      damping_ = other.damping_;
      frequency_ = other.frequency_;
      strengthZMultiplier_ = other.strengthZMultiplier_;
      StrengthZ = other.strengthZ_ != null ? other.StrengthZ.Clone() : null;
      strengthYMultiplier_ = other.strengthYMultiplier_;
      StrengthY = other.strengthY_ != null ? other.StrengthY.Clone() : null;
      strengthXMultiplier_ = other.strengthXMultiplier_;
      StrengthX = other.strengthX_ != null ? other.StrengthX.Clone() : null;
      strengthMultiplier_ = other.strengthMultiplier_;
      Strength = other.strength_ != null ? other.Strength.Clone() : null;
      separateAxes_ = other.separateAxes_;
      RotationAmount = other.rotationAmount_ != null ? other.RotationAmount.Clone() : null;
      SizeAmount = other.sizeAmount_ != null ? other.SizeAmount.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NoiseModule Clone() {
      return new NoiseModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "positionAmount" field.</summary>
    public const int PositionAmountFieldNumber = 2;
    private global::ProtoPs.MinMaxCurve positionAmount_;
    /// <summary>
    ///How much the noise affects the particle positions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve PositionAmount {
      get { return positionAmount_; }
      set {
        positionAmount_ = value;
      }
    }

    /// <summary>Field number for the "remapZMultiplier" field.</summary>
    public const int RemapZMultiplierFieldNumber = 3;
    private float remapZMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RemapZMultiplier {
      get { return remapZMultiplier_; }
      set {
        remapZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "remapZ" field.</summary>
    public const int RemapZFieldNumber = 4;
    private global::ProtoPs.MinMaxCurve remapZ_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RemapZ {
      get { return remapZ_; }
      set {
        remapZ_ = value;
      }
    }

    /// <summary>Field number for the "remapYMultiplier" field.</summary>
    public const int RemapYMultiplierFieldNumber = 5;
    private float remapYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RemapYMultiplier {
      get { return remapYMultiplier_; }
      set {
        remapYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "remapY" field.</summary>
    public const int RemapYFieldNumber = 6;
    private global::ProtoPs.MinMaxCurve remapY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RemapY {
      get { return remapY_; }
      set {
        remapY_ = value;
      }
    }

    /// <summary>Field number for the "remapXMultiplier" field.</summary>
    public const int RemapXMultiplierFieldNumber = 7;
    private float remapXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RemapXMultiplier {
      get { return remapXMultiplier_; }
      set {
        remapXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "remapX" field.</summary>
    public const int RemapXFieldNumber = 8;
    private global::ProtoPs.MinMaxCurve remapX_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RemapX {
      get { return remapX_; }
      set {
        remapX_ = value;
      }
    }

    /// <summary>Field number for the "remapMultiplier" field.</summary>
    public const int RemapMultiplierFieldNumber = 9;
    private float remapMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RemapMultiplier {
      get { return remapMultiplier_; }
      set {
        remapMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "remap" field.</summary>
    public const int RemapFieldNumber = 10;
    private global::ProtoPs.MinMaxCurve remap_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Remap {
      get { return remap_; }
      set {
        remap_ = value;
      }
    }

    /// <summary>Field number for the "remapEnabled" field.</summary>
    public const int RemapEnabledFieldNumber = 11;
    private bool remapEnabled_;
    /// <summary>
    ///Enable remapping of the final noise values, allowing for noise values to be translated into different values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RemapEnabled {
      get { return remapEnabled_; }
      set {
        remapEnabled_ = value;
      }
    }

    /// <summary>Field number for the "scrollSpeedMultiplier" field.</summary>
    public const int ScrollSpeedMultiplierFieldNumber = 12;
    private float scrollSpeedMultiplier_;
    /// <summary>
    ///Scroll speed multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ScrollSpeedMultiplier {
      get { return scrollSpeedMultiplier_; }
      set {
        scrollSpeedMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "scrollSpeed" field.</summary>
    public const int ScrollSpeedFieldNumber = 13;
    private global::ProtoPs.MinMaxCurve scrollSpeed_;
    /// <summary>
    /// Scroll the noise map over the particle system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve ScrollSpeed {
      get { return scrollSpeed_; }
      set {
        scrollSpeed_ = value;
      }
    }

    /// <summary>Field number for the "quality" field.</summary>
    public const int QualityFieldNumber = 14;
    private global::ProtoPs.ParticleSystemNoiseQuality quality_ = 0;
    /// <summary>
    /// Generate 1D, 2D or 3D noise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemNoiseQuality Quality {
      get { return quality_; }
      set {
        quality_ = value;
      }
    }

    /// <summary>Field number for the "octaveScale" field.</summary>
    public const int OctaveScaleFieldNumber = 15;
    private float octaveScale_;
    /// <summary>
    ///     When combining each octave, zoom in by this amount.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OctaveScale {
      get { return octaveScale_; }
      set {
        octaveScale_ = value;
      }
    }

    /// <summary>Field number for the "octaveMultiplier" field.</summary>
    public const int OctaveMultiplierFieldNumber = 16;
    private float octaveMultiplier_;
    /// <summary>
    ///When combining each octave, scale the intensity by this amount.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OctaveMultiplier {
      get { return octaveMultiplier_; }
      set {
        octaveMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "octaveCount" field.</summary>
    public const int OctaveCountFieldNumber = 17;
    private int octaveCount_;
    /// <summary>
    ///     Layers of noise that combine to produce final noise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int OctaveCount {
      get { return octaveCount_; }
      set {
        octaveCount_ = value;
      }
    }

    /// <summary>Field number for the "damping" field.</summary>
    public const int DampingFieldNumber = 18;
    private bool damping_;
    /// <summary>
    ///     Higher frequency noise will reduce the strength by a proportional amount, if enabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Damping {
      get { return damping_; }
      set {
        damping_ = value;
      }
    }

    /// <summary>Field number for the "frequency" field.</summary>
    public const int FrequencyFieldNumber = 19;
    private float frequency_;
    /// <summary>
    ///     Low values create soft, smooth noise, and high values create rapidly changing noise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Frequency {
      get { return frequency_; }
      set {
        frequency_ = value;
      }
    }

    /// <summary>Field number for the "strengthZMultiplier" field.</summary>
    public const int StrengthZMultiplierFieldNumber = 20;
    private float strengthZMultiplier_;
    /// <summary>
    ///     Z axis strength multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StrengthZMultiplier {
      get { return strengthZMultiplier_; }
      set {
        strengthZMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "strengthZ" field.</summary>
    public const int StrengthZFieldNumber = 21;
    private global::ProtoPs.MinMaxCurve strengthZ_;
    /// <summary>
    ///Define the strength of the effect on the Z axis, when using the ParticleSystem.NoiseModule.separateAxes option.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StrengthZ {
      get { return strengthZ_; }
      set {
        strengthZ_ = value;
      }
    }

    /// <summary>Field number for the "strengthYMultiplier" field.</summary>
    public const int StrengthYMultiplierFieldNumber = 22;
    private float strengthYMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StrengthYMultiplier {
      get { return strengthYMultiplier_; }
      set {
        strengthYMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "strengthY" field.</summary>
    public const int StrengthYFieldNumber = 23;
    private global::ProtoPs.MinMaxCurve strengthY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StrengthY {
      get { return strengthY_; }
      set {
        strengthY_ = value;
      }
    }

    /// <summary>Field number for the "strengthXMultiplier" field.</summary>
    public const int StrengthXMultiplierFieldNumber = 24;
    private float strengthXMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StrengthXMultiplier {
      get { return strengthXMultiplier_; }
      set {
        strengthXMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "strengthX" field.</summary>
    public const int StrengthXFieldNumber = 25;
    private global::ProtoPs.MinMaxCurve strengthX_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve StrengthX {
      get { return strengthX_; }
      set {
        strengthX_ = value;
      }
    }

    /// <summary>Field number for the "strengthMultiplier" field.</summary>
    public const int StrengthMultiplierFieldNumber = 26;
    private float strengthMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StrengthMultiplier {
      get { return strengthMultiplier_; }
      set {
        strengthMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "strength" field.</summary>
    public const int StrengthFieldNumber = 27;
    private global::ProtoPs.MinMaxCurve strength_;
    /// <summary>
    ///How strong the overall noise effect is.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Strength {
      get { return strength_; }
      set {
        strength_ = value;
      }
    }

    /// <summary>Field number for the "separateAxes" field.</summary>
    public const int SeparateAxesFieldNumber = 28;
    private bool separateAxes_;
    /// <summary>
    ///     Control the noise separately for each axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SeparateAxes {
      get { return separateAxes_; }
      set {
        separateAxes_ = value;
      }
    }

    /// <summary>Field number for the "rotationAmount" field.</summary>
    public const int RotationAmountFieldNumber = 29;
    private global::ProtoPs.MinMaxCurve rotationAmount_;
    /// <summary>
    /// How much the noise affects the particle rotation, in degrees per second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve RotationAmount {
      get { return rotationAmount_; }
      set {
        rotationAmount_ = value;
      }
    }

    /// <summary>Field number for the "sizeAmount" field.</summary>
    public const int SizeAmountFieldNumber = 30;
    private global::ProtoPs.MinMaxCurve sizeAmount_;
    /// <summary>
    ///How much the noise affects the particle sizes, applied as a multiplier on the size of each particle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve SizeAmount {
      get { return sizeAmount_; }
      set {
        sizeAmount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NoiseModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NoiseModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(PositionAmount, other.PositionAmount)) return false;
      if (RemapZMultiplier != other.RemapZMultiplier) return false;
      if (!object.Equals(RemapZ, other.RemapZ)) return false;
      if (RemapYMultiplier != other.RemapYMultiplier) return false;
      if (!object.Equals(RemapY, other.RemapY)) return false;
      if (RemapXMultiplier != other.RemapXMultiplier) return false;
      if (!object.Equals(RemapX, other.RemapX)) return false;
      if (RemapMultiplier != other.RemapMultiplier) return false;
      if (!object.Equals(Remap, other.Remap)) return false;
      if (RemapEnabled != other.RemapEnabled) return false;
      if (ScrollSpeedMultiplier != other.ScrollSpeedMultiplier) return false;
      if (!object.Equals(ScrollSpeed, other.ScrollSpeed)) return false;
      if (Quality != other.Quality) return false;
      if (OctaveScale != other.OctaveScale) return false;
      if (OctaveMultiplier != other.OctaveMultiplier) return false;
      if (OctaveCount != other.OctaveCount) return false;
      if (Damping != other.Damping) return false;
      if (Frequency != other.Frequency) return false;
      if (StrengthZMultiplier != other.StrengthZMultiplier) return false;
      if (!object.Equals(StrengthZ, other.StrengthZ)) return false;
      if (StrengthYMultiplier != other.StrengthYMultiplier) return false;
      if (!object.Equals(StrengthY, other.StrengthY)) return false;
      if (StrengthXMultiplier != other.StrengthXMultiplier) return false;
      if (!object.Equals(StrengthX, other.StrengthX)) return false;
      if (StrengthMultiplier != other.StrengthMultiplier) return false;
      if (!object.Equals(Strength, other.Strength)) return false;
      if (SeparateAxes != other.SeparateAxes) return false;
      if (!object.Equals(RotationAmount, other.RotationAmount)) return false;
      if (!object.Equals(SizeAmount, other.SizeAmount)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (positionAmount_ != null) hash ^= PositionAmount.GetHashCode();
      if (RemapZMultiplier != 0F) hash ^= RemapZMultiplier.GetHashCode();
      if (remapZ_ != null) hash ^= RemapZ.GetHashCode();
      if (RemapYMultiplier != 0F) hash ^= RemapYMultiplier.GetHashCode();
      if (remapY_ != null) hash ^= RemapY.GetHashCode();
      if (RemapXMultiplier != 0F) hash ^= RemapXMultiplier.GetHashCode();
      if (remapX_ != null) hash ^= RemapX.GetHashCode();
      if (RemapMultiplier != 0F) hash ^= RemapMultiplier.GetHashCode();
      if (remap_ != null) hash ^= Remap.GetHashCode();
      if (RemapEnabled != false) hash ^= RemapEnabled.GetHashCode();
      if (ScrollSpeedMultiplier != 0F) hash ^= ScrollSpeedMultiplier.GetHashCode();
      if (scrollSpeed_ != null) hash ^= ScrollSpeed.GetHashCode();
      if (Quality != 0) hash ^= Quality.GetHashCode();
      if (OctaveScale != 0F) hash ^= OctaveScale.GetHashCode();
      if (OctaveMultiplier != 0F) hash ^= OctaveMultiplier.GetHashCode();
      if (OctaveCount != 0) hash ^= OctaveCount.GetHashCode();
      if (Damping != false) hash ^= Damping.GetHashCode();
      if (Frequency != 0F) hash ^= Frequency.GetHashCode();
      if (StrengthZMultiplier != 0F) hash ^= StrengthZMultiplier.GetHashCode();
      if (strengthZ_ != null) hash ^= StrengthZ.GetHashCode();
      if (StrengthYMultiplier != 0F) hash ^= StrengthYMultiplier.GetHashCode();
      if (strengthY_ != null) hash ^= StrengthY.GetHashCode();
      if (StrengthXMultiplier != 0F) hash ^= StrengthXMultiplier.GetHashCode();
      if (strengthX_ != null) hash ^= StrengthX.GetHashCode();
      if (StrengthMultiplier != 0F) hash ^= StrengthMultiplier.GetHashCode();
      if (strength_ != null) hash ^= Strength.GetHashCode();
      if (SeparateAxes != false) hash ^= SeparateAxes.GetHashCode();
      if (rotationAmount_ != null) hash ^= RotationAmount.GetHashCode();
      if (sizeAmount_ != null) hash ^= SizeAmount.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (positionAmount_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PositionAmount);
      }
      if (RemapZMultiplier != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(RemapZMultiplier);
      }
      if (remapZ_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(RemapZ);
      }
      if (RemapYMultiplier != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(RemapYMultiplier);
      }
      if (remapY_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RemapY);
      }
      if (RemapXMultiplier != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RemapXMultiplier);
      }
      if (remapX_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RemapX);
      }
      if (RemapMultiplier != 0F) {
        output.WriteRawTag(77);
        output.WriteFloat(RemapMultiplier);
      }
      if (remap_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Remap);
      }
      if (RemapEnabled != false) {
        output.WriteRawTag(88);
        output.WriteBool(RemapEnabled);
      }
      if (ScrollSpeedMultiplier != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(ScrollSpeedMultiplier);
      }
      if (scrollSpeed_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(ScrollSpeed);
      }
      if (Quality != 0) {
        output.WriteRawTag(112);
        output.WriteEnum((int) Quality);
      }
      if (OctaveScale != 0F) {
        output.WriteRawTag(125);
        output.WriteFloat(OctaveScale);
      }
      if (OctaveMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(OctaveMultiplier);
      }
      if (OctaveCount != 0) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(OctaveCount);
      }
      if (Damping != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Damping);
      }
      if (Frequency != 0F) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(Frequency);
      }
      if (StrengthZMultiplier != 0F) {
        output.WriteRawTag(165, 1);
        output.WriteFloat(StrengthZMultiplier);
      }
      if (strengthZ_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(StrengthZ);
      }
      if (StrengthYMultiplier != 0F) {
        output.WriteRawTag(181, 1);
        output.WriteFloat(StrengthYMultiplier);
      }
      if (strengthY_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(StrengthY);
      }
      if (StrengthXMultiplier != 0F) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(StrengthXMultiplier);
      }
      if (strengthX_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(StrengthX);
      }
      if (StrengthMultiplier != 0F) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(StrengthMultiplier);
      }
      if (strength_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(Strength);
      }
      if (SeparateAxes != false) {
        output.WriteRawTag(224, 1);
        output.WriteBool(SeparateAxes);
      }
      if (rotationAmount_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(RotationAmount);
      }
      if (sizeAmount_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(SizeAmount);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (positionAmount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PositionAmount);
      }
      if (RemapZMultiplier != 0F) {
        size += 1 + 4;
      }
      if (remapZ_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemapZ);
      }
      if (RemapYMultiplier != 0F) {
        size += 1 + 4;
      }
      if (remapY_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemapY);
      }
      if (RemapXMultiplier != 0F) {
        size += 1 + 4;
      }
      if (remapX_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemapX);
      }
      if (RemapMultiplier != 0F) {
        size += 1 + 4;
      }
      if (remap_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Remap);
      }
      if (RemapEnabled != false) {
        size += 1 + 1;
      }
      if (ScrollSpeedMultiplier != 0F) {
        size += 1 + 4;
      }
      if (scrollSpeed_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScrollSpeed);
      }
      if (Quality != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Quality);
      }
      if (OctaveScale != 0F) {
        size += 1 + 4;
      }
      if (OctaveMultiplier != 0F) {
        size += 2 + 4;
      }
      if (OctaveCount != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(OctaveCount);
      }
      if (Damping != false) {
        size += 2 + 1;
      }
      if (Frequency != 0F) {
        size += 2 + 4;
      }
      if (StrengthZMultiplier != 0F) {
        size += 2 + 4;
      }
      if (strengthZ_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StrengthZ);
      }
      if (StrengthYMultiplier != 0F) {
        size += 2 + 4;
      }
      if (strengthY_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StrengthY);
      }
      if (StrengthXMultiplier != 0F) {
        size += 2 + 4;
      }
      if (strengthX_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StrengthX);
      }
      if (StrengthMultiplier != 0F) {
        size += 2 + 4;
      }
      if (strength_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Strength);
      }
      if (SeparateAxes != false) {
        size += 2 + 1;
      }
      if (rotationAmount_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RotationAmount);
      }
      if (sizeAmount_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SizeAmount);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NoiseModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.positionAmount_ != null) {
        if (positionAmount_ == null) {
          positionAmount_ = new global::ProtoPs.MinMaxCurve();
        }
        PositionAmount.MergeFrom(other.PositionAmount);
      }
      if (other.RemapZMultiplier != 0F) {
        RemapZMultiplier = other.RemapZMultiplier;
      }
      if (other.remapZ_ != null) {
        if (remapZ_ == null) {
          remapZ_ = new global::ProtoPs.MinMaxCurve();
        }
        RemapZ.MergeFrom(other.RemapZ);
      }
      if (other.RemapYMultiplier != 0F) {
        RemapYMultiplier = other.RemapYMultiplier;
      }
      if (other.remapY_ != null) {
        if (remapY_ == null) {
          remapY_ = new global::ProtoPs.MinMaxCurve();
        }
        RemapY.MergeFrom(other.RemapY);
      }
      if (other.RemapXMultiplier != 0F) {
        RemapXMultiplier = other.RemapXMultiplier;
      }
      if (other.remapX_ != null) {
        if (remapX_ == null) {
          remapX_ = new global::ProtoPs.MinMaxCurve();
        }
        RemapX.MergeFrom(other.RemapX);
      }
      if (other.RemapMultiplier != 0F) {
        RemapMultiplier = other.RemapMultiplier;
      }
      if (other.remap_ != null) {
        if (remap_ == null) {
          remap_ = new global::ProtoPs.MinMaxCurve();
        }
        Remap.MergeFrom(other.Remap);
      }
      if (other.RemapEnabled != false) {
        RemapEnabled = other.RemapEnabled;
      }
      if (other.ScrollSpeedMultiplier != 0F) {
        ScrollSpeedMultiplier = other.ScrollSpeedMultiplier;
      }
      if (other.scrollSpeed_ != null) {
        if (scrollSpeed_ == null) {
          scrollSpeed_ = new global::ProtoPs.MinMaxCurve();
        }
        ScrollSpeed.MergeFrom(other.ScrollSpeed);
      }
      if (other.Quality != 0) {
        Quality = other.Quality;
      }
      if (other.OctaveScale != 0F) {
        OctaveScale = other.OctaveScale;
      }
      if (other.OctaveMultiplier != 0F) {
        OctaveMultiplier = other.OctaveMultiplier;
      }
      if (other.OctaveCount != 0) {
        OctaveCount = other.OctaveCount;
      }
      if (other.Damping != false) {
        Damping = other.Damping;
      }
      if (other.Frequency != 0F) {
        Frequency = other.Frequency;
      }
      if (other.StrengthZMultiplier != 0F) {
        StrengthZMultiplier = other.StrengthZMultiplier;
      }
      if (other.strengthZ_ != null) {
        if (strengthZ_ == null) {
          strengthZ_ = new global::ProtoPs.MinMaxCurve();
        }
        StrengthZ.MergeFrom(other.StrengthZ);
      }
      if (other.StrengthYMultiplier != 0F) {
        StrengthYMultiplier = other.StrengthYMultiplier;
      }
      if (other.strengthY_ != null) {
        if (strengthY_ == null) {
          strengthY_ = new global::ProtoPs.MinMaxCurve();
        }
        StrengthY.MergeFrom(other.StrengthY);
      }
      if (other.StrengthXMultiplier != 0F) {
        StrengthXMultiplier = other.StrengthXMultiplier;
      }
      if (other.strengthX_ != null) {
        if (strengthX_ == null) {
          strengthX_ = new global::ProtoPs.MinMaxCurve();
        }
        StrengthX.MergeFrom(other.StrengthX);
      }
      if (other.StrengthMultiplier != 0F) {
        StrengthMultiplier = other.StrengthMultiplier;
      }
      if (other.strength_ != null) {
        if (strength_ == null) {
          strength_ = new global::ProtoPs.MinMaxCurve();
        }
        Strength.MergeFrom(other.Strength);
      }
      if (other.SeparateAxes != false) {
        SeparateAxes = other.SeparateAxes;
      }
      if (other.rotationAmount_ != null) {
        if (rotationAmount_ == null) {
          rotationAmount_ = new global::ProtoPs.MinMaxCurve();
        }
        RotationAmount.MergeFrom(other.RotationAmount);
      }
      if (other.sizeAmount_ != null) {
        if (sizeAmount_ == null) {
          sizeAmount_ = new global::ProtoPs.MinMaxCurve();
        }
        SizeAmount.MergeFrom(other.SizeAmount);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 18: {
            if (positionAmount_ == null) {
              positionAmount_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(positionAmount_);
            break;
          }
          case 29: {
            RemapZMultiplier = input.ReadFloat();
            break;
          }
          case 34: {
            if (remapZ_ == null) {
              remapZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(remapZ_);
            break;
          }
          case 45: {
            RemapYMultiplier = input.ReadFloat();
            break;
          }
          case 50: {
            if (remapY_ == null) {
              remapY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(remapY_);
            break;
          }
          case 61: {
            RemapXMultiplier = input.ReadFloat();
            break;
          }
          case 66: {
            if (remapX_ == null) {
              remapX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(remapX_);
            break;
          }
          case 77: {
            RemapMultiplier = input.ReadFloat();
            break;
          }
          case 82: {
            if (remap_ == null) {
              remap_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(remap_);
            break;
          }
          case 88: {
            RemapEnabled = input.ReadBool();
            break;
          }
          case 101: {
            ScrollSpeedMultiplier = input.ReadFloat();
            break;
          }
          case 106: {
            if (scrollSpeed_ == null) {
              scrollSpeed_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(scrollSpeed_);
            break;
          }
          case 112: {
            quality_ = (global::ProtoPs.ParticleSystemNoiseQuality) input.ReadEnum();
            break;
          }
          case 125: {
            OctaveScale = input.ReadFloat();
            break;
          }
          case 133: {
            OctaveMultiplier = input.ReadFloat();
            break;
          }
          case 136: {
            OctaveCount = input.ReadInt32();
            break;
          }
          case 144: {
            Damping = input.ReadBool();
            break;
          }
          case 157: {
            Frequency = input.ReadFloat();
            break;
          }
          case 165: {
            StrengthZMultiplier = input.ReadFloat();
            break;
          }
          case 170: {
            if (strengthZ_ == null) {
              strengthZ_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(strengthZ_);
            break;
          }
          case 181: {
            StrengthYMultiplier = input.ReadFloat();
            break;
          }
          case 186: {
            if (strengthY_ == null) {
              strengthY_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(strengthY_);
            break;
          }
          case 197: {
            StrengthXMultiplier = input.ReadFloat();
            break;
          }
          case 202: {
            if (strengthX_ == null) {
              strengthX_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(strengthX_);
            break;
          }
          case 213: {
            StrengthMultiplier = input.ReadFloat();
            break;
          }
          case 218: {
            if (strength_ == null) {
              strength_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(strength_);
            break;
          }
          case 224: {
            SeparateAxes = input.ReadBool();
            break;
          }
          case 234: {
            if (rotationAmount_ == null) {
              rotationAmount_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(rotationAmount_);
            break;
          }
          case 242: {
            if (sizeAmount_ == null) {
              sizeAmount_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(sizeAmount_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class TrailModule : pb::IMessage<TrailModule> {
    private static readonly pb::MessageParser<TrailModule> _parser = new pb::MessageParser<TrailModule>(() => new TrailModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TrailModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrailModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrailModule(TrailModule other) : this() {
      enabled_ = other.enabled_;
      ratio_ = other.ratio_;
      Lifetime = other.lifetime_ != null ? other.Lifetime.Clone() : null;
      lifetimeMultiplier_ = other.lifetimeMultiplier_;
      minVertexDistance_ = other.minVertexDistance_;
      textureMode_ = other.textureMode_;
      worldSpace_ = other.worldSpace_;
      dieWithParticles_ = other.dieWithParticles_;
      sizeAffectsWidth_ = other.sizeAffectsWidth_;
      sizeAffectsLifetime_ = other.sizeAffectsLifetime_;
      inheritParticleColor_ = other.inheritParticleColor_;
      ColorOverLifetime = other.colorOverLifetime_ != null ? other.ColorOverLifetime.Clone() : null;
      WidthOverTrail = other.widthOverTrail_ != null ? other.WidthOverTrail.Clone() : null;
      widthOverTrailMultiplier_ = other.widthOverTrailMultiplier_;
      ColorOverTrail = other.colorOverTrail_ != null ? other.ColorOverTrail.Clone() : null;
      generateLightingData_ = other.generateLightingData_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrailModule Clone() {
      return new TrailModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 100;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "ratio" field.</summary>
    public const int RatioFieldNumber = 1;
    private float ratio_;
    /// <summary>
    ///Choose what proportion of particles will receive a trail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Ratio {
      get { return ratio_; }
      set {
        ratio_ = value;
      }
    }

    /// <summary>Field number for the "lifetime" field.</summary>
    public const int LifetimeFieldNumber = 2;
    private global::ProtoPs.MinMaxCurve lifetime_;
    /// <summary>
    ///     The curve describing the trail lifetime, throughout the lifetime of the particle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Lifetime {
      get { return lifetime_; }
      set {
        lifetime_ = value;
      }
    }

    /// <summary>Field number for the "lifetimeMultiplier" field.</summary>
    public const int LifetimeMultiplierFieldNumber = 3;
    private float lifetimeMultiplier_;
    /// <summary>
    ///     Change the lifetime multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LifetimeMultiplier {
      get { return lifetimeMultiplier_; }
      set {
        lifetimeMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "minVertexDistance" field.</summary>
    public const int MinVertexDistanceFieldNumber = 4;
    private float minVertexDistance_;
    /// <summary>
    /// Set the minimum distance each trail can travel before a new vertex is added to it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinVertexDistance {
      get { return minVertexDistance_; }
      set {
        minVertexDistance_ = value;
      }
    }

    /// <summary>Field number for the "textureMode" field.</summary>
    public const int TextureModeFieldNumber = 5;
    private global::ProtoPs.ParticleSystemTrailTextureMode textureMode_ = 0;
    /// <summary>
    /// Choose whether the U coordinate of the trail texture is tiled or stretched.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemTrailTextureMode TextureMode {
      get { return textureMode_; }
      set {
        textureMode_ = value;
      }
    }

    /// <summary>Field number for the "worldSpace" field.</summary>
    public const int WorldSpaceFieldNumber = 6;
    private bool worldSpace_;
    /// <summary>
    /// Drop new trail points in world space, regardless of Particle System Simulation Space.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool WorldSpace {
      get { return worldSpace_; }
      set {
        worldSpace_ = value;
      }
    }

    /// <summary>Field number for the "dieWithParticles" field.</summary>
    public const int DieWithParticlesFieldNumber = 7;
    private bool dieWithParticles_;
    /// <summary>
    ///If enabled, Trails will disappear immediately when their owning particle dies. Otherwise, the trail will persist until all its points have naturally expired, based on its lifetime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DieWithParticles {
      get { return dieWithParticles_; }
      set {
        dieWithParticles_ = value;
      }
    }

    /// <summary>Field number for the "sizeAffectsWidth" field.</summary>
    public const int SizeAffectsWidthFieldNumber = 8;
    private bool sizeAffectsWidth_;
    /// <summary>
    /// Set whether the particle size will act as a multiplier on top of the trail width.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SizeAffectsWidth {
      get { return sizeAffectsWidth_; }
      set {
        sizeAffectsWidth_ = value;
      }
    }

    /// <summary>Field number for the "sizeAffectsLifetime" field.</summary>
    public const int SizeAffectsLifetimeFieldNumber = 9;
    private bool sizeAffectsLifetime_;
    /// <summary>
    ///     Set whether the particle size will act as a multiplier on top of the trail lifetime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SizeAffectsLifetime {
      get { return sizeAffectsLifetime_; }
      set {
        sizeAffectsLifetime_ = value;
      }
    }

    /// <summary>Field number for the "inheritParticleColor" field.</summary>
    public const int InheritParticleColorFieldNumber = 10;
    private bool inheritParticleColor_;
    /// <summary>
    ///     Toggle whether the trail will inherit the particle color as its starting color.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool InheritParticleColor {
      get { return inheritParticleColor_; }
      set {
        inheritParticleColor_ = value;
      }
    }

    /// <summary>Field number for the "colorOverLifetime" field.</summary>
    public const int ColorOverLifetimeFieldNumber = 11;
    private global::ProtoPs.MinMaxGradient colorOverLifetime_;
    /// <summary>
    ///     The gradient controlling the trail colors during the lifetime of the attached particle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxGradient ColorOverLifetime {
      get { return colorOverLifetime_; }
      set {
        colorOverLifetime_ = value;
      }
    }

    /// <summary>Field number for the "widthOverTrail" field.</summary>
    public const int WidthOverTrailFieldNumber = 12;
    private global::ProtoPs.MinMaxCurve widthOverTrail_;
    /// <summary>
    ///     The curve describing the width, of each trail point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve WidthOverTrail {
      get { return widthOverTrail_; }
      set {
        widthOverTrail_ = value;
      }
    }

    /// <summary>Field number for the "widthOverTrailMultiplier" field.</summary>
    public const int WidthOverTrailMultiplierFieldNumber = 13;
    private float widthOverTrailMultiplier_;
    /// <summary>
    ///     Change the width multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float WidthOverTrailMultiplier {
      get { return widthOverTrailMultiplier_; }
      set {
        widthOverTrailMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "colorOverTrail" field.</summary>
    public const int ColorOverTrailFieldNumber = 14;
    private global::ProtoPs.MinMaxGradient colorOverTrail_;
    /// <summary>
    ///     The gradient controlling the trail colors over the length of the trail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxGradient ColorOverTrail {
      get { return colorOverTrail_; }
      set {
        colorOverTrail_ = value;
      }
    }

    /// <summary>Field number for the "generateLightingData" field.</summary>
    public const int GenerateLightingDataFieldNumber = 15;
    private bool generateLightingData_;
    /// <summary>
    ///     Configures the trails to generate Normals and Tangents. With this data, Scene lighting can affect the trails via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GenerateLightingData {
      get { return generateLightingData_; }
      set {
        generateLightingData_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TrailModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TrailModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (Ratio != other.Ratio) return false;
      if (!object.Equals(Lifetime, other.Lifetime)) return false;
      if (LifetimeMultiplier != other.LifetimeMultiplier) return false;
      if (MinVertexDistance != other.MinVertexDistance) return false;
      if (TextureMode != other.TextureMode) return false;
      if (WorldSpace != other.WorldSpace) return false;
      if (DieWithParticles != other.DieWithParticles) return false;
      if (SizeAffectsWidth != other.SizeAffectsWidth) return false;
      if (SizeAffectsLifetime != other.SizeAffectsLifetime) return false;
      if (InheritParticleColor != other.InheritParticleColor) return false;
      if (!object.Equals(ColorOverLifetime, other.ColorOverLifetime)) return false;
      if (!object.Equals(WidthOverTrail, other.WidthOverTrail)) return false;
      if (WidthOverTrailMultiplier != other.WidthOverTrailMultiplier) return false;
      if (!object.Equals(ColorOverTrail, other.ColorOverTrail)) return false;
      if (GenerateLightingData != other.GenerateLightingData) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (Ratio != 0F) hash ^= Ratio.GetHashCode();
      if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
      if (LifetimeMultiplier != 0F) hash ^= LifetimeMultiplier.GetHashCode();
      if (MinVertexDistance != 0F) hash ^= MinVertexDistance.GetHashCode();
      if (TextureMode != 0) hash ^= TextureMode.GetHashCode();
      if (WorldSpace != false) hash ^= WorldSpace.GetHashCode();
      if (DieWithParticles != false) hash ^= DieWithParticles.GetHashCode();
      if (SizeAffectsWidth != false) hash ^= SizeAffectsWidth.GetHashCode();
      if (SizeAffectsLifetime != false) hash ^= SizeAffectsLifetime.GetHashCode();
      if (InheritParticleColor != false) hash ^= InheritParticleColor.GetHashCode();
      if (colorOverLifetime_ != null) hash ^= ColorOverLifetime.GetHashCode();
      if (widthOverTrail_ != null) hash ^= WidthOverTrail.GetHashCode();
      if (WidthOverTrailMultiplier != 0F) hash ^= WidthOverTrailMultiplier.GetHashCode();
      if (colorOverTrail_ != null) hash ^= ColorOverTrail.GetHashCode();
      if (GenerateLightingData != false) hash ^= GenerateLightingData.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Ratio != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Ratio);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Lifetime);
      }
      if (LifetimeMultiplier != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(LifetimeMultiplier);
      }
      if (MinVertexDistance != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinVertexDistance);
      }
      if (TextureMode != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) TextureMode);
      }
      if (WorldSpace != false) {
        output.WriteRawTag(48);
        output.WriteBool(WorldSpace);
      }
      if (DieWithParticles != false) {
        output.WriteRawTag(56);
        output.WriteBool(DieWithParticles);
      }
      if (SizeAffectsWidth != false) {
        output.WriteRawTag(64);
        output.WriteBool(SizeAffectsWidth);
      }
      if (SizeAffectsLifetime != false) {
        output.WriteRawTag(72);
        output.WriteBool(SizeAffectsLifetime);
      }
      if (InheritParticleColor != false) {
        output.WriteRawTag(80);
        output.WriteBool(InheritParticleColor);
      }
      if (colorOverLifetime_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ColorOverLifetime);
      }
      if (widthOverTrail_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(WidthOverTrail);
      }
      if (WidthOverTrailMultiplier != 0F) {
        output.WriteRawTag(109);
        output.WriteFloat(WidthOverTrailMultiplier);
      }
      if (colorOverTrail_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(ColorOverTrail);
      }
      if (GenerateLightingData != false) {
        output.WriteRawTag(120);
        output.WriteBool(GenerateLightingData);
      }
      if (Enabled != false) {
        output.WriteRawTag(160, 6);
        output.WriteBool(Enabled);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 2 + 1;
      }
      if (Ratio != 0F) {
        size += 1 + 4;
      }
      if (lifetime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
      }
      if (LifetimeMultiplier != 0F) {
        size += 1 + 4;
      }
      if (MinVertexDistance != 0F) {
        size += 1 + 4;
      }
      if (TextureMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TextureMode);
      }
      if (WorldSpace != false) {
        size += 1 + 1;
      }
      if (DieWithParticles != false) {
        size += 1 + 1;
      }
      if (SizeAffectsWidth != false) {
        size += 1 + 1;
      }
      if (SizeAffectsLifetime != false) {
        size += 1 + 1;
      }
      if (InheritParticleColor != false) {
        size += 1 + 1;
      }
      if (colorOverLifetime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorOverLifetime);
      }
      if (widthOverTrail_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WidthOverTrail);
      }
      if (WidthOverTrailMultiplier != 0F) {
        size += 1 + 4;
      }
      if (colorOverTrail_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorOverTrail);
      }
      if (GenerateLightingData != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TrailModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.Ratio != 0F) {
        Ratio = other.Ratio;
      }
      if (other.lifetime_ != null) {
        if (lifetime_ == null) {
          lifetime_ = new global::ProtoPs.MinMaxCurve();
        }
        Lifetime.MergeFrom(other.Lifetime);
      }
      if (other.LifetimeMultiplier != 0F) {
        LifetimeMultiplier = other.LifetimeMultiplier;
      }
      if (other.MinVertexDistance != 0F) {
        MinVertexDistance = other.MinVertexDistance;
      }
      if (other.TextureMode != 0) {
        TextureMode = other.TextureMode;
      }
      if (other.WorldSpace != false) {
        WorldSpace = other.WorldSpace;
      }
      if (other.DieWithParticles != false) {
        DieWithParticles = other.DieWithParticles;
      }
      if (other.SizeAffectsWidth != false) {
        SizeAffectsWidth = other.SizeAffectsWidth;
      }
      if (other.SizeAffectsLifetime != false) {
        SizeAffectsLifetime = other.SizeAffectsLifetime;
      }
      if (other.InheritParticleColor != false) {
        InheritParticleColor = other.InheritParticleColor;
      }
      if (other.colorOverLifetime_ != null) {
        if (colorOverLifetime_ == null) {
          colorOverLifetime_ = new global::ProtoPs.MinMaxGradient();
        }
        ColorOverLifetime.MergeFrom(other.ColorOverLifetime);
      }
      if (other.widthOverTrail_ != null) {
        if (widthOverTrail_ == null) {
          widthOverTrail_ = new global::ProtoPs.MinMaxCurve();
        }
        WidthOverTrail.MergeFrom(other.WidthOverTrail);
      }
      if (other.WidthOverTrailMultiplier != 0F) {
        WidthOverTrailMultiplier = other.WidthOverTrailMultiplier;
      }
      if (other.colorOverTrail_ != null) {
        if (colorOverTrail_ == null) {
          colorOverTrail_ = new global::ProtoPs.MinMaxGradient();
        }
        ColorOverTrail.MergeFrom(other.ColorOverTrail);
      }
      if (other.GenerateLightingData != false) {
        GenerateLightingData = other.GenerateLightingData;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            Ratio = input.ReadFloat();
            break;
          }
          case 18: {
            if (lifetime_ == null) {
              lifetime_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(lifetime_);
            break;
          }
          case 29: {
            LifetimeMultiplier = input.ReadFloat();
            break;
          }
          case 37: {
            MinVertexDistance = input.ReadFloat();
            break;
          }
          case 40: {
            textureMode_ = (global::ProtoPs.ParticleSystemTrailTextureMode) input.ReadEnum();
            break;
          }
          case 48: {
            WorldSpace = input.ReadBool();
            break;
          }
          case 56: {
            DieWithParticles = input.ReadBool();
            break;
          }
          case 64: {
            SizeAffectsWidth = input.ReadBool();
            break;
          }
          case 72: {
            SizeAffectsLifetime = input.ReadBool();
            break;
          }
          case 80: {
            InheritParticleColor = input.ReadBool();
            break;
          }
          case 90: {
            if (colorOverLifetime_ == null) {
              colorOverLifetime_ = new global::ProtoPs.MinMaxGradient();
            }
            input.ReadMessage(colorOverLifetime_);
            break;
          }
          case 98: {
            if (widthOverTrail_ == null) {
              widthOverTrail_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(widthOverTrail_);
            break;
          }
          case 109: {
            WidthOverTrailMultiplier = input.ReadFloat();
            break;
          }
          case 114: {
            if (colorOverTrail_ == null) {
              colorOverTrail_ = new global::ProtoPs.MinMaxGradient();
            }
            input.ReadMessage(colorOverTrail_);
            break;
          }
          case 120: {
            GenerateLightingData = input.ReadBool();
            break;
          }
          case 800: {
            Enabled = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class TriggerModule : pb::IMessage<TriggerModule> {
    private static readonly pb::MessageParser<TriggerModule> _parser = new pb::MessageParser<TriggerModule>(() => new TriggerModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TriggerModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriggerModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriggerModule(TriggerModule other) : this() {
      enabled_ = other.enabled_;
      inside_ = other.inside_;
      outside_ = other.outside_;
      enter_ = other.enter_;
      exit_ = other.exit_;
      radiusScale_ = other.radiusScale_;
      maxColliderCount_ = other.maxColliderCount_;
      colliders_ = other.colliders_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriggerModule Clone() {
      return new TriggerModule(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "inside" field.</summary>
    public const int InsideFieldNumber = 2;
    private global::ProtoPs.ParticleSystemOverlapAction inside_ = 0;
    /// <summary>
    ///     Choose what action to perform when particles are inside the trigger volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemOverlapAction Inside {
      get { return inside_; }
      set {
        inside_ = value;
      }
    }

    /// <summary>Field number for the "outside" field.</summary>
    public const int OutsideFieldNumber = 3;
    private global::ProtoPs.ParticleSystemOverlapAction outside_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemOverlapAction Outside {
      get { return outside_; }
      set {
        outside_ = value;
      }
    }

    /// <summary>Field number for the "enter" field.</summary>
    public const int EnterFieldNumber = 4;
    private global::ProtoPs.ParticleSystemOverlapAction enter_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemOverlapAction Enter {
      get { return enter_; }
      set {
        enter_ = value;
      }
    }

    /// <summary>Field number for the "exit" field.</summary>
    public const int ExitFieldNumber = 5;
    private global::ProtoPs.ParticleSystemOverlapAction exit_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemOverlapAction Exit {
      get { return exit_; }
      set {
        exit_ = value;
      }
    }

    /// <summary>Field number for the "radiusScale" field.</summary>
    public const int RadiusScaleFieldNumber = 6;
    private float radiusScale_;
    /// <summary>
    ///     A multiplier applied to the size of each particle before overlaps are processed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RadiusScale {
      get { return radiusScale_; }
      set {
        radiusScale_ = value;
      }
    }

    /// <summary>Field number for the "maxColliderCount" field.</summary>
    public const int MaxColliderCountFieldNumber = 7;
    private int maxColliderCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxColliderCount {
      get { return maxColliderCount_; }
      set {
        maxColliderCount_ = value;
      }
    }

    /// <summary>Field number for the "colliders" field.</summary>
    public const int CollidersFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_colliders_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> colliders_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///repeated proto_world.ColliderBox collider_boxs = 8;
    ///repeated proto_world.ColliderSphere collider_spheres = 9;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Colliders {
      get { return colliders_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TriggerModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TriggerModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (Inside != other.Inside) return false;
      if (Outside != other.Outside) return false;
      if (Enter != other.Enter) return false;
      if (Exit != other.Exit) return false;
      if (RadiusScale != other.RadiusScale) return false;
      if (MaxColliderCount != other.MaxColliderCount) return false;
      if(!colliders_.Equals(other.colliders_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (Inside != 0) hash ^= Inside.GetHashCode();
      if (Outside != 0) hash ^= Outside.GetHashCode();
      if (Enter != 0) hash ^= Enter.GetHashCode();
      if (Exit != 0) hash ^= Exit.GetHashCode();
      if (RadiusScale != 0F) hash ^= RadiusScale.GetHashCode();
      if (MaxColliderCount != 0) hash ^= MaxColliderCount.GetHashCode();
      hash ^= colliders_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (Inside != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Inside);
      }
      if (Outside != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Outside);
      }
      if (Enter != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Enter);
      }
      if (Exit != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Exit);
      }
      if (RadiusScale != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(RadiusScale);
      }
      if (MaxColliderCount != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(MaxColliderCount);
      }
      colliders_.WriteTo(output, _repeated_colliders_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (Inside != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Inside);
      }
      if (Outside != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Outside);
      }
      if (Enter != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Enter);
      }
      if (Exit != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Exit);
      }
      if (RadiusScale != 0F) {
        size += 1 + 4;
      }
      if (MaxColliderCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxColliderCount);
      }
      size += colliders_.CalculateSize(_repeated_colliders_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TriggerModule other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.Inside != 0) {
        Inside = other.Inside;
      }
      if (other.Outside != 0) {
        Outside = other.Outside;
      }
      if (other.Enter != 0) {
        Enter = other.Enter;
      }
      if (other.Exit != 0) {
        Exit = other.Exit;
      }
      if (other.RadiusScale != 0F) {
        RadiusScale = other.RadiusScale;
      }
      if (other.MaxColliderCount != 0) {
        MaxColliderCount = other.MaxColliderCount;
      }
      colliders_.Add(other.colliders_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 16: {
            inside_ = (global::ProtoPs.ParticleSystemOverlapAction) input.ReadEnum();
            break;
          }
          case 24: {
            outside_ = (global::ProtoPs.ParticleSystemOverlapAction) input.ReadEnum();
            break;
          }
          case 32: {
            enter_ = (global::ProtoPs.ParticleSystemOverlapAction) input.ReadEnum();
            break;
          }
          case 40: {
            exit_ = (global::ProtoPs.ParticleSystemOverlapAction) input.ReadEnum();
            break;
          }
          case 53: {
            RadiusScale = input.ReadFloat();
            break;
          }
          case 56: {
            MaxColliderCount = input.ReadInt32();
            break;
          }
          case 66: {
            colliders_.AddEntriesFrom(input, _repeated_colliders_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class CollisionModule : pb::IMessage<CollisionModule> {
    private static readonly pb::MessageParser<CollisionModule> _parser = new pb::MessageParser<CollisionModule>(() => new CollisionModule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CollisionModule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollisionModule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollisionModule(CollisionModule other) : this() {
      maxKillSpeed_ = other.maxKillSpeed_;
      multiplyColliderForceByParticleSpeed_ = other.multiplyColliderForceByParticleSpeed_;
      multiplyColliderForceByCollisionAngle_ = other.multiplyColliderForceByCollisionAngle_;
      colliderForce_ = other.colliderForce_;
      sendCollisionMessages_ = other.sendCollisionMessages_;
      radiusScale_ = other.radiusScale_;
      voxelSize_ = other.voxelSize_;
      quality_ = other.quality_;
      maxCollisionShapes_ = other.maxCollisionShapes_;
      enableDynamicColliders_ = other.enableDynamicColliders_;
      CollidesWith = other.collidesWith_ != null ? other.CollidesWith.Clone() : null;
      maxPlaneCount_ = other.maxPlaneCount_;
      minKillSpeed_ = other.minKillSpeed_;
      lifetimeLossMultiplier_ = other.lifetimeLossMultiplier_;
      LifetimeLoss = other.lifetimeLoss_ != null ? other.LifetimeLoss.Clone() : null;
      bounceMultiplier_ = other.bounceMultiplier_;
      Bounce = other.bounce_ != null ? other.Bounce.Clone() : null;
      dampenMultiplier_ = other.dampenMultiplier_;
      Dampen = other.dampen_ != null ? other.Dampen.Clone() : null;
      mode_ = other.mode_;
      type_ = other.type_;
      enabled_ = other.enabled_;
      multiplyColliderForceByParticleSize_ = other.multiplyColliderForceByParticleSize_;
      planes_ = other.planes_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollisionModule Clone() {
      return new CollisionModule(this);
    }

    /// <summary>Field number for the "maxKillSpeed" field.</summary>
    public const int MaxKillSpeedFieldNumber = 1;
    private float maxKillSpeed_;
    /// <summary>
    ///     Kill particles whose speed goes above this threshold, after a collision.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxKillSpeed {
      get { return maxKillSpeed_; }
      set {
        maxKillSpeed_ = value;
      }
    }

    /// <summary>Field number for the "multiplyColliderForceByParticleSpeed" field.</summary>
    public const int MultiplyColliderForceByParticleSpeedFieldNumber = 2;
    private bool multiplyColliderForceByParticleSpeed_;
    /// <summary>
    ///     If true, particle speeds are considered when applying forces to Colliders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MultiplyColliderForceByParticleSpeed {
      get { return multiplyColliderForceByParticleSpeed_; }
      set {
        multiplyColliderForceByParticleSpeed_ = value;
      }
    }

    /// <summary>Field number for the "multiplyColliderForceByCollisionAngle" field.</summary>
    public const int MultiplyColliderForceByCollisionAngleFieldNumber = 3;
    private bool multiplyColliderForceByCollisionAngle_;
    /// <summary>
    ///     If true, the collision angle is considered when applying forces from particles to Colliders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MultiplyColliderForceByCollisionAngle {
      get { return multiplyColliderForceByCollisionAngle_; }
      set {
        multiplyColliderForceByCollisionAngle_ = value;
      }
    }

    /// <summary>Field number for the "colliderForce" field.</summary>
    public const int ColliderForceFieldNumber = 4;
    private float colliderForce_;
    /// <summary>
    ///     How much force is applied to a Collider when hit by particles from this Particle  System.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ColliderForce {
      get { return colliderForce_; }
      set {
        colliderForce_ = value;
      }
    }

    /// <summary>Field number for the "sendCollisionMessages" field.</summary>
    public const int SendCollisionMessagesFieldNumber = 5;
    private bool sendCollisionMessages_;
    /// <summary>
    ///     Send collision callback messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SendCollisionMessages {
      get { return sendCollisionMessages_; }
      set {
        sendCollisionMessages_ = value;
      }
    }

    /// <summary>Field number for the "radiusScale" field.</summary>
    public const int RadiusScaleFieldNumber = 6;
    private float radiusScale_;
    /// <summary>
    ///     A multiplier applied to the size of each particle before collisions are processed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RadiusScale {
      get { return radiusScale_; }
      set {
        radiusScale_ = value;
      }
    }

    /// <summary>Field number for the "voxelSize" field.</summary>
    public const int VoxelSizeFieldNumber = 7;
    private float voxelSize_;
    /// <summary>
    ///     Size of voxels in the collision cache.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float VoxelSize {
      get { return voxelSize_; }
      set {
        voxelSize_ = value;
      }
    }

    /// <summary>Field number for the "quality" field.</summary>
    public const int QualityFieldNumber = 8;
    private global::ProtoPs.ParticleSystemCollisionQuality quality_ = 0;
    /// <summary>
    ///     Specifies the accuracy of particle collisions against colliders in the scene.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemCollisionQuality Quality {
      get { return quality_; }
      set {
        quality_ = value;
      }
    }

    /// <summary>Field number for the "maxCollisionShapes" field.</summary>
    public const int MaxCollisionShapesFieldNumber = 9;
    private int maxCollisionShapes_;
    /// <summary>
    ///     The maximum number of collision shapes that will be considered for particle collisions.
    ///     Excess shapes will be ignored. Terrains take priority.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxCollisionShapes {
      get { return maxCollisionShapes_; }
      set {
        maxCollisionShapes_ = value;
      }
    }

    /// <summary>Field number for the "enableDynamicColliders" field.</summary>
    public const int EnableDynamicCollidersFieldNumber = 10;
    private bool enableDynamicColliders_;
    /// <summary>
    ///     Allow particles to collide when inside colliders.
    ///[Obsolete("enableInteriorCollisions property is deprecated and is no longer required and has no effect on the particle system.")]
    ///            public bool enableInteriorCollisions { get; set; }
    ///     Allow particles to collide with dynamic colliders when using world collision mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableDynamicColliders {
      get { return enableDynamicColliders_; }
      set {
        enableDynamicColliders_ = value;
      }
    }

    /// <summary>Field number for the "collidesWith" field.</summary>
    public const int CollidesWithFieldNumber = 11;
    private global::ProtoPs.LayerMask collidesWith_;
    /// <summary>
    ///     Control which layers this particle system collides with.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.LayerMask CollidesWith {
      get { return collidesWith_; }
      set {
        collidesWith_ = value;
      }
    }

    /// <summary>Field number for the "maxPlaneCount" field.</summary>
    public const int MaxPlaneCountFieldNumber = 12;
    private int maxPlaneCount_;
    /// <summary>
    ///     The maximum number of planes it is possible to set as colliders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxPlaneCount {
      get { return maxPlaneCount_; }
      set {
        maxPlaneCount_ = value;
      }
    }

    /// <summary>Field number for the "minKillSpeed" field.</summary>
    public const int MinKillSpeedFieldNumber = 13;
    private float minKillSpeed_;
    /// <summary>
    ///     Kill particles whose speed falls below this threshold, after a collision.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinKillSpeed {
      get { return minKillSpeed_; }
      set {
        minKillSpeed_ = value;
      }
    }

    /// <summary>Field number for the "lifetimeLossMultiplier" field.</summary>
    public const int LifetimeLossMultiplierFieldNumber = 14;
    private float lifetimeLossMultiplier_;
    /// <summary>
    ///     Change the lifetime loss multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LifetimeLossMultiplier {
      get { return lifetimeLossMultiplier_; }
      set {
        lifetimeLossMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "lifetimeLoss" field.</summary>
    public const int LifetimeLossFieldNumber = 15;
    private global::ProtoPs.MinMaxCurve lifetimeLoss_;
    /// <summary>
    ///     How much a particle's lifetime is reduced after a collision.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve LifetimeLoss {
      get { return lifetimeLoss_; }
      set {
        lifetimeLoss_ = value;
      }
    }

    /// <summary>Field number for the "bounceMultiplier" field.</summary>
    public const int BounceMultiplierFieldNumber = 16;
    private float bounceMultiplier_;
    /// <summary>
    ///     Change the bounce multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float BounceMultiplier {
      get { return bounceMultiplier_; }
      set {
        bounceMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "bounce" field.</summary>
    public const int BounceFieldNumber = 17;
    private global::ProtoPs.MinMaxCurve bounce_;
    /// <summary>
    ///     How much force is applied to each particle after a collision.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Bounce {
      get { return bounce_; }
      set {
        bounce_ = value;
      }
    }

    /// <summary>Field number for the "dampenMultiplier" field.</summary>
    public const int DampenMultiplierFieldNumber = 18;
    private float dampenMultiplier_;
    /// <summary>
    ///     Change the dampen multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DampenMultiplier {
      get { return dampenMultiplier_; }
      set {
        dampenMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "dampen" field.</summary>
    public const int DampenFieldNumber = 19;
    private global::ProtoPs.MinMaxCurve dampen_;
    /// <summary>
    ///     How much speed is lost from each particle after a collision.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Dampen {
      get { return dampen_; }
      set {
        dampen_ = value;
      }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 20;
    private global::ProtoPs.ParticleSystemCollisionMode mode_ = 0;
    /// <summary>
    ///     Choose between 2D and 3D world collisions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemCollisionMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 21;
    private global::ProtoPs.ParticleSystemCollisionType type_ = 0;
    /// <summary>
    ///     The type of particle collision to perform.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemCollisionType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 22;
    private bool enabled_;
    /// <summary>
    ///     Enable/disable the Collision module.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "multiplyColliderForceByParticleSize" field.</summary>
    public const int MultiplyColliderForceByParticleSizeFieldNumber = 23;
    private bool multiplyColliderForceByParticleSize_;
    /// <summary>
    ///     If true, particle sizes are considered when applying forces to Colliders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MultiplyColliderForceByParticleSize {
      get { return multiplyColliderForceByParticleSize_; }
      set {
        multiplyColliderForceByParticleSize_ = value;
      }
    }

    /// <summary>Field number for the "planes" field.</summary>
    public const int PlanesFieldNumber = 24;
    private static readonly pb::FieldCodec<string> _repeated_planes_codec
        = pb::FieldCodec.ForString(194);
    private readonly pbc::RepeatedField<string> planes_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Planes {
      get { return planes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CollisionModule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CollisionModule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxKillSpeed != other.MaxKillSpeed) return false;
      if (MultiplyColliderForceByParticleSpeed != other.MultiplyColliderForceByParticleSpeed) return false;
      if (MultiplyColliderForceByCollisionAngle != other.MultiplyColliderForceByCollisionAngle) return false;
      if (ColliderForce != other.ColliderForce) return false;
      if (SendCollisionMessages != other.SendCollisionMessages) return false;
      if (RadiusScale != other.RadiusScale) return false;
      if (VoxelSize != other.VoxelSize) return false;
      if (Quality != other.Quality) return false;
      if (MaxCollisionShapes != other.MaxCollisionShapes) return false;
      if (EnableDynamicColliders != other.EnableDynamicColliders) return false;
      if (!object.Equals(CollidesWith, other.CollidesWith)) return false;
      if (MaxPlaneCount != other.MaxPlaneCount) return false;
      if (MinKillSpeed != other.MinKillSpeed) return false;
      if (LifetimeLossMultiplier != other.LifetimeLossMultiplier) return false;
      if (!object.Equals(LifetimeLoss, other.LifetimeLoss)) return false;
      if (BounceMultiplier != other.BounceMultiplier) return false;
      if (!object.Equals(Bounce, other.Bounce)) return false;
      if (DampenMultiplier != other.DampenMultiplier) return false;
      if (!object.Equals(Dampen, other.Dampen)) return false;
      if (Mode != other.Mode) return false;
      if (Type != other.Type) return false;
      if (Enabled != other.Enabled) return false;
      if (MultiplyColliderForceByParticleSize != other.MultiplyColliderForceByParticleSize) return false;
      if(!planes_.Equals(other.planes_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxKillSpeed != 0F) hash ^= MaxKillSpeed.GetHashCode();
      if (MultiplyColliderForceByParticleSpeed != false) hash ^= MultiplyColliderForceByParticleSpeed.GetHashCode();
      if (MultiplyColliderForceByCollisionAngle != false) hash ^= MultiplyColliderForceByCollisionAngle.GetHashCode();
      if (ColliderForce != 0F) hash ^= ColliderForce.GetHashCode();
      if (SendCollisionMessages != false) hash ^= SendCollisionMessages.GetHashCode();
      if (RadiusScale != 0F) hash ^= RadiusScale.GetHashCode();
      if (VoxelSize != 0F) hash ^= VoxelSize.GetHashCode();
      if (Quality != 0) hash ^= Quality.GetHashCode();
      if (MaxCollisionShapes != 0) hash ^= MaxCollisionShapes.GetHashCode();
      if (EnableDynamicColliders != false) hash ^= EnableDynamicColliders.GetHashCode();
      if (collidesWith_ != null) hash ^= CollidesWith.GetHashCode();
      if (MaxPlaneCount != 0) hash ^= MaxPlaneCount.GetHashCode();
      if (MinKillSpeed != 0F) hash ^= MinKillSpeed.GetHashCode();
      if (LifetimeLossMultiplier != 0F) hash ^= LifetimeLossMultiplier.GetHashCode();
      if (lifetimeLoss_ != null) hash ^= LifetimeLoss.GetHashCode();
      if (BounceMultiplier != 0F) hash ^= BounceMultiplier.GetHashCode();
      if (bounce_ != null) hash ^= Bounce.GetHashCode();
      if (DampenMultiplier != 0F) hash ^= DampenMultiplier.GetHashCode();
      if (dampen_ != null) hash ^= Dampen.GetHashCode();
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (MultiplyColliderForceByParticleSize != false) hash ^= MultiplyColliderForceByParticleSize.GetHashCode();
      hash ^= planes_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxKillSpeed != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MaxKillSpeed);
      }
      if (MultiplyColliderForceByParticleSpeed != false) {
        output.WriteRawTag(16);
        output.WriteBool(MultiplyColliderForceByParticleSpeed);
      }
      if (MultiplyColliderForceByCollisionAngle != false) {
        output.WriteRawTag(24);
        output.WriteBool(MultiplyColliderForceByCollisionAngle);
      }
      if (ColliderForce != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(ColliderForce);
      }
      if (SendCollisionMessages != false) {
        output.WriteRawTag(40);
        output.WriteBool(SendCollisionMessages);
      }
      if (RadiusScale != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(RadiusScale);
      }
      if (VoxelSize != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(VoxelSize);
      }
      if (Quality != 0) {
        output.WriteRawTag(64);
        output.WriteEnum((int) Quality);
      }
      if (MaxCollisionShapes != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(MaxCollisionShapes);
      }
      if (EnableDynamicColliders != false) {
        output.WriteRawTag(80);
        output.WriteBool(EnableDynamicColliders);
      }
      if (collidesWith_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(CollidesWith);
      }
      if (MaxPlaneCount != 0) {
        output.WriteRawTag(96);
        output.WriteInt32(MaxPlaneCount);
      }
      if (MinKillSpeed != 0F) {
        output.WriteRawTag(109);
        output.WriteFloat(MinKillSpeed);
      }
      if (LifetimeLossMultiplier != 0F) {
        output.WriteRawTag(117);
        output.WriteFloat(LifetimeLossMultiplier);
      }
      if (lifetimeLoss_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(LifetimeLoss);
      }
      if (BounceMultiplier != 0F) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(BounceMultiplier);
      }
      if (bounce_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Bounce);
      }
      if (DampenMultiplier != 0F) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(DampenMultiplier);
      }
      if (dampen_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(Dampen);
      }
      if (Mode != 0) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) Mode);
      }
      if (Type != 0) {
        output.WriteRawTag(168, 1);
        output.WriteEnum((int) Type);
      }
      if (Enabled != false) {
        output.WriteRawTag(176, 1);
        output.WriteBool(Enabled);
      }
      if (MultiplyColliderForceByParticleSize != false) {
        output.WriteRawTag(184, 1);
        output.WriteBool(MultiplyColliderForceByParticleSize);
      }
      planes_.WriteTo(output, _repeated_planes_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxKillSpeed != 0F) {
        size += 1 + 4;
      }
      if (MultiplyColliderForceByParticleSpeed != false) {
        size += 1 + 1;
      }
      if (MultiplyColliderForceByCollisionAngle != false) {
        size += 1 + 1;
      }
      if (ColliderForce != 0F) {
        size += 1 + 4;
      }
      if (SendCollisionMessages != false) {
        size += 1 + 1;
      }
      if (RadiusScale != 0F) {
        size += 1 + 4;
      }
      if (VoxelSize != 0F) {
        size += 1 + 4;
      }
      if (Quality != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Quality);
      }
      if (MaxCollisionShapes != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxCollisionShapes);
      }
      if (EnableDynamicColliders != false) {
        size += 1 + 1;
      }
      if (collidesWith_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CollidesWith);
      }
      if (MaxPlaneCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxPlaneCount);
      }
      if (MinKillSpeed != 0F) {
        size += 1 + 4;
      }
      if (LifetimeLossMultiplier != 0F) {
        size += 1 + 4;
      }
      if (lifetimeLoss_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LifetimeLoss);
      }
      if (BounceMultiplier != 0F) {
        size += 2 + 4;
      }
      if (bounce_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Bounce);
      }
      if (DampenMultiplier != 0F) {
        size += 2 + 4;
      }
      if (dampen_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Dampen);
      }
      if (Mode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (Type != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Enabled != false) {
        size += 2 + 1;
      }
      if (MultiplyColliderForceByParticleSize != false) {
        size += 2 + 1;
      }
      size += planes_.CalculateSize(_repeated_planes_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CollisionModule other) {
      if (other == null) {
        return;
      }
      if (other.MaxKillSpeed != 0F) {
        MaxKillSpeed = other.MaxKillSpeed;
      }
      if (other.MultiplyColliderForceByParticleSpeed != false) {
        MultiplyColliderForceByParticleSpeed = other.MultiplyColliderForceByParticleSpeed;
      }
      if (other.MultiplyColliderForceByCollisionAngle != false) {
        MultiplyColliderForceByCollisionAngle = other.MultiplyColliderForceByCollisionAngle;
      }
      if (other.ColliderForce != 0F) {
        ColliderForce = other.ColliderForce;
      }
      if (other.SendCollisionMessages != false) {
        SendCollisionMessages = other.SendCollisionMessages;
      }
      if (other.RadiusScale != 0F) {
        RadiusScale = other.RadiusScale;
      }
      if (other.VoxelSize != 0F) {
        VoxelSize = other.VoxelSize;
      }
      if (other.Quality != 0) {
        Quality = other.Quality;
      }
      if (other.MaxCollisionShapes != 0) {
        MaxCollisionShapes = other.MaxCollisionShapes;
      }
      if (other.EnableDynamicColliders != false) {
        EnableDynamicColliders = other.EnableDynamicColliders;
      }
      if (other.collidesWith_ != null) {
        if (collidesWith_ == null) {
          collidesWith_ = new global::ProtoPs.LayerMask();
        }
        CollidesWith.MergeFrom(other.CollidesWith);
      }
      if (other.MaxPlaneCount != 0) {
        MaxPlaneCount = other.MaxPlaneCount;
      }
      if (other.MinKillSpeed != 0F) {
        MinKillSpeed = other.MinKillSpeed;
      }
      if (other.LifetimeLossMultiplier != 0F) {
        LifetimeLossMultiplier = other.LifetimeLossMultiplier;
      }
      if (other.lifetimeLoss_ != null) {
        if (lifetimeLoss_ == null) {
          lifetimeLoss_ = new global::ProtoPs.MinMaxCurve();
        }
        LifetimeLoss.MergeFrom(other.LifetimeLoss);
      }
      if (other.BounceMultiplier != 0F) {
        BounceMultiplier = other.BounceMultiplier;
      }
      if (other.bounce_ != null) {
        if (bounce_ == null) {
          bounce_ = new global::ProtoPs.MinMaxCurve();
        }
        Bounce.MergeFrom(other.Bounce);
      }
      if (other.DampenMultiplier != 0F) {
        DampenMultiplier = other.DampenMultiplier;
      }
      if (other.dampen_ != null) {
        if (dampen_ == null) {
          dampen_ = new global::ProtoPs.MinMaxCurve();
        }
        Dampen.MergeFrom(other.Dampen);
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.MultiplyColliderForceByParticleSize != false) {
        MultiplyColliderForceByParticleSize = other.MultiplyColliderForceByParticleSize;
      }
      planes_.Add(other.planes_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            MaxKillSpeed = input.ReadFloat();
            break;
          }
          case 16: {
            MultiplyColliderForceByParticleSpeed = input.ReadBool();
            break;
          }
          case 24: {
            MultiplyColliderForceByCollisionAngle = input.ReadBool();
            break;
          }
          case 37: {
            ColliderForce = input.ReadFloat();
            break;
          }
          case 40: {
            SendCollisionMessages = input.ReadBool();
            break;
          }
          case 53: {
            RadiusScale = input.ReadFloat();
            break;
          }
          case 61: {
            VoxelSize = input.ReadFloat();
            break;
          }
          case 64: {
            quality_ = (global::ProtoPs.ParticleSystemCollisionQuality) input.ReadEnum();
            break;
          }
          case 72: {
            MaxCollisionShapes = input.ReadInt32();
            break;
          }
          case 80: {
            EnableDynamicColliders = input.ReadBool();
            break;
          }
          case 90: {
            if (collidesWith_ == null) {
              collidesWith_ = new global::ProtoPs.LayerMask();
            }
            input.ReadMessage(collidesWith_);
            break;
          }
          case 96: {
            MaxPlaneCount = input.ReadInt32();
            break;
          }
          case 109: {
            MinKillSpeed = input.ReadFloat();
            break;
          }
          case 117: {
            LifetimeLossMultiplier = input.ReadFloat();
            break;
          }
          case 122: {
            if (lifetimeLoss_ == null) {
              lifetimeLoss_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(lifetimeLoss_);
            break;
          }
          case 133: {
            BounceMultiplier = input.ReadFloat();
            break;
          }
          case 138: {
            if (bounce_ == null) {
              bounce_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(bounce_);
            break;
          }
          case 149: {
            DampenMultiplier = input.ReadFloat();
            break;
          }
          case 154: {
            if (dampen_ == null) {
              dampen_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(dampen_);
            break;
          }
          case 160: {
            mode_ = (global::ProtoPs.ParticleSystemCollisionMode) input.ReadEnum();
            break;
          }
          case 168: {
            type_ = (global::ProtoPs.ParticleSystemCollisionType) input.ReadEnum();
            break;
          }
          case 176: {
            Enabled = input.ReadBool();
            break;
          }
          case 184: {
            MultiplyColliderForceByParticleSize = input.ReadBool();
            break;
          }
          case 194: {
            planes_.AddEntriesFrom(input, _repeated_planes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ParticleSystem : pb::IMessage<ParticleSystem> {
    private static readonly pb::MessageParser<ParticleSystem> _parser = new pb::MessageParser<ParticleSystem>(() => new ParticleSystem());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ParticleSystem> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParticleSystem() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParticleSystem(ParticleSystem other) : this() {
      parentPS_ = other.parentPS_;
      Renderer = other.renderer_ != null ? other.Renderer.Clone() : null;
      Main = other.main_ != null ? other.Main.Clone() : null;
      Emission = other.emission_ != null ? other.Emission.Clone() : null;
      Shape = other.shape_ != null ? other.Shape.Clone() : null;
      VelocityOverLifetime = other.velocityOverLifetime_ != null ? other.VelocityOverLifetime.Clone() : null;
      LimitVelocityOverLifetime = other.limitVelocityOverLifetime_ != null ? other.LimitVelocityOverLifetime.Clone() : null;
      InheritVelocity = other.inheritVelocity_ != null ? other.InheritVelocity.Clone() : null;
      ForceOverLifetime = other.forceOverLifetime_ != null ? other.ForceOverLifetime.Clone() : null;
      Trails = other.trails_ != null ? other.Trails.Clone() : null;
      TextureSheetAnimation = other.textureSheetAnimation_ != null ? other.TextureSheetAnimation.Clone() : null;
      SubEmitters = other.subEmitters_ != null ? other.SubEmitters.Clone() : null;
      Trigger = other.trigger_ != null ? other.Trigger.Clone() : null;
      Collision = other.collision_ != null ? other.Collision.Clone() : null;
      Noise = other.noise_ != null ? other.Noise.Clone() : null;
      ExternalForces = other.externalForces_ != null ? other.ExternalForces.Clone() : null;
      RotationBySpeed = other.rotationBySpeed_ != null ? other.RotationBySpeed.Clone() : null;
      RotationOverLifetime = other.rotationOverLifetime_ != null ? other.RotationOverLifetime.Clone() : null;
      SizeBySpeed = other.sizeBySpeed_ != null ? other.SizeBySpeed.Clone() : null;
      SizeOverLifetime = other.sizeOverLifetime_ != null ? other.SizeOverLifetime.Clone() : null;
      ColorBySpeed = other.colorBySpeed_ != null ? other.ColorBySpeed.Clone() : null;
      ColorOverLifetime = other.colorOverLifetime_ != null ? other.ColorOverLifetime.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParticleSystem Clone() {
      return new ParticleSystem(this);
    }

    /// <summary>Field number for the "parentPS" field.</summary>
    public const int ParentPSFieldNumber = 1;
    private string parentPS_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ParentPS {
      get { return parentPS_; }
      set {
        parentPS_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "renderer" field.</summary>
    public const int RendererFieldNumber = 100;
    private global::ProtoPs.ParticleSystemRenderer renderer_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemRenderer Renderer {
      get { return renderer_; }
      set {
        renderer_ = value;
      }
    }

    /// <summary>Field number for the "main" field.</summary>
    public const int MainFieldNumber = 101;
    private global::ProtoPs.MainModule main_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MainModule Main {
      get { return main_; }
      set {
        main_ = value;
      }
    }

    /// <summary>Field number for the "emission" field.</summary>
    public const int EmissionFieldNumber = 102;
    private global::ProtoPs.EmissionModule emission_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.EmissionModule Emission {
      get { return emission_; }
      set {
        emission_ = value;
      }
    }

    /// <summary>Field number for the "shape" field.</summary>
    public const int ShapeFieldNumber = 103;
    private global::ProtoPs.ShapeModule shape_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ShapeModule Shape {
      get { return shape_; }
      set {
        shape_ = value;
      }
    }

    /// <summary>Field number for the "velocityOverLifetime" field.</summary>
    public const int VelocityOverLifetimeFieldNumber = 104;
    private global::ProtoPs.VelocityOverLifetimeModule velocityOverLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.VelocityOverLifetimeModule VelocityOverLifetime {
      get { return velocityOverLifetime_; }
      set {
        velocityOverLifetime_ = value;
      }
    }

    /// <summary>Field number for the "limitVelocityOverLifetime" field.</summary>
    public const int LimitVelocityOverLifetimeFieldNumber = 105;
    private global::ProtoPs.LimitVelocityOverLifetimeModule limitVelocityOverLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.LimitVelocityOverLifetimeModule LimitVelocityOverLifetime {
      get { return limitVelocityOverLifetime_; }
      set {
        limitVelocityOverLifetime_ = value;
      }
    }

    /// <summary>Field number for the "inheritVelocity" field.</summary>
    public const int InheritVelocityFieldNumber = 106;
    private global::ProtoPs.InheritVelocityModule inheritVelocity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.InheritVelocityModule InheritVelocity {
      get { return inheritVelocity_; }
      set {
        inheritVelocity_ = value;
      }
    }

    /// <summary>Field number for the "forceOverLifetime" field.</summary>
    public const int ForceOverLifetimeFieldNumber = 107;
    private global::ProtoPs.ForceOverLifetimeModule forceOverLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ForceOverLifetimeModule ForceOverLifetime {
      get { return forceOverLifetime_; }
      set {
        forceOverLifetime_ = value;
      }
    }

    /// <summary>Field number for the "trails" field.</summary>
    public const int TrailsFieldNumber = 109;
    private global::ProtoPs.TrailModule trails_;
    /// <summary>
    ///CustomDataModule customData=108;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.TrailModule Trails {
      get { return trails_; }
      set {
        trails_ = value;
      }
    }

    /// <summary>Field number for the "textureSheetAnimation" field.</summary>
    public const int TextureSheetAnimationFieldNumber = 111;
    private global::ProtoPs.TextureSheetAnimationModule textureSheetAnimation_;
    /// <summary>
    ///LightsModule lights=110;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.TextureSheetAnimationModule TextureSheetAnimation {
      get { return textureSheetAnimation_; }
      set {
        textureSheetAnimation_ = value;
      }
    }

    /// <summary>Field number for the "subEmitters" field.</summary>
    public const int SubEmittersFieldNumber = 112;
    private global::ProtoPs.SubEmittersModule subEmitters_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.SubEmittersModule SubEmitters {
      get { return subEmitters_; }
      set {
        subEmitters_ = value;
      }
    }

    /// <summary>Field number for the "trigger" field.</summary>
    public const int TriggerFieldNumber = 113;
    private global::ProtoPs.TriggerModule trigger_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.TriggerModule Trigger {
      get { return trigger_; }
      set {
        trigger_ = value;
      }
    }

    /// <summary>Field number for the "collision" field.</summary>
    public const int CollisionFieldNumber = 114;
    private global::ProtoPs.CollisionModule collision_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.CollisionModule Collision {
      get { return collision_; }
      set {
        collision_ = value;
      }
    }

    /// <summary>Field number for the "noise" field.</summary>
    public const int NoiseFieldNumber = 115;
    private global::ProtoPs.NoiseModule noise_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.NoiseModule Noise {
      get { return noise_; }
      set {
        noise_ = value;
      }
    }

    /// <summary>Field number for the "externalForces" field.</summary>
    public const int ExternalForcesFieldNumber = 116;
    private global::ProtoPs.ExternalForcesModule externalForces_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ExternalForcesModule ExternalForces {
      get { return externalForces_; }
      set {
        externalForces_ = value;
      }
    }

    /// <summary>Field number for the "rotationBySpeed" field.</summary>
    public const int RotationBySpeedFieldNumber = 117;
    private global::ProtoPs.RotationBySpeedModule rotationBySpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.RotationBySpeedModule RotationBySpeed {
      get { return rotationBySpeed_; }
      set {
        rotationBySpeed_ = value;
      }
    }

    /// <summary>Field number for the "rotationOverLifetime" field.</summary>
    public const int RotationOverLifetimeFieldNumber = 118;
    private global::ProtoPs.RotationOverLifetimeModule rotationOverLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.RotationOverLifetimeModule RotationOverLifetime {
      get { return rotationOverLifetime_; }
      set {
        rotationOverLifetime_ = value;
      }
    }

    /// <summary>Field number for the "sizeBySpeed" field.</summary>
    public const int SizeBySpeedFieldNumber = 119;
    private global::ProtoPs.SizeBySpeedModule sizeBySpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.SizeBySpeedModule SizeBySpeed {
      get { return sizeBySpeed_; }
      set {
        sizeBySpeed_ = value;
      }
    }

    /// <summary>Field number for the "sizeOverLifetime" field.</summary>
    public const int SizeOverLifetimeFieldNumber = 120;
    private global::ProtoPs.SizeOverLifetimeModule sizeOverLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.SizeOverLifetimeModule SizeOverLifetime {
      get { return sizeOverLifetime_; }
      set {
        sizeOverLifetime_ = value;
      }
    }

    /// <summary>Field number for the "colorBySpeed" field.</summary>
    public const int ColorBySpeedFieldNumber = 121;
    private global::ProtoPs.ColorBySpeedModule colorBySpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ColorBySpeedModule ColorBySpeed {
      get { return colorBySpeed_; }
      set {
        colorBySpeed_ = value;
      }
    }

    /// <summary>Field number for the "colorOverLifetime" field.</summary>
    public const int ColorOverLifetimeFieldNumber = 122;
    private global::ProtoPs.ColorOverLifetimeModule colorOverLifetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ColorOverLifetimeModule ColorOverLifetime {
      get { return colorOverLifetime_; }
      set {
        colorOverLifetime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ParticleSystem);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ParticleSystem other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ParentPS != other.ParentPS) return false;
      if (!object.Equals(Renderer, other.Renderer)) return false;
      if (!object.Equals(Main, other.Main)) return false;
      if (!object.Equals(Emission, other.Emission)) return false;
      if (!object.Equals(Shape, other.Shape)) return false;
      if (!object.Equals(VelocityOverLifetime, other.VelocityOverLifetime)) return false;
      if (!object.Equals(LimitVelocityOverLifetime, other.LimitVelocityOverLifetime)) return false;
      if (!object.Equals(InheritVelocity, other.InheritVelocity)) return false;
      if (!object.Equals(ForceOverLifetime, other.ForceOverLifetime)) return false;
      if (!object.Equals(Trails, other.Trails)) return false;
      if (!object.Equals(TextureSheetAnimation, other.TextureSheetAnimation)) return false;
      if (!object.Equals(SubEmitters, other.SubEmitters)) return false;
      if (!object.Equals(Trigger, other.Trigger)) return false;
      if (!object.Equals(Collision, other.Collision)) return false;
      if (!object.Equals(Noise, other.Noise)) return false;
      if (!object.Equals(ExternalForces, other.ExternalForces)) return false;
      if (!object.Equals(RotationBySpeed, other.RotationBySpeed)) return false;
      if (!object.Equals(RotationOverLifetime, other.RotationOverLifetime)) return false;
      if (!object.Equals(SizeBySpeed, other.SizeBySpeed)) return false;
      if (!object.Equals(SizeOverLifetime, other.SizeOverLifetime)) return false;
      if (!object.Equals(ColorBySpeed, other.ColorBySpeed)) return false;
      if (!object.Equals(ColorOverLifetime, other.ColorOverLifetime)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ParentPS.Length != 0) hash ^= ParentPS.GetHashCode();
      if (renderer_ != null) hash ^= Renderer.GetHashCode();
      if (main_ != null) hash ^= Main.GetHashCode();
      if (emission_ != null) hash ^= Emission.GetHashCode();
      if (shape_ != null) hash ^= Shape.GetHashCode();
      if (velocityOverLifetime_ != null) hash ^= VelocityOverLifetime.GetHashCode();
      if (limitVelocityOverLifetime_ != null) hash ^= LimitVelocityOverLifetime.GetHashCode();
      if (inheritVelocity_ != null) hash ^= InheritVelocity.GetHashCode();
      if (forceOverLifetime_ != null) hash ^= ForceOverLifetime.GetHashCode();
      if (trails_ != null) hash ^= Trails.GetHashCode();
      if (textureSheetAnimation_ != null) hash ^= TextureSheetAnimation.GetHashCode();
      if (subEmitters_ != null) hash ^= SubEmitters.GetHashCode();
      if (trigger_ != null) hash ^= Trigger.GetHashCode();
      if (collision_ != null) hash ^= Collision.GetHashCode();
      if (noise_ != null) hash ^= Noise.GetHashCode();
      if (externalForces_ != null) hash ^= ExternalForces.GetHashCode();
      if (rotationBySpeed_ != null) hash ^= RotationBySpeed.GetHashCode();
      if (rotationOverLifetime_ != null) hash ^= RotationOverLifetime.GetHashCode();
      if (sizeBySpeed_ != null) hash ^= SizeBySpeed.GetHashCode();
      if (sizeOverLifetime_ != null) hash ^= SizeOverLifetime.GetHashCode();
      if (colorBySpeed_ != null) hash ^= ColorBySpeed.GetHashCode();
      if (colorOverLifetime_ != null) hash ^= ColorOverLifetime.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ParentPS.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ParentPS);
      }
      if (renderer_ != null) {
        output.WriteRawTag(162, 6);
        output.WriteMessage(Renderer);
      }
      if (main_ != null) {
        output.WriteRawTag(170, 6);
        output.WriteMessage(Main);
      }
      if (emission_ != null) {
        output.WriteRawTag(178, 6);
        output.WriteMessage(Emission);
      }
      if (shape_ != null) {
        output.WriteRawTag(186, 6);
        output.WriteMessage(Shape);
      }
      if (velocityOverLifetime_ != null) {
        output.WriteRawTag(194, 6);
        output.WriteMessage(VelocityOverLifetime);
      }
      if (limitVelocityOverLifetime_ != null) {
        output.WriteRawTag(202, 6);
        output.WriteMessage(LimitVelocityOverLifetime);
      }
      if (inheritVelocity_ != null) {
        output.WriteRawTag(210, 6);
        output.WriteMessage(InheritVelocity);
      }
      if (forceOverLifetime_ != null) {
        output.WriteRawTag(218, 6);
        output.WriteMessage(ForceOverLifetime);
      }
      if (trails_ != null) {
        output.WriteRawTag(234, 6);
        output.WriteMessage(Trails);
      }
      if (textureSheetAnimation_ != null) {
        output.WriteRawTag(250, 6);
        output.WriteMessage(TextureSheetAnimation);
      }
      if (subEmitters_ != null) {
        output.WriteRawTag(130, 7);
        output.WriteMessage(SubEmitters);
      }
      if (trigger_ != null) {
        output.WriteRawTag(138, 7);
        output.WriteMessage(Trigger);
      }
      if (collision_ != null) {
        output.WriteRawTag(146, 7);
        output.WriteMessage(Collision);
      }
      if (noise_ != null) {
        output.WriteRawTag(154, 7);
        output.WriteMessage(Noise);
      }
      if (externalForces_ != null) {
        output.WriteRawTag(162, 7);
        output.WriteMessage(ExternalForces);
      }
      if (rotationBySpeed_ != null) {
        output.WriteRawTag(170, 7);
        output.WriteMessage(RotationBySpeed);
      }
      if (rotationOverLifetime_ != null) {
        output.WriteRawTag(178, 7);
        output.WriteMessage(RotationOverLifetime);
      }
      if (sizeBySpeed_ != null) {
        output.WriteRawTag(186, 7);
        output.WriteMessage(SizeBySpeed);
      }
      if (sizeOverLifetime_ != null) {
        output.WriteRawTag(194, 7);
        output.WriteMessage(SizeOverLifetime);
      }
      if (colorBySpeed_ != null) {
        output.WriteRawTag(202, 7);
        output.WriteMessage(ColorBySpeed);
      }
      if (colorOverLifetime_ != null) {
        output.WriteRawTag(210, 7);
        output.WriteMessage(ColorOverLifetime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ParentPS.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ParentPS);
      }
      if (renderer_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Renderer);
      }
      if (main_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Main);
      }
      if (emission_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Emission);
      }
      if (shape_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Shape);
      }
      if (velocityOverLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(VelocityOverLifetime);
      }
      if (limitVelocityOverLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LimitVelocityOverLifetime);
      }
      if (inheritVelocity_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InheritVelocity);
      }
      if (forceOverLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ForceOverLifetime);
      }
      if (trails_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Trails);
      }
      if (textureSheetAnimation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TextureSheetAnimation);
      }
      if (subEmitters_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SubEmitters);
      }
      if (trigger_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Trigger);
      }
      if (collision_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Collision);
      }
      if (noise_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Noise);
      }
      if (externalForces_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ExternalForces);
      }
      if (rotationBySpeed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RotationBySpeed);
      }
      if (rotationOverLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RotationOverLifetime);
      }
      if (sizeBySpeed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SizeBySpeed);
      }
      if (sizeOverLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SizeOverLifetime);
      }
      if (colorBySpeed_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ColorBySpeed);
      }
      if (colorOverLifetime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ColorOverLifetime);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ParticleSystem other) {
      if (other == null) {
        return;
      }
      if (other.ParentPS.Length != 0) {
        ParentPS = other.ParentPS;
      }
      if (other.renderer_ != null) {
        if (renderer_ == null) {
          renderer_ = new global::ProtoPs.ParticleSystemRenderer();
        }
        Renderer.MergeFrom(other.Renderer);
      }
      if (other.main_ != null) {
        if (main_ == null) {
          main_ = new global::ProtoPs.MainModule();
        }
        Main.MergeFrom(other.Main);
      }
      if (other.emission_ != null) {
        if (emission_ == null) {
          emission_ = new global::ProtoPs.EmissionModule();
        }
        Emission.MergeFrom(other.Emission);
      }
      if (other.shape_ != null) {
        if (shape_ == null) {
          shape_ = new global::ProtoPs.ShapeModule();
        }
        Shape.MergeFrom(other.Shape);
      }
      if (other.velocityOverLifetime_ != null) {
        if (velocityOverLifetime_ == null) {
          velocityOverLifetime_ = new global::ProtoPs.VelocityOverLifetimeModule();
        }
        VelocityOverLifetime.MergeFrom(other.VelocityOverLifetime);
      }
      if (other.limitVelocityOverLifetime_ != null) {
        if (limitVelocityOverLifetime_ == null) {
          limitVelocityOverLifetime_ = new global::ProtoPs.LimitVelocityOverLifetimeModule();
        }
        LimitVelocityOverLifetime.MergeFrom(other.LimitVelocityOverLifetime);
      }
      if (other.inheritVelocity_ != null) {
        if (inheritVelocity_ == null) {
          inheritVelocity_ = new global::ProtoPs.InheritVelocityModule();
        }
        InheritVelocity.MergeFrom(other.InheritVelocity);
      }
      if (other.forceOverLifetime_ != null) {
        if (forceOverLifetime_ == null) {
          forceOverLifetime_ = new global::ProtoPs.ForceOverLifetimeModule();
        }
        ForceOverLifetime.MergeFrom(other.ForceOverLifetime);
      }
      if (other.trails_ != null) {
        if (trails_ == null) {
          trails_ = new global::ProtoPs.TrailModule();
        }
        Trails.MergeFrom(other.Trails);
      }
      if (other.textureSheetAnimation_ != null) {
        if (textureSheetAnimation_ == null) {
          textureSheetAnimation_ = new global::ProtoPs.TextureSheetAnimationModule();
        }
        TextureSheetAnimation.MergeFrom(other.TextureSheetAnimation);
      }
      if (other.subEmitters_ != null) {
        if (subEmitters_ == null) {
          subEmitters_ = new global::ProtoPs.SubEmittersModule();
        }
        SubEmitters.MergeFrom(other.SubEmitters);
      }
      if (other.trigger_ != null) {
        if (trigger_ == null) {
          trigger_ = new global::ProtoPs.TriggerModule();
        }
        Trigger.MergeFrom(other.Trigger);
      }
      if (other.collision_ != null) {
        if (collision_ == null) {
          collision_ = new global::ProtoPs.CollisionModule();
        }
        Collision.MergeFrom(other.Collision);
      }
      if (other.noise_ != null) {
        if (noise_ == null) {
          noise_ = new global::ProtoPs.NoiseModule();
        }
        Noise.MergeFrom(other.Noise);
      }
      if (other.externalForces_ != null) {
        if (externalForces_ == null) {
          externalForces_ = new global::ProtoPs.ExternalForcesModule();
        }
        ExternalForces.MergeFrom(other.ExternalForces);
      }
      if (other.rotationBySpeed_ != null) {
        if (rotationBySpeed_ == null) {
          rotationBySpeed_ = new global::ProtoPs.RotationBySpeedModule();
        }
        RotationBySpeed.MergeFrom(other.RotationBySpeed);
      }
      if (other.rotationOverLifetime_ != null) {
        if (rotationOverLifetime_ == null) {
          rotationOverLifetime_ = new global::ProtoPs.RotationOverLifetimeModule();
        }
        RotationOverLifetime.MergeFrom(other.RotationOverLifetime);
      }
      if (other.sizeBySpeed_ != null) {
        if (sizeBySpeed_ == null) {
          sizeBySpeed_ = new global::ProtoPs.SizeBySpeedModule();
        }
        SizeBySpeed.MergeFrom(other.SizeBySpeed);
      }
      if (other.sizeOverLifetime_ != null) {
        if (sizeOverLifetime_ == null) {
          sizeOverLifetime_ = new global::ProtoPs.SizeOverLifetimeModule();
        }
        SizeOverLifetime.MergeFrom(other.SizeOverLifetime);
      }
      if (other.colorBySpeed_ != null) {
        if (colorBySpeed_ == null) {
          colorBySpeed_ = new global::ProtoPs.ColorBySpeedModule();
        }
        ColorBySpeed.MergeFrom(other.ColorBySpeed);
      }
      if (other.colorOverLifetime_ != null) {
        if (colorOverLifetime_ == null) {
          colorOverLifetime_ = new global::ProtoPs.ColorOverLifetimeModule();
        }
        ColorOverLifetime.MergeFrom(other.ColorOverLifetime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            ParentPS = input.ReadString();
            break;
          }
          case 802: {
            if (renderer_ == null) {
              renderer_ = new global::ProtoPs.ParticleSystemRenderer();
            }
            input.ReadMessage(renderer_);
            break;
          }
          case 810: {
            if (main_ == null) {
              main_ = new global::ProtoPs.MainModule();
            }
            input.ReadMessage(main_);
            break;
          }
          case 818: {
            if (emission_ == null) {
              emission_ = new global::ProtoPs.EmissionModule();
            }
            input.ReadMessage(emission_);
            break;
          }
          case 826: {
            if (shape_ == null) {
              shape_ = new global::ProtoPs.ShapeModule();
            }
            input.ReadMessage(shape_);
            break;
          }
          case 834: {
            if (velocityOverLifetime_ == null) {
              velocityOverLifetime_ = new global::ProtoPs.VelocityOverLifetimeModule();
            }
            input.ReadMessage(velocityOverLifetime_);
            break;
          }
          case 842: {
            if (limitVelocityOverLifetime_ == null) {
              limitVelocityOverLifetime_ = new global::ProtoPs.LimitVelocityOverLifetimeModule();
            }
            input.ReadMessage(limitVelocityOverLifetime_);
            break;
          }
          case 850: {
            if (inheritVelocity_ == null) {
              inheritVelocity_ = new global::ProtoPs.InheritVelocityModule();
            }
            input.ReadMessage(inheritVelocity_);
            break;
          }
          case 858: {
            if (forceOverLifetime_ == null) {
              forceOverLifetime_ = new global::ProtoPs.ForceOverLifetimeModule();
            }
            input.ReadMessage(forceOverLifetime_);
            break;
          }
          case 874: {
            if (trails_ == null) {
              trails_ = new global::ProtoPs.TrailModule();
            }
            input.ReadMessage(trails_);
            break;
          }
          case 890: {
            if (textureSheetAnimation_ == null) {
              textureSheetAnimation_ = new global::ProtoPs.TextureSheetAnimationModule();
            }
            input.ReadMessage(textureSheetAnimation_);
            break;
          }
          case 898: {
            if (subEmitters_ == null) {
              subEmitters_ = new global::ProtoPs.SubEmittersModule();
            }
            input.ReadMessage(subEmitters_);
            break;
          }
          case 906: {
            if (trigger_ == null) {
              trigger_ = new global::ProtoPs.TriggerModule();
            }
            input.ReadMessage(trigger_);
            break;
          }
          case 914: {
            if (collision_ == null) {
              collision_ = new global::ProtoPs.CollisionModule();
            }
            input.ReadMessage(collision_);
            break;
          }
          case 922: {
            if (noise_ == null) {
              noise_ = new global::ProtoPs.NoiseModule();
            }
            input.ReadMessage(noise_);
            break;
          }
          case 930: {
            if (externalForces_ == null) {
              externalForces_ = new global::ProtoPs.ExternalForcesModule();
            }
            input.ReadMessage(externalForces_);
            break;
          }
          case 938: {
            if (rotationBySpeed_ == null) {
              rotationBySpeed_ = new global::ProtoPs.RotationBySpeedModule();
            }
            input.ReadMessage(rotationBySpeed_);
            break;
          }
          case 946: {
            if (rotationOverLifetime_ == null) {
              rotationOverLifetime_ = new global::ProtoPs.RotationOverLifetimeModule();
            }
            input.ReadMessage(rotationOverLifetime_);
            break;
          }
          case 954: {
            if (sizeBySpeed_ == null) {
              sizeBySpeed_ = new global::ProtoPs.SizeBySpeedModule();
            }
            input.ReadMessage(sizeBySpeed_);
            break;
          }
          case 962: {
            if (sizeOverLifetime_ == null) {
              sizeOverLifetime_ = new global::ProtoPs.SizeOverLifetimeModule();
            }
            input.ReadMessage(sizeOverLifetime_);
            break;
          }
          case 970: {
            if (colorBySpeed_ == null) {
              colorBySpeed_ = new global::ProtoPs.ColorBySpeedModule();
            }
            input.ReadMessage(colorBySpeed_);
            break;
          }
          case 978: {
            if (colorOverLifetime_ == null) {
              colorOverLifetime_ = new global::ProtoPs.ColorOverLifetimeModule();
            }
            input.ReadMessage(colorOverLifetime_);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
