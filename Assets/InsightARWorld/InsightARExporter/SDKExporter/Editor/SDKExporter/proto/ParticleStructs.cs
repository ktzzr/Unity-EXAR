// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: particle_structs.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ProtoPs {

  /// <summary>Holder for reflection information generated from particle_structs.proto</summary>
  public static partial class ParticleStructsReflection {

    #region Descriptor
    /// <summary>File descriptor for particle_structs.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ParticleStructsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZwYXJ0aWNsZV9zdHJ1Y3RzLnByb3RvEghwcm90b19wcxoKbWF0aC5wcm90",
            "bxoUcGFydGljbGVfZW51bXMucHJvdG8iTgoIS2V5ZnJhbWUSDAoEdGltZRgB",
            "IAEoAhINCgV2YWx1ZRgCIAEoAhIRCglpblRhbmdlbnQYAyABKAISEgoKb3V0",
            "VGFuZ2VudBgEIAEoAiKVAQoOQW5pbWF0aW9uQ3VydmUSIAoEa2V5cxhkIAMo",
            "CzISLnByb3RvX3BzLktleWZyYW1lEg4KBmxlbmd0aBhlIAEoBRInCgtwcmVX",
            "cmFwTW9kZRhmIAEoDjISLnByb3RvX3BzLldyYXBNb2RlEigKDHBvc3RXcmFw",
            "TW9kZRhnIAEoDjISLnByb3RvX3BzLldyYXBNb2RlIjkKCUN1cnZlRGF0YRIN",
            "CgV0aW1lcxgBIAMoAhINCgVkYXRhcxgCIAMoAhIOCgZsZW5ndGgYBSABKAUi",
            "jAIKC01pbk1heEN1cnZlEi8KBG1vZGUYZSABKA4yIS5wcm90b19wcy5QYXJ0",
            "aWNsZVN5c3RlbUN1cnZlTW9kZRIYCg9jdXJ2ZU11bHRpcGxpZXIYygEgASgC",
            "EiYKCGN1cnZlTWF4GMsBIAEoCzITLnByb3RvX3BzLkN1cnZlRGF0YRImCghj",
            "dXJ2ZU1pbhjMASABKAsyEy5wcm90b19wcy5DdXJ2ZURhdGESFAoLY29uc3Rh",
            "bnRNYXgYzQEgASgCEhQKC2NvbnN0YW50TWluGM4BIAEoAhIRCghjb25zdGFu",
            "dBjPASABKAISIwoFY3VydmUY0AEgASgLMhMucHJvdG9fcHMuQ3VydmVEYXRh",
            "IkMKEEdyYWRpZW50Q29sb3JLZXkSIQoFY29sb3IYASABKAsyEi5wcm90b19t",
            "YXRoLmZsb2F0NBIMCgR0aW1lGAIgASgCIi8KEEdyYWRpZW50QWxwaGFLZXkS",
            "DQoFYWxwaGEYASABKAISDAoEdGltZRgCIAEoAiKNAQoIR3JhZGllbnQSLQoJ",
            "Y29sb3JLZXlzGAEgAygLMhoucHJvdG9fcHMuR3JhZGllbnRDb2xvcktleRIs",
            "CghhbHBoYUtleRgCIAMoCzIaLnByb3RvX3BzLkdyYWRpZW50QWxwaGFLZXkS",
            "JAoEbW9kZRgDIAEoDjIWLnByb3RvX3BzLkdyYWRpZW50TW9kZSKrAgoOTWlu",
            "TWF4R3JhZGllbnQSMgoEbW9kZRgKIAEoDjIkLnByb3RvX3BzLlBhcnRpY2xl",
            "U3lzdGVtR3JhZGllbnRNb2RlEicKC2dyYWRpZW50TWF4GAsgASgLMhIucHJv",
            "dG9fcHMuR3JhZGllbnQSJwoLZ3JhZGllbnRNaW4YDCABKAsyEi5wcm90b19w",
            "cy5HcmFkaWVudBIkCghjb2xvck1heBgNIAEoCzISLnByb3RvX21hdGguZmxv",
            "YXQ0EiQKCGNvbG9yTWluGA4gASgLMhIucHJvdG9fbWF0aC5mbG9hdDQSIQoF",
            "Y29sb3IYDyABKAsyEi5wcm90b19tYXRoLmZsb2F0NBIkCghncmFkaWVudBgQ",
            "IAEoCzISLnByb3RvX3BzLkdyYWRpZW50IqQBCgVCdXJzdBIMCgR0aW1lGAEg",
            "ASgCEhAKCG1pbkNvdW50GAIgASgFEhAKCG1heENvdW50GAMgASgFEhIKCmN5",
            "Y2xlQ291bnQYBCABKAUSFgoOcmVwZWF0SW50ZXJ2YWwYBSABKAISJAoFY291",
            "bnQYBiABKAsyFS5wcm90b19wcy5NaW5NYXhDdXJ2ZRIXCg9jb3VudE11bHRp",
            "cGxpZXIYByABKAIiGgoJTGF5ZXJNYXNrEg0KBXZhbHVlGAEgASgFQgJIA2IG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::ProtoMath.MathReflection.Descriptor, global::ProtoPs.ParticleEnumsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.Keyframe), global::ProtoPs.Keyframe.Parser, new[]{ "Time", "Value", "InTangent", "OutTangent" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.AnimationCurve), global::ProtoPs.AnimationCurve.Parser, new[]{ "Keys", "Length", "PreWrapMode", "PostWrapMode" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.CurveData), global::ProtoPs.CurveData.Parser, new[]{ "Times", "Datas", "Length" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.MinMaxCurve), global::ProtoPs.MinMaxCurve.Parser, new[]{ "Mode", "CurveMultiplier", "CurveMax", "CurveMin", "ConstantMax", "ConstantMin", "Constant", "Curve" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.GradientColorKey), global::ProtoPs.GradientColorKey.Parser, new[]{ "Color", "Time" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.GradientAlphaKey), global::ProtoPs.GradientAlphaKey.Parser, new[]{ "Alpha", "Time" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.Gradient), global::ProtoPs.Gradient.Parser, new[]{ "ColorKeys", "AlphaKey", "Mode" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.MinMaxGradient), global::ProtoPs.MinMaxGradient.Parser, new[]{ "Mode", "GradientMax", "GradientMin", "ColorMax", "ColorMin", "Color", "Gradient" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.Burst), global::ProtoPs.Burst.Parser, new[]{ "Time", "MinCount", "MaxCount", "CycleCount", "RepeatInterval", "Count", "CountMultiplier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ProtoPs.LayerMask), global::ProtoPs.LayerMask.Parser, new[]{ "Value" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Keyframe : pb::IMessage<Keyframe> {
    private static readonly pb::MessageParser<Keyframe> _parser = new pb::MessageParser<Keyframe>(() => new Keyframe());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Keyframe> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Keyframe() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Keyframe(Keyframe other) : this() {
      time_ = other.time_;
      value_ = other.value_;
      inTangent_ = other.inTangent_;
      outTangent_ = other.outTangent_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Keyframe Clone() {
      return new Keyframe(this);
    }

    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 1;
    private float time_;
    /// <summary>
    ///The time of the keyframe.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private float value_;
    /// <summary>
    /// The value of the curve at keyframe.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    /// <summary>Field number for the "inTangent" field.</summary>
    public const int InTangentFieldNumber = 3;
    private float inTangent_;
    /// <summary>
    ///  Describes the tangent when approaching this point from the previous point in the curve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InTangent {
      get { return inTangent_; }
      set {
        inTangent_ = value;
      }
    }

    /// <summary>Field number for the "outTangent" field.</summary>
    public const int OutTangentFieldNumber = 4;
    private float outTangent_;
    /// <summary>
    ///Describes the tangent when leaving this point towards the next point in the curve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OutTangent {
      get { return outTangent_; }
      set {
        outTangent_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Keyframe);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Keyframe other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Time != other.Time) return false;
      if (Value != other.Value) return false;
      if (InTangent != other.InTangent) return false;
      if (OutTangent != other.OutTangent) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Time != 0F) hash ^= Time.GetHashCode();
      if (Value != 0F) hash ^= Value.GetHashCode();
      if (InTangent != 0F) hash ^= InTangent.GetHashCode();
      if (OutTangent != 0F) hash ^= OutTangent.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Time != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Time);
      }
      if (Value != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Value);
      }
      if (InTangent != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(InTangent);
      }
      if (OutTangent != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(OutTangent);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Time != 0F) {
        size += 1 + 4;
      }
      if (Value != 0F) {
        size += 1 + 4;
      }
      if (InTangent != 0F) {
        size += 1 + 4;
      }
      if (OutTangent != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Keyframe other) {
      if (other == null) {
        return;
      }
      if (other.Time != 0F) {
        Time = other.Time;
      }
      if (other.Value != 0F) {
        Value = other.Value;
      }
      if (other.InTangent != 0F) {
        InTangent = other.InTangent;
      }
      if (other.OutTangent != 0F) {
        OutTangent = other.OutTangent;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            Time = input.ReadFloat();
            break;
          }
          case 21: {
            Value = input.ReadFloat();
            break;
          }
          case 29: {
            InTangent = input.ReadFloat();
            break;
          }
          case 37: {
            OutTangent = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class AnimationCurve : pb::IMessage<AnimationCurve> {
    private static readonly pb::MessageParser<AnimationCurve> _parser = new pb::MessageParser<AnimationCurve>(() => new AnimationCurve());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AnimationCurve> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AnimationCurve() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AnimationCurve(AnimationCurve other) : this() {
      keys_ = other.keys_.Clone();
      length_ = other.length_;
      preWrapMode_ = other.preWrapMode_;
      postWrapMode_ = other.postWrapMode_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AnimationCurve Clone() {
      return new AnimationCurve(this);
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 100;
    private static readonly pb::FieldCodec<global::ProtoPs.Keyframe> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(802, global::ProtoPs.Keyframe.Parser);
    private readonly pbc::RepeatedField<global::ProtoPs.Keyframe> keys_ = new pbc::RepeatedField<global::ProtoPs.Keyframe>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ProtoPs.Keyframe> Keys {
      get { return keys_; }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 101;
    private int length_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    /// <summary>Field number for the "preWrapMode" field.</summary>
    public const int PreWrapModeFieldNumber = 102;
    private global::ProtoPs.WrapMode preWrapMode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.WrapMode PreWrapMode {
      get { return preWrapMode_; }
      set {
        preWrapMode_ = value;
      }
    }

    /// <summary>Field number for the "postWrapMode" field.</summary>
    public const int PostWrapModeFieldNumber = 103;
    private global::ProtoPs.WrapMode postWrapMode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.WrapMode PostWrapMode {
      get { return postWrapMode_; }
      set {
        postWrapMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AnimationCurve);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AnimationCurve other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keys_.Equals(other.keys_)) return false;
      if (Length != other.Length) return false;
      if (PreWrapMode != other.PreWrapMode) return false;
      if (PostWrapMode != other.PostWrapMode) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keys_.GetHashCode();
      if (Length != 0) hash ^= Length.GetHashCode();
      if (PreWrapMode != 0) hash ^= PreWrapMode.GetHashCode();
      if (PostWrapMode != 0) hash ^= PostWrapMode.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      keys_.WriteTo(output, _repeated_keys_codec);
      if (Length != 0) {
        output.WriteRawTag(168, 6);
        output.WriteInt32(Length);
      }
      if (PreWrapMode != 0) {
        output.WriteRawTag(176, 6);
        output.WriteEnum((int) PreWrapMode);
      }
      if (PostWrapMode != 0) {
        output.WriteRawTag(184, 6);
        output.WriteEnum((int) PostWrapMode);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Length);
      }
      if (PreWrapMode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PreWrapMode);
      }
      if (PostWrapMode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PostWrapMode);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AnimationCurve other) {
      if (other == null) {
        return;
      }
      keys_.Add(other.keys_);
      if (other.Length != 0) {
        Length = other.Length;
      }
      if (other.PreWrapMode != 0) {
        PreWrapMode = other.PreWrapMode;
      }
      if (other.PostWrapMode != 0) {
        PostWrapMode = other.PostWrapMode;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 802: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
          case 808: {
            Length = input.ReadInt32();
            break;
          }
          case 816: {
            preWrapMode_ = (global::ProtoPs.WrapMode) input.ReadEnum();
            break;
          }
          case 824: {
            postWrapMode_ = (global::ProtoPs.WrapMode) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class CurveData : pb::IMessage<CurveData> {
    private static readonly pb::MessageParser<CurveData> _parser = new pb::MessageParser<CurveData>(() => new CurveData());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CurveData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CurveData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CurveData(CurveData other) : this() {
      times_ = other.times_.Clone();
      datas_ = other.datas_.Clone();
      length_ = other.length_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CurveData Clone() {
      return new CurveData(this);
    }

    /// <summary>Field number for the "times" field.</summary>
    public const int TimesFieldNumber = 1;
    private static readonly pb::FieldCodec<float> _repeated_times_codec
        = pb::FieldCodec.ForFloat(10);
    private readonly pbc::RepeatedField<float> times_ = new pbc::RepeatedField<float>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> Times {
      get { return times_; }
    }

    /// <summary>Field number for the "datas" field.</summary>
    public const int DatasFieldNumber = 2;
    private static readonly pb::FieldCodec<float> _repeated_datas_codec
        = pb::FieldCodec.ForFloat(18);
    private readonly pbc::RepeatedField<float> datas_ = new pbc::RepeatedField<float>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> Datas {
      get { return datas_; }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 5;
    private int length_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CurveData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CurveData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!times_.Equals(other.times_)) return false;
      if(!datas_.Equals(other.datas_)) return false;
      if (Length != other.Length) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= times_.GetHashCode();
      hash ^= datas_.GetHashCode();
      if (Length != 0) hash ^= Length.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      times_.WriteTo(output, _repeated_times_codec);
      datas_.WriteTo(output, _repeated_datas_codec);
      if (Length != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(Length);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += times_.CalculateSize(_repeated_times_codec);
      size += datas_.CalculateSize(_repeated_datas_codec);
      if (Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Length);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CurveData other) {
      if (other == null) {
        return;
      }
      times_.Add(other.times_);
      datas_.Add(other.datas_);
      if (other.Length != 0) {
        Length = other.Length;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 13: {
            times_.AddEntriesFrom(input, _repeated_times_codec);
            break;
          }
          case 18:
          case 21: {
            datas_.AddEntriesFrom(input, _repeated_datas_codec);
            break;
          }
          case 40: {
            Length = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class MinMaxCurve : pb::IMessage<MinMaxCurve> {
    private static readonly pb::MessageParser<MinMaxCurve> _parser = new pb::MessageParser<MinMaxCurve>(() => new MinMaxCurve());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MinMaxCurve> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinMaxCurve() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinMaxCurve(MinMaxCurve other) : this() {
      mode_ = other.mode_;
      curveMultiplier_ = other.curveMultiplier_;
      CurveMax = other.curveMax_ != null ? other.CurveMax.Clone() : null;
      CurveMin = other.curveMin_ != null ? other.CurveMin.Clone() : null;
      constantMax_ = other.constantMax_;
      constantMin_ = other.constantMin_;
      constant_ = other.constant_;
      Curve = other.curve_ != null ? other.Curve.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinMaxCurve Clone() {
      return new MinMaxCurve(this);
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 101;
    private global::ProtoPs.ParticleSystemCurveMode mode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemCurveMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    /// <summary>Field number for the "curveMultiplier" field.</summary>
    public const int CurveMultiplierFieldNumber = 202;
    private float curveMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float CurveMultiplier {
      get { return curveMultiplier_; }
      set {
        curveMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "curveMax" field.</summary>
    public const int CurveMaxFieldNumber = 203;
    private global::ProtoPs.CurveData curveMax_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.CurveData CurveMax {
      get { return curveMax_; }
      set {
        curveMax_ = value;
      }
    }

    /// <summary>Field number for the "curveMin" field.</summary>
    public const int CurveMinFieldNumber = 204;
    private global::ProtoPs.CurveData curveMin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.CurveData CurveMin {
      get { return curveMin_; }
      set {
        curveMin_ = value;
      }
    }

    /// <summary>Field number for the "constantMax" field.</summary>
    public const int ConstantMaxFieldNumber = 205;
    private float constantMax_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ConstantMax {
      get { return constantMax_; }
      set {
        constantMax_ = value;
      }
    }

    /// <summary>Field number for the "constantMin" field.</summary>
    public const int ConstantMinFieldNumber = 206;
    private float constantMin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ConstantMin {
      get { return constantMin_; }
      set {
        constantMin_ = value;
      }
    }

    /// <summary>Field number for the "constant" field.</summary>
    public const int ConstantFieldNumber = 207;
    private float constant_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Constant {
      get { return constant_; }
      set {
        constant_ = value;
      }
    }

    /// <summary>Field number for the "curve" field.</summary>
    public const int CurveFieldNumber = 208;
    private global::ProtoPs.CurveData curve_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.CurveData Curve {
      get { return curve_; }
      set {
        curve_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MinMaxCurve);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MinMaxCurve other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Mode != other.Mode) return false;
      if (CurveMultiplier != other.CurveMultiplier) return false;
      if (!object.Equals(CurveMax, other.CurveMax)) return false;
      if (!object.Equals(CurveMin, other.CurveMin)) return false;
      if (ConstantMax != other.ConstantMax) return false;
      if (ConstantMin != other.ConstantMin) return false;
      if (Constant != other.Constant) return false;
      if (!object.Equals(Curve, other.Curve)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (CurveMultiplier != 0F) hash ^= CurveMultiplier.GetHashCode();
      if (curveMax_ != null) hash ^= CurveMax.GetHashCode();
      if (curveMin_ != null) hash ^= CurveMin.GetHashCode();
      if (ConstantMax != 0F) hash ^= ConstantMax.GetHashCode();
      if (ConstantMin != 0F) hash ^= ConstantMin.GetHashCode();
      if (Constant != 0F) hash ^= Constant.GetHashCode();
      if (curve_ != null) hash ^= Curve.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Mode != 0) {
        output.WriteRawTag(168, 6);
        output.WriteEnum((int) Mode);
      }
      if (CurveMultiplier != 0F) {
        output.WriteRawTag(213, 12);
        output.WriteFloat(CurveMultiplier);
      }
      if (curveMax_ != null) {
        output.WriteRawTag(218, 12);
        output.WriteMessage(CurveMax);
      }
      if (curveMin_ != null) {
        output.WriteRawTag(226, 12);
        output.WriteMessage(CurveMin);
      }
      if (ConstantMax != 0F) {
        output.WriteRawTag(237, 12);
        output.WriteFloat(ConstantMax);
      }
      if (ConstantMin != 0F) {
        output.WriteRawTag(245, 12);
        output.WriteFloat(ConstantMin);
      }
      if (Constant != 0F) {
        output.WriteRawTag(253, 12);
        output.WriteFloat(Constant);
      }
      if (curve_ != null) {
        output.WriteRawTag(130, 13);
        output.WriteMessage(Curve);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Mode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (CurveMultiplier != 0F) {
        size += 2 + 4;
      }
      if (curveMax_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CurveMax);
      }
      if (curveMin_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CurveMin);
      }
      if (ConstantMax != 0F) {
        size += 2 + 4;
      }
      if (ConstantMin != 0F) {
        size += 2 + 4;
      }
      if (Constant != 0F) {
        size += 2 + 4;
      }
      if (curve_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Curve);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MinMaxCurve other) {
      if (other == null) {
        return;
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      if (other.CurveMultiplier != 0F) {
        CurveMultiplier = other.CurveMultiplier;
      }
      if (other.curveMax_ != null) {
        if (curveMax_ == null) {
          curveMax_ = new global::ProtoPs.CurveData();
        }
        CurveMax.MergeFrom(other.CurveMax);
      }
      if (other.curveMin_ != null) {
        if (curveMin_ == null) {
          curveMin_ = new global::ProtoPs.CurveData();
        }
        CurveMin.MergeFrom(other.CurveMin);
      }
      if (other.ConstantMax != 0F) {
        ConstantMax = other.ConstantMax;
      }
      if (other.ConstantMin != 0F) {
        ConstantMin = other.ConstantMin;
      }
      if (other.Constant != 0F) {
        Constant = other.Constant;
      }
      if (other.curve_ != null) {
        if (curve_ == null) {
          curve_ = new global::ProtoPs.CurveData();
        }
        Curve.MergeFrom(other.Curve);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 808: {
            mode_ = (global::ProtoPs.ParticleSystemCurveMode) input.ReadEnum();
            break;
          }
          case 1621: {
            CurveMultiplier = input.ReadFloat();
            break;
          }
          case 1626: {
            if (curveMax_ == null) {
              curveMax_ = new global::ProtoPs.CurveData();
            }
            input.ReadMessage(curveMax_);
            break;
          }
          case 1634: {
            if (curveMin_ == null) {
              curveMin_ = new global::ProtoPs.CurveData();
            }
            input.ReadMessage(curveMin_);
            break;
          }
          case 1645: {
            ConstantMax = input.ReadFloat();
            break;
          }
          case 1653: {
            ConstantMin = input.ReadFloat();
            break;
          }
          case 1661: {
            Constant = input.ReadFloat();
            break;
          }
          case 1666: {
            if (curve_ == null) {
              curve_ = new global::ProtoPs.CurveData();
            }
            input.ReadMessage(curve_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class GradientColorKey : pb::IMessage<GradientColorKey> {
    private static readonly pb::MessageParser<GradientColorKey> _parser = new pb::MessageParser<GradientColorKey>(() => new GradientColorKey());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GradientColorKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GradientColorKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GradientColorKey(GradientColorKey other) : this() {
      Color = other.color_ != null ? other.Color.Clone() : null;
      time_ = other.time_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GradientColorKey Clone() {
      return new GradientColorKey(this);
    }

    /// <summary>Field number for the "color" field.</summary>
    public const int ColorFieldNumber = 1;
    private global::ProtoMath.float4 color_;
    /// <summary>
    ///Color of key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float4 Color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 2;
    private float time_;
    /// <summary>
    ///Time of the key (0 - 1).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GradientColorKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GradientColorKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Color, other.Color)) return false;
      if (Time != other.Time) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (color_ != null) hash ^= Color.GetHashCode();
      if (Time != 0F) hash ^= Time.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (color_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Color);
      }
      if (Time != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Time);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (color_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Color);
      }
      if (Time != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GradientColorKey other) {
      if (other == null) {
        return;
      }
      if (other.color_ != null) {
        if (color_ == null) {
          color_ = new global::ProtoMath.float4();
        }
        Color.MergeFrom(other.Color);
      }
      if (other.Time != 0F) {
        Time = other.Time;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (color_ == null) {
              color_ = new global::ProtoMath.float4();
            }
            input.ReadMessage(color_);
            break;
          }
          case 21: {
            Time = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class GradientAlphaKey : pb::IMessage<GradientAlphaKey> {
    private static readonly pb::MessageParser<GradientAlphaKey> _parser = new pb::MessageParser<GradientAlphaKey>(() => new GradientAlphaKey());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GradientAlphaKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GradientAlphaKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GradientAlphaKey(GradientAlphaKey other) : this() {
      alpha_ = other.alpha_;
      time_ = other.time_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GradientAlphaKey Clone() {
      return new GradientAlphaKey(this);
    }

    /// <summary>Field number for the "alpha" field.</summary>
    public const int AlphaFieldNumber = 1;
    private float alpha_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Alpha {
      get { return alpha_; }
      set {
        alpha_ = value;
      }
    }

    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 2;
    private float time_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GradientAlphaKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GradientAlphaKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Alpha != other.Alpha) return false;
      if (Time != other.Time) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Alpha != 0F) hash ^= Alpha.GetHashCode();
      if (Time != 0F) hash ^= Time.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Alpha != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Alpha);
      }
      if (Time != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Time);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Alpha != 0F) {
        size += 1 + 4;
      }
      if (Time != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GradientAlphaKey other) {
      if (other == null) {
        return;
      }
      if (other.Alpha != 0F) {
        Alpha = other.Alpha;
      }
      if (other.Time != 0F) {
        Time = other.Time;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            Alpha = input.ReadFloat();
            break;
          }
          case 21: {
            Time = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Gradient : pb::IMessage<Gradient> {
    private static readonly pb::MessageParser<Gradient> _parser = new pb::MessageParser<Gradient>(() => new Gradient());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Gradient> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Gradient() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Gradient(Gradient other) : this() {
      colorKeys_ = other.colorKeys_.Clone();
      alphaKey_ = other.alphaKey_.Clone();
      mode_ = other.mode_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Gradient Clone() {
      return new Gradient(this);
    }

    /// <summary>Field number for the "colorKeys" field.</summary>
    public const int ColorKeysFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ProtoPs.GradientColorKey> _repeated_colorKeys_codec
        = pb::FieldCodec.ForMessage(10, global::ProtoPs.GradientColorKey.Parser);
    private readonly pbc::RepeatedField<global::ProtoPs.GradientColorKey> colorKeys_ = new pbc::RepeatedField<global::ProtoPs.GradientColorKey>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ProtoPs.GradientColorKey> ColorKeys {
      get { return colorKeys_; }
    }

    /// <summary>Field number for the "alphaKey" field.</summary>
    public const int AlphaKeyFieldNumber = 2;
    private static readonly pb::FieldCodec<global::ProtoPs.GradientAlphaKey> _repeated_alphaKey_codec
        = pb::FieldCodec.ForMessage(18, global::ProtoPs.GradientAlphaKey.Parser);
    private readonly pbc::RepeatedField<global::ProtoPs.GradientAlphaKey> alphaKey_ = new pbc::RepeatedField<global::ProtoPs.GradientAlphaKey>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ProtoPs.GradientAlphaKey> AlphaKey {
      get { return alphaKey_; }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 3;
    private global::ProtoPs.GradientMode mode_ = 0;
    /// <summary>
    ///     Control how the gradient is evaluated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.GradientMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Gradient);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Gradient other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!colorKeys_.Equals(other.colorKeys_)) return false;
      if(!alphaKey_.Equals(other.alphaKey_)) return false;
      if (Mode != other.Mode) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= colorKeys_.GetHashCode();
      hash ^= alphaKey_.GetHashCode();
      if (Mode != 0) hash ^= Mode.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      colorKeys_.WriteTo(output, _repeated_colorKeys_codec);
      alphaKey_.WriteTo(output, _repeated_alphaKey_codec);
      if (Mode != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Mode);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += colorKeys_.CalculateSize(_repeated_colorKeys_codec);
      size += alphaKey_.CalculateSize(_repeated_alphaKey_codec);
      if (Mode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Gradient other) {
      if (other == null) {
        return;
      }
      colorKeys_.Add(other.colorKeys_);
      alphaKey_.Add(other.alphaKey_);
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            colorKeys_.AddEntriesFrom(input, _repeated_colorKeys_codec);
            break;
          }
          case 18: {
            alphaKey_.AddEntriesFrom(input, _repeated_alphaKey_codec);
            break;
          }
          case 24: {
            mode_ = (global::ProtoPs.GradientMode) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class MinMaxGradient : pb::IMessage<MinMaxGradient> {
    private static readonly pb::MessageParser<MinMaxGradient> _parser = new pb::MessageParser<MinMaxGradient>(() => new MinMaxGradient());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MinMaxGradient> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinMaxGradient() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinMaxGradient(MinMaxGradient other) : this() {
      mode_ = other.mode_;
      GradientMax = other.gradientMax_ != null ? other.GradientMax.Clone() : null;
      GradientMin = other.gradientMin_ != null ? other.GradientMin.Clone() : null;
      ColorMax = other.colorMax_ != null ? other.ColorMax.Clone() : null;
      ColorMin = other.colorMin_ != null ? other.ColorMin.Clone() : null;
      Color = other.color_ != null ? other.Color.Clone() : null;
      Gradient = other.gradient_ != null ? other.Gradient.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinMaxGradient Clone() {
      return new MinMaxGradient(this);
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 10;
    private global::ProtoPs.ParticleSystemGradientMode mode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.ParticleSystemGradientMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    /// <summary>Field number for the "gradientMax" field.</summary>
    public const int GradientMaxFieldNumber = 11;
    private global::ProtoPs.Gradient gradientMax_;
    /// <summary>
    ///     Set a gradient for the upper bound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.Gradient GradientMax {
      get { return gradientMax_; }
      set {
        gradientMax_ = value;
      }
    }

    /// <summary>Field number for the "gradientMin" field.</summary>
    public const int GradientMinFieldNumber = 12;
    private global::ProtoPs.Gradient gradientMin_;
    /// <summary>
    ///     Set a gradient for the lower bound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.Gradient GradientMin {
      get { return gradientMin_; }
      set {
        gradientMin_ = value;
      }
    }

    /// <summary>Field number for the "colorMax" field.</summary>
    public const int ColorMaxFieldNumber = 13;
    private global::ProtoMath.float4 colorMax_;
    /// <summary>
    ///     Set a constant color for the upper bound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float4 ColorMax {
      get { return colorMax_; }
      set {
        colorMax_ = value;
      }
    }

    /// <summary>Field number for the "colorMin" field.</summary>
    public const int ColorMinFieldNumber = 14;
    private global::ProtoMath.float4 colorMin_;
    /// <summary>
    ///     Set a constant color for the lower bound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float4 ColorMin {
      get { return colorMin_; }
      set {
        colorMin_ = value;
      }
    }

    /// <summary>Field number for the "color" field.</summary>
    public const int ColorFieldNumber = 15;
    private global::ProtoMath.float4 color_;
    /// <summary>
    ///     Set a constant color.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoMath.float4 Color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    /// <summary>Field number for the "gradient" field.</summary>
    public const int GradientFieldNumber = 16;
    private global::ProtoPs.Gradient gradient_;
    /// <summary>
    ///     Set the gradient.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.Gradient Gradient {
      get { return gradient_; }
      set {
        gradient_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MinMaxGradient);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MinMaxGradient other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Mode != other.Mode) return false;
      if (!object.Equals(GradientMax, other.GradientMax)) return false;
      if (!object.Equals(GradientMin, other.GradientMin)) return false;
      if (!object.Equals(ColorMax, other.ColorMax)) return false;
      if (!object.Equals(ColorMin, other.ColorMin)) return false;
      if (!object.Equals(Color, other.Color)) return false;
      if (!object.Equals(Gradient, other.Gradient)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (gradientMax_ != null) hash ^= GradientMax.GetHashCode();
      if (gradientMin_ != null) hash ^= GradientMin.GetHashCode();
      if (colorMax_ != null) hash ^= ColorMax.GetHashCode();
      if (colorMin_ != null) hash ^= ColorMin.GetHashCode();
      if (color_ != null) hash ^= Color.GetHashCode();
      if (gradient_ != null) hash ^= Gradient.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Mode != 0) {
        output.WriteRawTag(80);
        output.WriteEnum((int) Mode);
      }
      if (gradientMax_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(GradientMax);
      }
      if (gradientMin_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(GradientMin);
      }
      if (colorMax_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(ColorMax);
      }
      if (colorMin_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(ColorMin);
      }
      if (color_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Color);
      }
      if (gradient_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(Gradient);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Mode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (gradientMax_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GradientMax);
      }
      if (gradientMin_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GradientMin);
      }
      if (colorMax_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorMax);
      }
      if (colorMin_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorMin);
      }
      if (color_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Color);
      }
      if (gradient_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Gradient);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MinMaxGradient other) {
      if (other == null) {
        return;
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      if (other.gradientMax_ != null) {
        if (gradientMax_ == null) {
          gradientMax_ = new global::ProtoPs.Gradient();
        }
        GradientMax.MergeFrom(other.GradientMax);
      }
      if (other.gradientMin_ != null) {
        if (gradientMin_ == null) {
          gradientMin_ = new global::ProtoPs.Gradient();
        }
        GradientMin.MergeFrom(other.GradientMin);
      }
      if (other.colorMax_ != null) {
        if (colorMax_ == null) {
          colorMax_ = new global::ProtoMath.float4();
        }
        ColorMax.MergeFrom(other.ColorMax);
      }
      if (other.colorMin_ != null) {
        if (colorMin_ == null) {
          colorMin_ = new global::ProtoMath.float4();
        }
        ColorMin.MergeFrom(other.ColorMin);
      }
      if (other.color_ != null) {
        if (color_ == null) {
          color_ = new global::ProtoMath.float4();
        }
        Color.MergeFrom(other.Color);
      }
      if (other.gradient_ != null) {
        if (gradient_ == null) {
          gradient_ = new global::ProtoPs.Gradient();
        }
        Gradient.MergeFrom(other.Gradient);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 80: {
            mode_ = (global::ProtoPs.ParticleSystemGradientMode) input.ReadEnum();
            break;
          }
          case 90: {
            if (gradientMax_ == null) {
              gradientMax_ = new global::ProtoPs.Gradient();
            }
            input.ReadMessage(gradientMax_);
            break;
          }
          case 98: {
            if (gradientMin_ == null) {
              gradientMin_ = new global::ProtoPs.Gradient();
            }
            input.ReadMessage(gradientMin_);
            break;
          }
          case 106: {
            if (colorMax_ == null) {
              colorMax_ = new global::ProtoMath.float4();
            }
            input.ReadMessage(colorMax_);
            break;
          }
          case 114: {
            if (colorMin_ == null) {
              colorMin_ = new global::ProtoMath.float4();
            }
            input.ReadMessage(colorMin_);
            break;
          }
          case 122: {
            if (color_ == null) {
              color_ = new global::ProtoMath.float4();
            }
            input.ReadMessage(color_);
            break;
          }
          case 130: {
            if (gradient_ == null) {
              gradient_ = new global::ProtoPs.Gradient();
            }
            input.ReadMessage(gradient_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Burst : pb::IMessage<Burst> {
    private static readonly pb::MessageParser<Burst> _parser = new pb::MessageParser<Burst>(() => new Burst());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Burst> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Burst() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Burst(Burst other) : this() {
      time_ = other.time_;
      minCount_ = other.minCount_;
      maxCount_ = other.maxCount_;
      cycleCount_ = other.cycleCount_;
      repeatInterval_ = other.repeatInterval_;
      Count = other.count_ != null ? other.Count.Clone() : null;
      countMultiplier_ = other.countMultiplier_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Burst Clone() {
      return new Burst(this);
    }

    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 1;
    private float time_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    /// <summary>Field number for the "minCount" field.</summary>
    public const int MinCountFieldNumber = 2;
    private int minCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinCount {
      get { return minCount_; }
      set {
        minCount_ = value;
      }
    }

    /// <summary>Field number for the "maxCount" field.</summary>
    public const int MaxCountFieldNumber = 3;
    private int maxCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxCount {
      get { return maxCount_; }
      set {
        maxCount_ = value;
      }
    }

    /// <summary>Field number for the "cycleCount" field.</summary>
    public const int CycleCountFieldNumber = 4;
    private int cycleCount_;
    /// <summary>
    ///(0 means infinitely).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CycleCount {
      get { return cycleCount_; }
      set {
        cycleCount_ = value;
      }
    }

    /// <summary>Field number for the "repeatInterval" field.</summary>
    public const int RepeatIntervalFieldNumber = 5;
    private float repeatInterval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RepeatInterval {
      get { return repeatInterval_; }
      set {
        repeatInterval_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 6;
    private global::ProtoPs.MinMaxCurve count_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ProtoPs.MinMaxCurve Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "countMultiplier" field.</summary>
    public const int CountMultiplierFieldNumber = 7;
    private float countMultiplier_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float CountMultiplier {
      get { return countMultiplier_; }
      set {
        countMultiplier_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Burst);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Burst other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Time != other.Time) return false;
      if (MinCount != other.MinCount) return false;
      if (MaxCount != other.MaxCount) return false;
      if (CycleCount != other.CycleCount) return false;
      if (RepeatInterval != other.RepeatInterval) return false;
      if (!object.Equals(Count, other.Count)) return false;
      if (CountMultiplier != other.CountMultiplier) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Time != 0F) hash ^= Time.GetHashCode();
      if (MinCount != 0) hash ^= MinCount.GetHashCode();
      if (MaxCount != 0) hash ^= MaxCount.GetHashCode();
      if (CycleCount != 0) hash ^= CycleCount.GetHashCode();
      if (RepeatInterval != 0F) hash ^= RepeatInterval.GetHashCode();
      if (count_ != null) hash ^= Count.GetHashCode();
      if (CountMultiplier != 0F) hash ^= CountMultiplier.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Time != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Time);
      }
      if (MinCount != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MinCount);
      }
      if (MaxCount != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxCount);
      }
      if (CycleCount != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(CycleCount);
      }
      if (RepeatInterval != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(RepeatInterval);
      }
      if (count_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Count);
      }
      if (CountMultiplier != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(CountMultiplier);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Time != 0F) {
        size += 1 + 4;
      }
      if (MinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinCount);
      }
      if (MaxCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxCount);
      }
      if (CycleCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CycleCount);
      }
      if (RepeatInterval != 0F) {
        size += 1 + 4;
      }
      if (count_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Count);
      }
      if (CountMultiplier != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Burst other) {
      if (other == null) {
        return;
      }
      if (other.Time != 0F) {
        Time = other.Time;
      }
      if (other.MinCount != 0) {
        MinCount = other.MinCount;
      }
      if (other.MaxCount != 0) {
        MaxCount = other.MaxCount;
      }
      if (other.CycleCount != 0) {
        CycleCount = other.CycleCount;
      }
      if (other.RepeatInterval != 0F) {
        RepeatInterval = other.RepeatInterval;
      }
      if (other.count_ != null) {
        if (count_ == null) {
          count_ = new global::ProtoPs.MinMaxCurve();
        }
        Count.MergeFrom(other.Count);
      }
      if (other.CountMultiplier != 0F) {
        CountMultiplier = other.CountMultiplier;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            Time = input.ReadFloat();
            break;
          }
          case 16: {
            MinCount = input.ReadInt32();
            break;
          }
          case 24: {
            MaxCount = input.ReadInt32();
            break;
          }
          case 32: {
            CycleCount = input.ReadInt32();
            break;
          }
          case 45: {
            RepeatInterval = input.ReadFloat();
            break;
          }
          case 50: {
            if (count_ == null) {
              count_ = new global::ProtoPs.MinMaxCurve();
            }
            input.ReadMessage(count_);
            break;
          }
          case 61: {
            CountMultiplier = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class LayerMask : pb::IMessage<LayerMask> {
    private static readonly pb::MessageParser<LayerMask> _parser = new pb::MessageParser<LayerMask>(() => new LayerMask());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LayerMask> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ProtoPs.ParticleStructsReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LayerMask() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LayerMask(LayerMask other) : this() {
      value_ = other.value_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LayerMask Clone() {
      return new LayerMask(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private int value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LayerMask);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LayerMask other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Value != other.Value) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Value != 0) hash ^= Value.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Value != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Value);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Value != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Value);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LayerMask other) {
      if (other == null) {
        return;
      }
      if (other.Value != 0) {
        Value = other.Value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Value = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
